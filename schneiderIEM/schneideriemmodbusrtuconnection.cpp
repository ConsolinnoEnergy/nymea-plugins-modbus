/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Copyright 2013 - 2022, nymea GmbH
* Contact: contact@nymea.io
*
* This fileDescriptor is part of nymea.
* This project including source code and documentation is protected by
* copyright law, and remains the property of nymea GmbH. All rights, including
* reproduction, publication, editing and translation, are reserved. The use of
* this project is subject to the terms of a license agreement to be concluded
* with nymea GmbH in accordance with the terms of use of nymea GmbH, available
* under https://nymea.io/license
*
* GNU Lesser General Public License Usage
* Alternatively, this project may be redistributed and/or modified under the
* terms of the GNU Lesser General Public License as published by the Free
* Software Foundation; version 3. This project is distributed in the hope that
* it will be useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this project. If not, see <https://www.gnu.org/licenses/>.
*
* For any further details and any questions please contact us under
* contact@nymea.io or see our FAQ/Licensing Information on
* https://nymea.io/license/faq
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WARNING
*
* This file has been autogenerated. Any changes in this file may be overwritten.
* If you want to change something, update the register json or the tool.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#include "schneideriemmodbusrtuconnection.h"
#include <loggingcategories.h>
#include <math.h>
#include <QTimer>

NYMEA_LOGGING_CATEGORY(dcSchneiderIEMModbusRtuConnection, "SchneiderIEMModbusRtuConnection")

SchneiderIEMModbusRtuConnection::SchneiderIEMModbusRtuConnection(ModbusRtuMaster *modbusRtuMaster, quint16 slaveId, QObject *parent) :
    QObject(parent),
    m_modbusRtuMaster(modbusRtuMaster),
    m_slaveId(slaveId)
{
    connect(m_modbusRtuMaster, &ModbusRtuMaster::connectedChanged, this, [=](bool connected){
        if (connected) {
            qCDebug(dcSchneiderIEMModbusRtuConnection()) << "Modbus RTU resource" << m_modbusRtuMaster->serialPort() << "connected again. Start testing if the connection is reachable...";
            m_pendingInitReplies.clear();
            m_pendingUpdateReplies.clear();
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
            testReachability();
        } else {
            qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Modbus RTU resource" << m_modbusRtuMaster->serialPort() << "disconnected. The connection is not reachable any more.";
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
        }

        evaluateReachableState();
    });
}

ModbusRtuMaster *SchneiderIEMModbusRtuConnection::modbusRtuMaster() const
{
    return m_modbusRtuMaster;
}
quint16 SchneiderIEMModbusRtuConnection::slaveId() const
{
    return m_slaveId;
}

bool SchneiderIEMModbusRtuConnection::reachable() const
{
    return m_reachable;
}

uint SchneiderIEMModbusRtuConnection::checkReachableRetries() const
{
    return m_checkReachableRetries;
}

void SchneiderIEMModbusRtuConnection::setCheckReachableRetries(uint checkReachableRetries)
{
    if (m_checkReachableRetries == checkReachableRetries)
        return;

    m_checkReachableRetries = checkReachableRetries;
    emit checkReachableRetriesChanged(m_checkReachableRetries);
}

ModbusDataUtils::ByteOrder SchneiderIEMModbusRtuConnection::endianness() const
{
    return m_endianness;
}

void SchneiderIEMModbusRtuConnection::setEndianness(ModbusDataUtils::ByteOrder endianness)
{
    if (m_endianness == endianness)
        return;

    m_endianness = endianness;
    emit endiannessChanged(m_endianness);
}

float SchneiderIEMModbusRtuConnection::totalCurrentPower() const
{
    return m_totalCurrentPower;
}

float SchneiderIEMModbusRtuConnection::voltagePhaseA() const
{
    return m_voltagePhaseA;
}

float SchneiderIEMModbusRtuConnection::voltagePhaseB() const
{
    return m_voltagePhaseB;
}

float SchneiderIEMModbusRtuConnection::voltagePhaseC() const
{
    return m_voltagePhaseC;
}

float SchneiderIEMModbusRtuConnection::currentPhaseA() const
{
    return m_currentPhaseA;
}

float SchneiderIEMModbusRtuConnection::currentPhaseB() const
{
    return m_currentPhaseB;
}

float SchneiderIEMModbusRtuConnection::currentPhaseC() const
{
    return m_currentPhaseC;
}

float SchneiderIEMModbusRtuConnection::powerPhaseA() const
{
    return m_powerPhaseA;
}

float SchneiderIEMModbusRtuConnection::powerPhaseB() const
{
    return m_powerPhaseB;
}

float SchneiderIEMModbusRtuConnection::powerPhaseC() const
{
    return m_powerPhaseC;
}

float SchneiderIEMModbusRtuConnection::frequency() const
{
    return m_frequency;
}

qint64 SchneiderIEMModbusRtuConnection::totalEnergyConsumed() const
{
    return m_totalEnergyConsumed;
}

qint64 SchneiderIEMModbusRtuConnection::totalEnergyProduced() const
{
    return m_totalEnergyProduced;
}

qint64 SchneiderIEMModbusRtuConnection::energyConsumedPhaseA() const
{
    return m_energyConsumedPhaseA;
}

qint64 SchneiderIEMModbusRtuConnection::energyConsumedPhaseB() const
{
    return m_energyConsumedPhaseB;
}

qint64 SchneiderIEMModbusRtuConnection::energyConsumedPhaseC() const
{
    return m_energyConsumedPhaseC;
}

bool SchneiderIEMModbusRtuConnection::initialize()
{
    if (!m_reachable) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Tried to initialize but the device is not to be reachable.";
        return false;
    }
    // No init registers defined. Nothing to be done and we are finished.
    emit initializationFinished(true);
    return true;
}

bool SchneiderIEMModbusRtuConnection::update()
{
    if (!m_modbusRtuMaster->connected()) {
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "Tried to update the registers but the hardware resource seems not to be connected.";
        return false;
    }

    if (!m_pendingUpdateReplies.isEmpty()) {
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "Tried to update the registers but there are still some update replies pending. Waiting for them to be finished...";
        return true;
    }

    // Hardware resource available but communication not working. 
    // Try to read the check reachability register to re-evaluatoe the communication... 
    if (m_modbusRtuMaster->connected() && !m_communicationWorking) {
        testReachability();
        return false;
    }

    ModbusRtuReply *reply = nullptr;

    // Read Total system power
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Total system power\" register:" << 3059 << "size:" << 2;
    reply = readTotalCurrentPower();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Total system power\" registers";
        return false;
    }

    if (reply->isFinished()) {
        return false; // Broadcast reply returns immediatly
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        m_pendingUpdateReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            verifyUpdateFinished();
            return;
        }

        QVector<quint16> values = reply->result();
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Total system power\" register" << 3059 << "size:" << 2 << values;
        processTotalCurrentPowerRegisterValues(values);
        verifyUpdateFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Total system power\" registers" << error << reply->errorString();
    });

    // Read Voltage phase L1
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Voltage phase L1\" register:" << 3027 << "size:" << 2;
    reply = readVoltagePhaseA();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Voltage phase L1\" registers";
        return false;
    }

    if (reply->isFinished()) {
        return false; // Broadcast reply returns immediatly
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        m_pendingUpdateReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            verifyUpdateFinished();
            return;
        }

        QVector<quint16> values = reply->result();
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Voltage phase L1\" register" << 3027 << "size:" << 2 << values;
        processVoltagePhaseARegisterValues(values);
        verifyUpdateFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Voltage phase L1\" registers" << error << reply->errorString();
    });

    // Read Voltage phase L2
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Voltage phase L2\" register:" << 3029 << "size:" << 2;
    reply = readVoltagePhaseB();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Voltage phase L2\" registers";
        return false;
    }

    if (reply->isFinished()) {
        return false; // Broadcast reply returns immediatly
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        m_pendingUpdateReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            verifyUpdateFinished();
            return;
        }

        QVector<quint16> values = reply->result();
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Voltage phase L2\" register" << 3029 << "size:" << 2 << values;
        processVoltagePhaseBRegisterValues(values);
        verifyUpdateFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Voltage phase L2\" registers" << error << reply->errorString();
    });

    // Read Voltage phase L3
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Voltage phase L3\" register:" << 3031 << "size:" << 2;
    reply = readVoltagePhaseC();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Voltage phase L3\" registers";
        return false;
    }

    if (reply->isFinished()) {
        return false; // Broadcast reply returns immediatly
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        m_pendingUpdateReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            verifyUpdateFinished();
            return;
        }

        QVector<quint16> values = reply->result();
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Voltage phase L3\" register" << 3031 << "size:" << 2 << values;
        processVoltagePhaseCRegisterValues(values);
        verifyUpdateFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Voltage phase L3\" registers" << error << reply->errorString();
    });

    // Read Current phase L1
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Current phase L1\" register:" << 2999 << "size:" << 2;
    reply = readCurrentPhaseA();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Current phase L1\" registers";
        return false;
    }

    if (reply->isFinished()) {
        return false; // Broadcast reply returns immediatly
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        m_pendingUpdateReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            verifyUpdateFinished();
            return;
        }

        QVector<quint16> values = reply->result();
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Current phase L1\" register" << 2999 << "size:" << 2 << values;
        processCurrentPhaseARegisterValues(values);
        verifyUpdateFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Current phase L1\" registers" << error << reply->errorString();
    });

    // Read Current phase L2
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Current phase L2\" register:" << 3001 << "size:" << 2;
    reply = readCurrentPhaseB();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Current phase L2\" registers";
        return false;
    }

    if (reply->isFinished()) {
        return false; // Broadcast reply returns immediatly
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        m_pendingUpdateReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            verifyUpdateFinished();
            return;
        }

        QVector<quint16> values = reply->result();
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Current phase L2\" register" << 3001 << "size:" << 2 << values;
        processCurrentPhaseBRegisterValues(values);
        verifyUpdateFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Current phase L2\" registers" << error << reply->errorString();
    });

    // Read Current phase L3
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Current phase L3\" register:" << 3003 << "size:" << 2;
    reply = readCurrentPhaseC();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Current phase L3\" registers";
        return false;
    }

    if (reply->isFinished()) {
        return false; // Broadcast reply returns immediatly
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        m_pendingUpdateReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            verifyUpdateFinished();
            return;
        }

        QVector<quint16> values = reply->result();
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Current phase L3\" register" << 3003 << "size:" << 2 << values;
        processCurrentPhaseCRegisterValues(values);
        verifyUpdateFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Current phase L3\" registers" << error << reply->errorString();
    });

    // Read Power phase L1
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Power phase L1\" register:" << 3053 << "size:" << 2;
    reply = readPowerPhaseA();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Power phase L1\" registers";
        return false;
    }

    if (reply->isFinished()) {
        return false; // Broadcast reply returns immediatly
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        m_pendingUpdateReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            verifyUpdateFinished();
            return;
        }

        QVector<quint16> values = reply->result();
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Power phase L1\" register" << 3053 << "size:" << 2 << values;
        processPowerPhaseARegisterValues(values);
        verifyUpdateFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Power phase L1\" registers" << error << reply->errorString();
    });

    // Read Power phase L2
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Power phase L2\" register:" << 3055 << "size:" << 2;
    reply = readPowerPhaseB();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Power phase L2\" registers";
        return false;
    }

    if (reply->isFinished()) {
        return false; // Broadcast reply returns immediatly
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        m_pendingUpdateReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            verifyUpdateFinished();
            return;
        }

        QVector<quint16> values = reply->result();
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Power phase L2\" register" << 3055 << "size:" << 2 << values;
        processPowerPhaseBRegisterValues(values);
        verifyUpdateFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Power phase L2\" registers" << error << reply->errorString();
    });

    // Read Power phase L3
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Power phase L3\" register:" << 3057 << "size:" << 2;
    reply = readPowerPhaseC();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Power phase L3\" registers";
        return false;
    }

    if (reply->isFinished()) {
        return false; // Broadcast reply returns immediatly
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        m_pendingUpdateReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            verifyUpdateFinished();
            return;
        }

        QVector<quint16> values = reply->result();
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Power phase L3\" register" << 3057 << "size:" << 2 << values;
        processPowerPhaseCRegisterValues(values);
        verifyUpdateFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Power phase L3\" registers" << error << reply->errorString();
    });

    // Read Frequency
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Frequency\" register:" << 3109 << "size:" << 2;
    reply = readFrequency();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Frequency\" registers";
        return false;
    }

    if (reply->isFinished()) {
        return false; // Broadcast reply returns immediatly
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        m_pendingUpdateReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            verifyUpdateFinished();
            return;
        }

        QVector<quint16> values = reply->result();
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Frequency\" register" << 3109 << "size:" << 2 << values;
        processFrequencyRegisterValues(values);
        verifyUpdateFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Frequency\" registers" << error << reply->errorString();
    });

    // Read Total energy consumed
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Total energy consumed\" register:" << 3203 << "size:" << 4;
    reply = readTotalEnergyConsumed();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Total energy consumed\" registers";
        return false;
    }

    if (reply->isFinished()) {
        return false; // Broadcast reply returns immediatly
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        m_pendingUpdateReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            verifyUpdateFinished();
            return;
        }

        QVector<quint16> values = reply->result();
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Total energy consumed\" register" << 3203 << "size:" << 4 << values;
        processTotalEnergyConsumedRegisterValues(values);
        verifyUpdateFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Total energy consumed\" registers" << error << reply->errorString();
    });

    // Read Total energy produced
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Total energy produced\" register:" << 3207 << "size:" << 4;
    reply = readTotalEnergyProduced();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Total energy produced\" registers";
        return false;
    }

    if (reply->isFinished()) {
        return false; // Broadcast reply returns immediatly
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        m_pendingUpdateReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            verifyUpdateFinished();
            return;
        }

        QVector<quint16> values = reply->result();
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Total energy produced\" register" << 3207 << "size:" << 4 << values;
        processTotalEnergyProducedRegisterValues(values);
        verifyUpdateFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Total energy produced\" registers" << error << reply->errorString();
    });

    // Read Energy consumed phase A
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Energy consumed phase A\" register:" << 3517 << "size:" << 4;
    reply = readEnergyConsumedPhaseA();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Energy consumed phase A\" registers";
        return false;
    }

    if (reply->isFinished()) {
        return false; // Broadcast reply returns immediatly
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        m_pendingUpdateReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            verifyUpdateFinished();
            return;
        }

        QVector<quint16> values = reply->result();
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Energy consumed phase A\" register" << 3517 << "size:" << 4 << values;
        processEnergyConsumedPhaseARegisterValues(values);
        verifyUpdateFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Energy consumed phase A\" registers" << error << reply->errorString();
    });

    // Read Energy consumed phase B
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Energy consumed phase B\" register:" << 3521 << "size:" << 4;
    reply = readEnergyConsumedPhaseB();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Energy consumed phase B\" registers";
        return false;
    }

    if (reply->isFinished()) {
        return false; // Broadcast reply returns immediatly
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        m_pendingUpdateReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            verifyUpdateFinished();
            return;
        }

        QVector<quint16> values = reply->result();
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Energy consumed phase B\" register" << 3521 << "size:" << 4 << values;
        processEnergyConsumedPhaseBRegisterValues(values);
        verifyUpdateFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Energy consumed phase B\" registers" << error << reply->errorString();
    });

    // Read Energy consumed phase C
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Energy consumed phase C\" register:" << 3525 << "size:" << 4;
    reply = readEnergyConsumedPhaseC();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Energy consumed phase C\" registers";
        return false;
    }

    if (reply->isFinished()) {
        return false; // Broadcast reply returns immediatly
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        m_pendingUpdateReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            verifyUpdateFinished();
            return;
        }

        QVector<quint16> values = reply->result();
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Energy consumed phase C\" register" << 3525 << "size:" << 4 << values;
        processEnergyConsumedPhaseCRegisterValues(values);
        verifyUpdateFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Energy consumed phase C\" registers" << error << reply->errorString();
    });
    return true;
}

void SchneiderIEMModbusRtuConnection::updateTotalCurrentPower()
{
    // Update registers from Total system power
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Total system power\" register:" << 3059 << "size:" << 2;
    ModbusRtuReply *reply = readTotalCurrentPower();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Total system power\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Total system power\" register" << 3059 << "size:" << 2 << values;
                processTotalCurrentPowerRegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Total system power\" registers" << error << reply->errorString();
        });
    }
}

void SchneiderIEMModbusRtuConnection::updateVoltagePhaseA()
{
    // Update registers from Voltage phase L1
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Voltage phase L1\" register:" << 3027 << "size:" << 2;
    ModbusRtuReply *reply = readVoltagePhaseA();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Voltage phase L1\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Voltage phase L1\" register" << 3027 << "size:" << 2 << values;
                processVoltagePhaseARegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Voltage phase L1\" registers" << error << reply->errorString();
        });
    }
}

void SchneiderIEMModbusRtuConnection::updateVoltagePhaseB()
{
    // Update registers from Voltage phase L2
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Voltage phase L2\" register:" << 3029 << "size:" << 2;
    ModbusRtuReply *reply = readVoltagePhaseB();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Voltage phase L2\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Voltage phase L2\" register" << 3029 << "size:" << 2 << values;
                processVoltagePhaseBRegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Voltage phase L2\" registers" << error << reply->errorString();
        });
    }
}

void SchneiderIEMModbusRtuConnection::updateVoltagePhaseC()
{
    // Update registers from Voltage phase L3
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Voltage phase L3\" register:" << 3031 << "size:" << 2;
    ModbusRtuReply *reply = readVoltagePhaseC();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Voltage phase L3\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Voltage phase L3\" register" << 3031 << "size:" << 2 << values;
                processVoltagePhaseCRegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Voltage phase L3\" registers" << error << reply->errorString();
        });
    }
}

void SchneiderIEMModbusRtuConnection::updateCurrentPhaseA()
{
    // Update registers from Current phase L1
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Current phase L1\" register:" << 2999 << "size:" << 2;
    ModbusRtuReply *reply = readCurrentPhaseA();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Current phase L1\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Current phase L1\" register" << 2999 << "size:" << 2 << values;
                processCurrentPhaseARegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Current phase L1\" registers" << error << reply->errorString();
        });
    }
}

void SchneiderIEMModbusRtuConnection::updateCurrentPhaseB()
{
    // Update registers from Current phase L2
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Current phase L2\" register:" << 3001 << "size:" << 2;
    ModbusRtuReply *reply = readCurrentPhaseB();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Current phase L2\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Current phase L2\" register" << 3001 << "size:" << 2 << values;
                processCurrentPhaseBRegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Current phase L2\" registers" << error << reply->errorString();
        });
    }
}

void SchneiderIEMModbusRtuConnection::updateCurrentPhaseC()
{
    // Update registers from Current phase L3
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Current phase L3\" register:" << 3003 << "size:" << 2;
    ModbusRtuReply *reply = readCurrentPhaseC();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Current phase L3\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Current phase L3\" register" << 3003 << "size:" << 2 << values;
                processCurrentPhaseCRegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Current phase L3\" registers" << error << reply->errorString();
        });
    }
}

void SchneiderIEMModbusRtuConnection::updatePowerPhaseA()
{
    // Update registers from Power phase L1
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Power phase L1\" register:" << 3053 << "size:" << 2;
    ModbusRtuReply *reply = readPowerPhaseA();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Power phase L1\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Power phase L1\" register" << 3053 << "size:" << 2 << values;
                processPowerPhaseARegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Power phase L1\" registers" << error << reply->errorString();
        });
    }
}

void SchneiderIEMModbusRtuConnection::updatePowerPhaseB()
{
    // Update registers from Power phase L2
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Power phase L2\" register:" << 3055 << "size:" << 2;
    ModbusRtuReply *reply = readPowerPhaseB();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Power phase L2\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Power phase L2\" register" << 3055 << "size:" << 2 << values;
                processPowerPhaseBRegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Power phase L2\" registers" << error << reply->errorString();
        });
    }
}

void SchneiderIEMModbusRtuConnection::updatePowerPhaseC()
{
    // Update registers from Power phase L3
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Power phase L3\" register:" << 3057 << "size:" << 2;
    ModbusRtuReply *reply = readPowerPhaseC();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Power phase L3\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Power phase L3\" register" << 3057 << "size:" << 2 << values;
                processPowerPhaseCRegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Power phase L3\" registers" << error << reply->errorString();
        });
    }
}

void SchneiderIEMModbusRtuConnection::updateFrequency()
{
    // Update registers from Frequency
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Frequency\" register:" << 3109 << "size:" << 2;
    ModbusRtuReply *reply = readFrequency();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Frequency\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Frequency\" register" << 3109 << "size:" << 2 << values;
                processFrequencyRegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Frequency\" registers" << error << reply->errorString();
        });
    }
}

void SchneiderIEMModbusRtuConnection::updateTotalEnergyConsumed()
{
    // Update registers from Total energy consumed
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Total energy consumed\" register:" << 3203 << "size:" << 4;
    ModbusRtuReply *reply = readTotalEnergyConsumed();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Total energy consumed\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Total energy consumed\" register" << 3203 << "size:" << 4 << values;
                processTotalEnergyConsumedRegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Total energy consumed\" registers" << error << reply->errorString();
        });
    }
}

void SchneiderIEMModbusRtuConnection::updateTotalEnergyProduced()
{
    // Update registers from Total energy produced
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Total energy produced\" register:" << 3207 << "size:" << 4;
    ModbusRtuReply *reply = readTotalEnergyProduced();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Total energy produced\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Total energy produced\" register" << 3207 << "size:" << 4 << values;
                processTotalEnergyProducedRegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Total energy produced\" registers" << error << reply->errorString();
        });
    }
}

void SchneiderIEMModbusRtuConnection::updateEnergyConsumedPhaseA()
{
    // Update registers from Energy consumed phase A
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Energy consumed phase A\" register:" << 3517 << "size:" << 4;
    ModbusRtuReply *reply = readEnergyConsumedPhaseA();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Energy consumed phase A\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Energy consumed phase A\" register" << 3517 << "size:" << 4 << values;
                processEnergyConsumedPhaseARegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Energy consumed phase A\" registers" << error << reply->errorString();
        });
    }
}

void SchneiderIEMModbusRtuConnection::updateEnergyConsumedPhaseB()
{
    // Update registers from Energy consumed phase B
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Energy consumed phase B\" register:" << 3521 << "size:" << 4;
    ModbusRtuReply *reply = readEnergyConsumedPhaseB();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Energy consumed phase B\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Energy consumed phase B\" register" << 3521 << "size:" << 4 << values;
                processEnergyConsumedPhaseBRegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Energy consumed phase B\" registers" << error << reply->errorString();
        });
    }
}

void SchneiderIEMModbusRtuConnection::updateEnergyConsumedPhaseC()
{
    // Update registers from Energy consumed phase C
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Read \"Energy consumed phase C\" register:" << 3525 << "size:" << 4;
    ModbusRtuReply *reply = readEnergyConsumedPhaseC();
    if (!reply) {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Error occurred while reading \"Energy consumed phase C\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcSchneiderIEMModbusRtuConnection()) << "<-- Response from \"Energy consumed phase C\" register" << 3525 << "size:" << 4 << values;
                processEnergyConsumedPhaseCRegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Energy consumed phase C\" registers" << error << reply->errorString();
        });
    }
}

ModbusRtuReply *SchneiderIEMModbusRtuConnection::readTotalCurrentPower()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 3059, 2);
}

ModbusRtuReply *SchneiderIEMModbusRtuConnection::readVoltagePhaseA()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 3027, 2);
}

ModbusRtuReply *SchneiderIEMModbusRtuConnection::readVoltagePhaseB()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 3029, 2);
}

ModbusRtuReply *SchneiderIEMModbusRtuConnection::readVoltagePhaseC()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 3031, 2);
}

ModbusRtuReply *SchneiderIEMModbusRtuConnection::readCurrentPhaseA()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 2999, 2);
}

ModbusRtuReply *SchneiderIEMModbusRtuConnection::readCurrentPhaseB()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 3001, 2);
}

ModbusRtuReply *SchneiderIEMModbusRtuConnection::readCurrentPhaseC()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 3003, 2);
}

ModbusRtuReply *SchneiderIEMModbusRtuConnection::readPowerPhaseA()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 3053, 2);
}

ModbusRtuReply *SchneiderIEMModbusRtuConnection::readPowerPhaseB()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 3055, 2);
}

ModbusRtuReply *SchneiderIEMModbusRtuConnection::readPowerPhaseC()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 3057, 2);
}

ModbusRtuReply *SchneiderIEMModbusRtuConnection::readFrequency()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 3109, 2);
}

ModbusRtuReply *SchneiderIEMModbusRtuConnection::readTotalEnergyConsumed()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 3203, 4);
}

ModbusRtuReply *SchneiderIEMModbusRtuConnection::readTotalEnergyProduced()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 3207, 4);
}

ModbusRtuReply *SchneiderIEMModbusRtuConnection::readEnergyConsumedPhaseA()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 3517, 4);
}

ModbusRtuReply *SchneiderIEMModbusRtuConnection::readEnergyConsumedPhaseB()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 3521, 4);
}

ModbusRtuReply *SchneiderIEMModbusRtuConnection::readEnergyConsumedPhaseC()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 3525, 4);
}

void SchneiderIEMModbusRtuConnection::processTotalCurrentPowerRegisterValues(const QVector<quint16> values)
{
    float receivedTotalCurrentPower = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit totalCurrentPowerReadFinished(receivedTotalCurrentPower);

    if (m_totalCurrentPower != receivedTotalCurrentPower) {
        m_totalCurrentPower = receivedTotalCurrentPower;
        emit totalCurrentPowerChanged(m_totalCurrentPower);
    }
}

void SchneiderIEMModbusRtuConnection::processVoltagePhaseARegisterValues(const QVector<quint16> values)
{
    float receivedVoltagePhaseA = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit voltagePhaseAReadFinished(receivedVoltagePhaseA);

    if (m_voltagePhaseA != receivedVoltagePhaseA) {
        m_voltagePhaseA = receivedVoltagePhaseA;
        emit voltagePhaseAChanged(m_voltagePhaseA);
    }
}

void SchneiderIEMModbusRtuConnection::processVoltagePhaseBRegisterValues(const QVector<quint16> values)
{
    float receivedVoltagePhaseB = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit voltagePhaseBReadFinished(receivedVoltagePhaseB);

    if (m_voltagePhaseB != receivedVoltagePhaseB) {
        m_voltagePhaseB = receivedVoltagePhaseB;
        emit voltagePhaseBChanged(m_voltagePhaseB);
    }
}

void SchneiderIEMModbusRtuConnection::processVoltagePhaseCRegisterValues(const QVector<quint16> values)
{
    float receivedVoltagePhaseC = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit voltagePhaseCReadFinished(receivedVoltagePhaseC);

    if (m_voltagePhaseC != receivedVoltagePhaseC) {
        m_voltagePhaseC = receivedVoltagePhaseC;
        emit voltagePhaseCChanged(m_voltagePhaseC);
    }
}

void SchneiderIEMModbusRtuConnection::processCurrentPhaseARegisterValues(const QVector<quint16> values)
{
    float receivedCurrentPhaseA = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit currentPhaseAReadFinished(receivedCurrentPhaseA);

    if (m_currentPhaseA != receivedCurrentPhaseA) {
        m_currentPhaseA = receivedCurrentPhaseA;
        emit currentPhaseAChanged(m_currentPhaseA);
    }
}

void SchneiderIEMModbusRtuConnection::processCurrentPhaseBRegisterValues(const QVector<quint16> values)
{
    float receivedCurrentPhaseB = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit currentPhaseBReadFinished(receivedCurrentPhaseB);

    if (m_currentPhaseB != receivedCurrentPhaseB) {
        m_currentPhaseB = receivedCurrentPhaseB;
        emit currentPhaseBChanged(m_currentPhaseB);
    }
}

void SchneiderIEMModbusRtuConnection::processCurrentPhaseCRegisterValues(const QVector<quint16> values)
{
    float receivedCurrentPhaseC = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit currentPhaseCReadFinished(receivedCurrentPhaseC);

    if (m_currentPhaseC != receivedCurrentPhaseC) {
        m_currentPhaseC = receivedCurrentPhaseC;
        emit currentPhaseCChanged(m_currentPhaseC);
    }
}

void SchneiderIEMModbusRtuConnection::processPowerPhaseARegisterValues(const QVector<quint16> values)
{
    float receivedPowerPhaseA = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit powerPhaseAReadFinished(receivedPowerPhaseA);

    if (m_powerPhaseA != receivedPowerPhaseA) {
        m_powerPhaseA = receivedPowerPhaseA;
        emit powerPhaseAChanged(m_powerPhaseA);
    }
}

void SchneiderIEMModbusRtuConnection::processPowerPhaseBRegisterValues(const QVector<quint16> values)
{
    float receivedPowerPhaseB = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit powerPhaseBReadFinished(receivedPowerPhaseB);

    if (m_powerPhaseB != receivedPowerPhaseB) {
        m_powerPhaseB = receivedPowerPhaseB;
        emit powerPhaseBChanged(m_powerPhaseB);
    }
}

void SchneiderIEMModbusRtuConnection::processPowerPhaseCRegisterValues(const QVector<quint16> values)
{
    float receivedPowerPhaseC = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit powerPhaseCReadFinished(receivedPowerPhaseC);

    if (m_powerPhaseC != receivedPowerPhaseC) {
        m_powerPhaseC = receivedPowerPhaseC;
        emit powerPhaseCChanged(m_powerPhaseC);
    }
}

void SchneiderIEMModbusRtuConnection::processFrequencyRegisterValues(const QVector<quint16> values)
{
    float receivedFrequency = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit frequencyReadFinished(receivedFrequency);

    if (m_frequency != receivedFrequency) {
        m_frequency = receivedFrequency;
        emit frequencyChanged(m_frequency);
    }
}

void SchneiderIEMModbusRtuConnection::processTotalEnergyConsumedRegisterValues(const QVector<quint16> values)
{
    qint64 receivedTotalEnergyConsumed = ModbusDataUtils::convertToInt64(values, m_endianness);
    emit totalEnergyConsumedReadFinished(receivedTotalEnergyConsumed);

    if (m_totalEnergyConsumed != receivedTotalEnergyConsumed) {
        m_totalEnergyConsumed = receivedTotalEnergyConsumed;
        emit totalEnergyConsumedChanged(m_totalEnergyConsumed);
    }
}

void SchneiderIEMModbusRtuConnection::processTotalEnergyProducedRegisterValues(const QVector<quint16> values)
{
    qint64 receivedTotalEnergyProduced = ModbusDataUtils::convertToInt64(values, m_endianness);
    emit totalEnergyProducedReadFinished(receivedTotalEnergyProduced);

    if (m_totalEnergyProduced != receivedTotalEnergyProduced) {
        m_totalEnergyProduced = receivedTotalEnergyProduced;
        emit totalEnergyProducedChanged(m_totalEnergyProduced);
    }
}

void SchneiderIEMModbusRtuConnection::processEnergyConsumedPhaseARegisterValues(const QVector<quint16> values)
{
    qint64 receivedEnergyConsumedPhaseA = ModbusDataUtils::convertToInt64(values, m_endianness);
    emit energyConsumedPhaseAReadFinished(receivedEnergyConsumedPhaseA);

    if (m_energyConsumedPhaseA != receivedEnergyConsumedPhaseA) {
        m_energyConsumedPhaseA = receivedEnergyConsumedPhaseA;
        emit energyConsumedPhaseAChanged(m_energyConsumedPhaseA);
    }
}

void SchneiderIEMModbusRtuConnection::processEnergyConsumedPhaseBRegisterValues(const QVector<quint16> values)
{
    qint64 receivedEnergyConsumedPhaseB = ModbusDataUtils::convertToInt64(values, m_endianness);
    emit energyConsumedPhaseBReadFinished(receivedEnergyConsumedPhaseB);

    if (m_energyConsumedPhaseB != receivedEnergyConsumedPhaseB) {
        m_energyConsumedPhaseB = receivedEnergyConsumedPhaseB;
        emit energyConsumedPhaseBChanged(m_energyConsumedPhaseB);
    }
}

void SchneiderIEMModbusRtuConnection::processEnergyConsumedPhaseCRegisterValues(const QVector<quint16> values)
{
    qint64 receivedEnergyConsumedPhaseC = ModbusDataUtils::convertToInt64(values, m_endianness);
    emit energyConsumedPhaseCReadFinished(receivedEnergyConsumedPhaseC);

    if (m_energyConsumedPhaseC != receivedEnergyConsumedPhaseC) {
        m_energyConsumedPhaseC = receivedEnergyConsumedPhaseC;
        emit energyConsumedPhaseCChanged(m_energyConsumedPhaseC);
    }
}

void SchneiderIEMModbusRtuConnection::handleModbusError(ModbusRtuReply::Error error)
{
    if (error == ModbusRtuReply::NoError) {
        // Reset the communication counter and we know we can reach the device
        m_communicationFailedCounter = 0;
        if (!m_communicationWorking)
            qCDebug(dcSchneiderIEMModbusRtuConnection()) << "Received a reply without any errors. The communication with the device seems to work now.";

        m_communicationWorking = true;
        evaluateReachableState();
    } else {
        m_communicationFailedCounter++;
        if (m_communicationWorking && m_communicationFailedCounter >= m_communicationFailedMax) {
            m_communicationWorking = false;
            qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Received" << m_communicationFailedCounter << "errors while communicating with the RTU master. Mark as not reachable until the communication works again.";
            evaluateReachableState();
        }
    }
}

void SchneiderIEMModbusRtuConnection::testReachability()
{
    if (m_checkRechableReply)
        return;

    // Try to read the check reachability register totalCurrentPower in order to verify if the communication is working or not.
    qCDebug(dcSchneiderIEMModbusRtuConnection()) << "--> Test reachability by reading \"Total system power\" register:" << 3059 << "size:" << 2;
    m_checkRechableReply = readTotalCurrentPower();
    if (!m_checkRechableReply) {
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "Error occurred verifying reachability by reading \"Total system power\" register";
        onReachabilityCheckFailed();
        return;
    }

    if (m_checkRechableReply->isFinished()) {
        m_checkRechableReply = nullptr;
        onReachabilityCheckFailed();
        return;
    }

    connect(m_checkRechableReply, &ModbusRtuReply::finished, this, [this](){
        // Note: we don't care about the result here, only the error
        handleModbusError(m_checkRechableReply->error());
        if (m_checkRechableReply->error() != ModbusRtuReply::NoError)
            onReachabilityCheckFailed();

        m_checkRechableReply = nullptr;
    });

    connect(m_checkRechableReply, &ModbusRtuReply::errorOccurred, this, [this] (ModbusRtuReply::Error error){
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "ModbusRtu reply error occurred while verifying reachability by reading \"Total system power\" register" << error << m_checkRechableReply->errorString();
    });
}

void SchneiderIEMModbusRtuConnection::verifyInitFinished()
{
    if (m_pendingInitReplies.isEmpty()) {
        finishInitialization(true);
    }
}

void SchneiderIEMModbusRtuConnection::finishInitialization(bool success)
{
    if (success) {
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "Initialization finished of SchneiderIEMModbusRtuConnection finished successfully";
    } else {
        qCWarning(dcSchneiderIEMModbusRtuConnection()) << "Initialization finished of SchneiderIEMModbusRtuConnection failed.";
    }

    // Cleanup init
    delete m_initObject;
    m_initObject = nullptr;
    m_pendingInitReplies.clear();

    emit initializationFinished(success);
}

void SchneiderIEMModbusRtuConnection::verifyUpdateFinished()
{
    if (m_pendingUpdateReplies.isEmpty()) {
        emit updateFinished();
    }
}

void SchneiderIEMModbusRtuConnection::onReachabilityCheckFailed()
{
    m_checkReachableRetriesCount++;

    if (m_checkReachableRetriesCount <= m_checkReachableRetries) {
        qCDebug(dcSchneiderIEMModbusRtuConnection()) << "Reachability test failed. Retry in on second" << m_checkReachableRetriesCount << "/" << m_checkReachableRetries;
        QTimer::singleShot(1000, this, &SchneiderIEMModbusRtuConnection::testReachability);
        return;
    }

    // The test reachability method failed, not retrying any more
    emit checkReachabilityFailed();
}

void SchneiderIEMModbusRtuConnection::evaluateReachableState()
{
    bool reachable = m_communicationWorking && m_modbusRtuMaster->connected();
    if (m_reachable == reachable)
        return;

    m_reachable = reachable;
    emit reachableChanged(m_reachable);
    m_checkReachableRetriesCount = 0;
}

QDebug operator<<(QDebug debug, SchneiderIEMModbusRtuConnection *schneiderIEMModbusRtuConnection)
{
    debug.nospace().noquote() << "SchneiderIEMModbusRtuConnection(" << schneiderIEMModbusRtuConnection->modbusRtuMaster()->modbusUuid().toString() << ", " << schneiderIEMModbusRtuConnection->modbusRtuMaster()->serialPort() << ", slave ID:" << schneiderIEMModbusRtuConnection->slaveId() << ")" << "\n";
    debug.nospace().noquote() << "    - Total system power: " << schneiderIEMModbusRtuConnection->totalCurrentPower() << " [kW]" << "\n";
    debug.nospace().noquote() << "    - Voltage phase L1: " << schneiderIEMModbusRtuConnection->voltagePhaseA() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Voltage phase L2: " << schneiderIEMModbusRtuConnection->voltagePhaseB() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Voltage phase L3: " << schneiderIEMModbusRtuConnection->voltagePhaseC() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Current phase L1: " << schneiderIEMModbusRtuConnection->currentPhaseA() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Current phase L2: " << schneiderIEMModbusRtuConnection->currentPhaseB() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Current phase L3: " << schneiderIEMModbusRtuConnection->currentPhaseC() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Power phase L1: " << schneiderIEMModbusRtuConnection->powerPhaseA() << " [kW]" << "\n";
    debug.nospace().noquote() << "    - Power phase L2: " << schneiderIEMModbusRtuConnection->powerPhaseB() << " [kW]" << "\n";
    debug.nospace().noquote() << "    - Power phase L3: " << schneiderIEMModbusRtuConnection->powerPhaseC() << " [kW]" << "\n";
    debug.nospace().noquote() << "    - Frequency: " << schneiderIEMModbusRtuConnection->frequency() << " [Hz]" << "\n";
    debug.nospace().noquote() << "    - Total energy consumed: " << schneiderIEMModbusRtuConnection->totalEnergyConsumed() << " [Wh]" << "\n";
    debug.nospace().noquote() << "    - Total energy produced: " << schneiderIEMModbusRtuConnection->totalEnergyProduced() << " [Wh]" << "\n";
    debug.nospace().noquote() << "    - Energy consumed phase A: " << schneiderIEMModbusRtuConnection->energyConsumedPhaseA() << " [Wh]" << "\n";
    debug.nospace().noquote() << "    - Energy consumed phase B: " << schneiderIEMModbusRtuConnection->energyConsumedPhaseB() << " [Wh]" << "\n";
    debug.nospace().noquote() << "    - Energy consumed phase C: " << schneiderIEMModbusRtuConnection->energyConsumedPhaseC() << " [Wh]" << "\n";
    return debug.quote().space();
}

