/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Copyright 2013 - 2024, nymea GmbH
* Contact: contact@nymea.io
*
* This fileDescriptor is part of nymea.
* This project including source code and documentation is protected by
* copyright law, and remains the property of nymea GmbH. All rights, including
* reproduction, publication, editing and translation, are reserved. The use of
* this project is subject to the terms of a license agreement to be concluded
* with nymea GmbH in accordance with the terms of use of nymea GmbH, available
* under https://nymea.io/license
*
* GNU Lesser General Public License Usage
* Alternatively, this project may be redistributed and/or modified under the
* terms of the GNU Lesser General Public License as published by the Free
* Software Foundation; version 3. This project is distributed in the hope that
* it will be useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this project. If not, see <https://www.gnu.org/licenses/>.
*
* For any further details and any questions please contact us under
* contact@nymea.io or see our FAQ/Licensing Information on
* https://nymea.io/license/faq
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WARNING
*
* This file has been autogenerated. Any changes in this file may be overwritten.
* If you want to change something, update the register json or the tool.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


#include "sungrowmodbustcpconnection.h"
#include <loggingcategories.h>
#include <math.h>
#include <QTimer>

NYMEA_LOGGING_CATEGORY(dcSungrowModbusTcpConnection, "SungrowModbusTcpConnection")

SungrowModbusTcpConnection::SungrowModbusTcpConnection(const QHostAddress &hostAddress, uint port, quint16 slaveId, QObject *parent) :
    ModbusTCPMaster(hostAddress, port, parent),
    m_slaveId(slaveId)
{
    connect(this, &ModbusTCPMaster::connectionStateChanged, this, [this](bool status){
        if (status) {
           qCDebug(dcSungrowModbusTcpConnection()) << "Modbus TCP connection" << m_hostAddress.toString() << "connected. Start testing if the connection is reachable...";
            // Cleanup before starting to initialize
            m_pendingInitReplies.clear();
            m_pendingUpdateReplies.clear();
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
            testReachability();
        } else {
            qCWarning(dcSungrowModbusTcpConnection()) << "Modbus TCP connection diconnected from" << m_hostAddress.toString() << ". The connection is not reachable any more.";
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
        }

        evaluateReachableState();
    });
}

bool SungrowModbusTcpConnection::reachable() const
{
    return m_reachable;
}

uint SungrowModbusTcpConnection::checkReachableRetries() const
{
    return m_checkReachableRetries;
}

void SungrowModbusTcpConnection::setCheckReachableRetries(uint checkReachableRetries)
{
    if (m_checkReachableRetries == checkReachableRetries)
        return;

    m_checkReachableRetries = checkReachableRetries;
    emit checkReachableRetriesChanged(m_checkReachableRetries);
}

ModbusDataUtils::ByteOrder SungrowModbusTcpConnection::endianness() const
{
    return m_endianness;
}

void SungrowModbusTcpConnection::setEndianness(ModbusDataUtils::ByteOrder endianness)
{
    if (m_endianness == endianness)
        return;

    m_endianness = endianness;
    emit endiannessChanged(m_endianness);
}

float SungrowModbusTcpConnection::batteryNominalPower() const
{
    return m_batteryNominalPower;
}

quint16 SungrowModbusTcpConnection::exportLimit() const
{
    return m_exportLimit;
}

QModbusReply *SungrowModbusTcpConnection::setExportLimit(quint16 exportLimit)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(exportLimit);
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Write \"Inverter export limit\" register:" << 13073 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 13073, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 SungrowModbusTcpConnection::exportLimitMode() const
{
    return m_exportLimitMode;
}

QModbusReply *SungrowModbusTcpConnection::setExportLimitMode(quint16 exportLimitMode)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(exportLimitMode);
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Write \"Inverter export mode\" register:" << 13086 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 13086, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

float SungrowModbusTcpConnection::batteryMinLevel() const
{
    return m_batteryMinLevel;
}

QModbusReply *SungrowModbusTcpConnection::setBatteryMinLevel(float batteryMinLevel)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(static_cast<quint16>(batteryMinLevel  * 1.0 / pow(10, -1)));
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Write \"Battery min SOC\" register:" << 13058 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 13058, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint32 SungrowModbusTcpConnection::protocolNumber() const
{
    return m_protocolNumber;
}

quint32 SungrowModbusTcpConnection::protocolVersion() const
{
    return m_protocolVersion;
}

QString SungrowModbusTcpConnection::armSoftwareVersion() const
{
    return m_armSoftwareVersion;
}

QString SungrowModbusTcpConnection::dspSoftwareVersion() const
{
    return m_dspSoftwareVersion;
}

QString SungrowModbusTcpConnection::serialNumber() const
{
    return m_serialNumber;
}

quint16 SungrowModbusTcpConnection::deviceTypeCode() const
{
    return m_deviceTypeCode;
}

float SungrowModbusTcpConnection::nominalOutputPower() const
{
    return m_nominalOutputPower;
}

float SungrowModbusTcpConnection::inverterTemperature() const
{
    return m_inverterTemperature;
}

QVector<quint16> SungrowModbusTcpConnection::dummy0() const
{
    return m_dummy0;
}

quint32 SungrowModbusTcpConnection::totalPVPower() const
{
    return m_totalPVPower;
}

float SungrowModbusTcpConnection::phaseAVoltage() const
{
    return m_phaseAVoltage;
}

float SungrowModbusTcpConnection::phaseBVoltage() const
{
    return m_phaseBVoltage;
}

float SungrowModbusTcpConnection::phaseCVoltage() const
{
    return m_phaseCVoltage;
}

QVector<quint16> SungrowModbusTcpConnection::dummy1() const
{
    return m_dummy1;
}

qint32 SungrowModbusTcpConnection::reactivePower() const
{
    return m_reactivePower;
}

float SungrowModbusTcpConnection::powerFactor() const
{
    return m_powerFactor;
}

float SungrowModbusTcpConnection::gridFrequency() const
{
    return m_gridFrequency;
}

SungrowModbusTcpConnection::SystemState SungrowModbusTcpConnection::systemState() const
{
    return m_systemState;
}

quint16 SungrowModbusTcpConnection::runningState() const
{
    return m_runningState;
}

float SungrowModbusTcpConnection::dailyPVGeneration() const
{
    return m_dailyPVGeneration;
}

float SungrowModbusTcpConnection::totalPVGeneration() const
{
    return m_totalPVGeneration;
}

float SungrowModbusTcpConnection::dailyPVExport() const
{
    return m_dailyPVExport;
}

float SungrowModbusTcpConnection::totalPVExport() const
{
    return m_totalPVExport;
}

qint32 SungrowModbusTcpConnection::loadPower() const
{
    return m_loadPower;
}

qint32 SungrowModbusTcpConnection::exportPower() const
{
    return m_exportPower;
}

float SungrowModbusTcpConnection::dailyBatteryChargePV() const
{
    return m_dailyBatteryChargePV;
}

float SungrowModbusTcpConnection::totalBatteryChargePV() const
{
    return m_totalBatteryChargePV;
}

QVector<quint16> SungrowModbusTcpConnection::dummy2() const
{
    return m_dummy2;
}

float SungrowModbusTcpConnection::batteryVoltage() const
{
    return m_batteryVoltage;
}

float SungrowModbusTcpConnection::batteryCurrent() const
{
    return m_batteryCurrent;
}

qint16 SungrowModbusTcpConnection::batteryPower() const
{
    return m_batteryPower;
}

float SungrowModbusTcpConnection::batteryLevel() const
{
    return m_batteryLevel;
}

float SungrowModbusTcpConnection::batteryHealthState() const
{
    return m_batteryHealthState;
}

float SungrowModbusTcpConnection::batteryTemperature() const
{
    return m_batteryTemperature;
}

QVector<quint16> SungrowModbusTcpConnection::dummy3() const
{
    return m_dummy3;
}

quint16 SungrowModbusTcpConnection::gridState() const
{
    return m_gridState;
}

float SungrowModbusTcpConnection::phaseACurrent() const
{
    return m_phaseACurrent;
}

float SungrowModbusTcpConnection::phaseBCurrent() const
{
    return m_phaseBCurrent;
}

float SungrowModbusTcpConnection::phaseCCurrent() const
{
    return m_phaseCCurrent;
}

qint32 SungrowModbusTcpConnection::totalActivePower() const
{
    return m_totalActivePower;
}

float SungrowModbusTcpConnection::dailyImportEnergy() const
{
    return m_dailyImportEnergy;
}

float SungrowModbusTcpConnection::totalImportEnergy() const
{
    return m_totalImportEnergy;
}

float SungrowModbusTcpConnection::totalBatteryCapacity() const
{
    return m_totalBatteryCapacity;
}

QVector<quint16> SungrowModbusTcpConnection::dummy4() const
{
    return m_dummy4;
}

float SungrowModbusTcpConnection::totalExportEnergy() const
{
    return m_totalExportEnergy;
}

SungrowModbusTcpConnection::BatteryType SungrowModbusTcpConnection::batteryType() const
{
    return m_batteryType;
}

float SungrowModbusTcpConnection::batteryNominalVoltage() const
{
    return m_batteryNominalVoltage;
}

quint16 SungrowModbusTcpConnection::batteryCapacity() const
{
    return m_batteryCapacity;
}

quint16 SungrowModbusTcpConnection::emsModeSelection() const
{
    return m_emsModeSelection;
}

QModbusReply *SungrowModbusTcpConnection::setEmsModeSelection(quint16 emsModeSelection)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(emsModeSelection);
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Write \"EMS mode (0/2/3/4)\" register:" << 13049 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 13049, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 SungrowModbusTcpConnection::chargeCommand() const
{
    return m_chargeCommand;
}

QModbusReply *SungrowModbusTcpConnection::setChargeCommand(quint16 chargeCommand)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(chargeCommand);
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Write \"Force charge or discharge\" register:" << 13050 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 13050, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 SungrowModbusTcpConnection::chargePower() const
{
    return m_chargePower;
}

QModbusReply *SungrowModbusTcpConnection::setChargePower(quint16 chargePower)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(chargePower);
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Write \"Set batter power\" register:" << 13051 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 13051, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

bool SungrowModbusTcpConnection::initialize()
{
    if (!m_reachable) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Tried to initialize but the device is not to be reachable.";
        return false;
    }
    if (m_initObject) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Tried to initialize but the init process is already running.";
        return false;
    }

    // Parent object for the init process
    m_initObject = new QObject(this);

    QModbusReply *reply = nullptr;

    // Read version
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Read init block \"version\" registers from:" << 4949 << "size:" << 34;
    reply = readBlockVersion();
    if (!reply) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Error occurred while reading block \"version\" registers";
        finishInitialization(false);
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, m_initObject, [this, reply](){
        m_pendingInitReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            finishInitialization(false);
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSungrowModbusTcpConnection()) << "<-- Response from reading init block \"version\" register" << 4949 << "size:" << 34 << blockValues;
        processProtocolNumberRegisterValues(blockValues.mid(0, 2));
        processProtocolVersionRegisterValues(blockValues.mid(2, 2));
        processArmSoftwareVersionRegisterValues(blockValues.mid(4, 15));
        processDspSoftwareVersionRegisterValues(blockValues.mid(19, 15));
        initialize2();
    });

    connect(reply, &QModbusReply::errorOccurred, m_initObject, [reply] (QModbusDevice::Error error){
        qCWarning(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while updating block \"version\" registers" << error << reply->errorString();
    });

    return true;
}

void SungrowModbusTcpConnection::initialize2()
{
    QModbusReply *reply = nullptr;

    // Read identification
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Read init block \"identification\" registers from:" << 4989 << "size:" << 12;
    reply = readBlockIdentification();
    if (!reply) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Error occurred while reading block \"identification\" registers";
        finishInitialization(false);
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, m_initObject, [this, reply](){
        m_pendingInitReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            finishInitialization(false);
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSungrowModbusTcpConnection()) << "<-- Response from reading init block \"identification\" register" << 4989 << "size:" << 12 << blockValues;
        processSerialNumberRegisterValues(blockValues.mid(0, 10));
        processDeviceTypeCodeRegisterValues(blockValues.mid(10, 1));
        processNominalOutputPowerRegisterValues(blockValues.mid(11, 1));
        initialize3();
    });

    connect(reply, &QModbusReply::errorOccurred, m_initObject, [reply] (QModbusDevice::Error error){
        qCWarning(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while updating block \"identification\" registers" << error << reply->errorString();
    });
}

void SungrowModbusTcpConnection::initialize3()
{
    QModbusReply *reply = nullptr;

    // Read batteryInformation
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Read init block \"batteryInformation\" registers from:" << 13054 << "size:" << 3;
    reply = readBlockBatteryInformation();
    if (!reply) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Error occurred while reading block \"batteryInformation\" registers";
        finishInitialization(false);
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, m_initObject, [this, reply](){
        m_pendingInitReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            finishInitialization(false);
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSungrowModbusTcpConnection()) << "<-- Response from reading init block \"batteryInformation\" register" << 13054 << "size:" << 3 << blockValues;
        processBatteryTypeRegisterValues(blockValues.mid(0, 1));
        processBatteryNominalVoltageRegisterValues(blockValues.mid(1, 1));
        processBatteryCapacityRegisterValues(blockValues.mid(2, 1));
        initialize4();
    });

    connect(reply, &QModbusReply::errorOccurred, m_initObject, [reply] (QModbusDevice::Error error){
        qCWarning(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while updating block \"batteryInformation\" registers" << error << reply->errorString();
    });
}

void SungrowModbusTcpConnection::initialize4()
{
    QModbusReply *reply = nullptr;

    // Read Battery nominal power
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Read init \"Battery nominal power\" register:" << 33046 << "size:" << 1;
    reply = readBatteryNominalPower();
    if (!reply) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Error occurred while reading \"Battery nominal power\" registers from" << hostAddress().toString() << errorString();
        finishInitialization(false);
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, m_initObject, [this, reply](){
        handleModbusError(reply->error());
        m_pendingInitReplies.removeAll(reply);
        if (reply->error() != QModbusDevice::NoError) {
            finishInitialization(false);
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSungrowModbusTcpConnection()) << "<-- Response from init \"Battery nominal power\" register" << 33046 << "size:" << 1 << unit.values();
        processBatteryNominalPowerRegisterValues(unit.values());
        verifyInitFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, m_initObject, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while reading \"Battery nominal power\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

bool SungrowModbusTcpConnection::update()
{
    if (!connected())
        return false;

    if (!m_pendingUpdateReplies.isEmpty()) {
        qCDebug(dcSungrowModbusTcpConnection()) << "Tried to update but there are still some update replies pending. Waiting for them to be finished...";
        return true;
    }

    QModbusReply *reply = nullptr;

    // Read Battery nominal power
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Read \"Battery nominal power\" register:" << 33046 << "size:" << 1;
    reply = readBatteryNominalPower();
    if (!reply) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Error occurred while reading \"Battery nominal power\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSungrowModbusTcpConnection()) << "<-- Response from \"Battery nominal power\" register" << 33046 << "size:" << 1 << unit.values();
        processBatteryNominalPowerRegisterValues(unit.values());
        update2();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while reading \"Battery nominal power\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    return true;
}

void SungrowModbusTcpConnection::update2()
{
    QModbusReply *reply = nullptr;

    // Read Inverter export limit
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Read \"Inverter export limit\" register:" << 13073 << "size:" << 1;
    reply = readExportLimit();
    if (!reply) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Error occurred while reading \"Inverter export limit\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSungrowModbusTcpConnection()) << "<-- Response from \"Inverter export limit\" register" << 13073 << "size:" << 1 << unit.values();
        processExportLimitRegisterValues(unit.values());
        update3();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while reading \"Inverter export limit\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SungrowModbusTcpConnection::update3()
{
    QModbusReply *reply = nullptr;

    // Read Inverter export mode
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Read \"Inverter export mode\" register:" << 13086 << "size:" << 1;
    reply = readExportLimitMode();
    if (!reply) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Error occurred while reading \"Inverter export mode\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSungrowModbusTcpConnection()) << "<-- Response from \"Inverter export mode\" register" << 13086 << "size:" << 1 << unit.values();
        processExportLimitModeRegisterValues(unit.values());
        update4();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while reading \"Inverter export mode\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SungrowModbusTcpConnection::update4()
{
    QModbusReply *reply = nullptr;

    // Read energyValues1
    reply = readBlockEnergyValues1();
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Read block \"energyValues1\" registers from:" << 5007 << "size:" << 29;
    if (!reply) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Error occurred while reading block \"energyValues1\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSungrowModbusTcpConnection()) << "<-- Response from reading block \"energyValues1\" register" << 5007 << "size:" << 29 << blockValues;
        processInverterTemperatureRegisterValues(blockValues.mid(0, 1));
        processDummy0RegisterValues(blockValues.mid(1, 8));
        processTotalPVPowerRegisterValues(blockValues.mid(9, 2));
        processPhaseAVoltageRegisterValues(blockValues.mid(11, 1));
        processPhaseBVoltageRegisterValues(blockValues.mid(12, 1));
        processPhaseCVoltageRegisterValues(blockValues.mid(13, 1));
        processDummy1RegisterValues(blockValues.mid(14, 11));
        processReactivePowerRegisterValues(blockValues.mid(25, 2));
        processPowerFactorRegisterValues(blockValues.mid(27, 1));
        processGridFrequencyRegisterValues(blockValues.mid(28, 1));
        update5();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while updating block \"energyValues1\" registers" << error << reply->errorString();
    });
}

void SungrowModbusTcpConnection::update5()
{
    QModbusReply *reply = nullptr;
    // Read energyValues2
    reply = readBlockEnergyValues2();
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Read block \"energyValues2\" registers from:" << 12999 << "size:" << 48;
    if (!reply) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Error occurred while reading block \"energyValues2\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSungrowModbusTcpConnection()) << "<-- Response from reading block \"energyValues2\" register" << 12999 << "size:" << 48 << blockValues;
        processSystemStateRegisterValues(blockValues.mid(0, 1));
        processRunningStateRegisterValues(blockValues.mid(1, 1));
        processDailyPVGenerationRegisterValues(blockValues.mid(2, 1));
        processTotalPVGenerationRegisterValues(blockValues.mid(3, 2));
        processDailyPVExportRegisterValues(blockValues.mid(5, 1));
        processTotalPVExportRegisterValues(blockValues.mid(6, 2));
        processLoadPowerRegisterValues(blockValues.mid(8, 2));
        processExportPowerRegisterValues(blockValues.mid(10, 2));
        processDailyBatteryChargePVRegisterValues(blockValues.mid(12, 1));
        processTotalBatteryChargePVRegisterValues(blockValues.mid(13, 2));
        processDummy2RegisterValues(blockValues.mid(15, 5));
        processBatteryVoltageRegisterValues(blockValues.mid(20, 1));
        processBatteryCurrentRegisterValues(blockValues.mid(21, 1));
        processBatteryPowerRegisterValues(blockValues.mid(22, 1));
        processBatteryLevelRegisterValues(blockValues.mid(23, 1));
        processBatteryHealthStateRegisterValues(blockValues.mid(24, 1));
        processBatteryTemperatureRegisterValues(blockValues.mid(25, 1));
        processDummy3RegisterValues(blockValues.mid(26, 4));
        processGridStateRegisterValues(blockValues.mid(30, 1));
        processPhaseACurrentRegisterValues(blockValues.mid(31, 1));
        processPhaseBCurrentRegisterValues(blockValues.mid(32, 1));
        processPhaseCCurrentRegisterValues(blockValues.mid(33, 1));
        processTotalActivePowerRegisterValues(blockValues.mid(34, 2));
        processDailyImportEnergyRegisterValues(blockValues.mid(36, 1));
        processTotalImportEnergyRegisterValues(blockValues.mid(37, 2));
        processTotalBatteryCapacityRegisterValues(blockValues.mid(39, 1));
        processDummy4RegisterValues(blockValues.mid(40, 6));
        processTotalExportEnergyRegisterValues(blockValues.mid(46, 2));
        update6();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while updating block \"energyValues2\" registers" << error << reply->errorString();
    });
}

void SungrowModbusTcpConnection::update6()
{
    QModbusReply *reply = nullptr;
    // Read batteryControl
    reply = readBlockBatteryControl();
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Read block \"batteryControl\" registers from:" << 13049 << "size:" << 3;
    if (!reply) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Error occurred while reading block \"batteryControl\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSungrowModbusTcpConnection()) << "<-- Response from reading block \"batteryControl\" register" << 13049 << "size:" << 3 << blockValues;
        processEmsModeSelectionRegisterValues(blockValues.mid(0, 1));
        processChargeCommandRegisterValues(blockValues.mid(1, 1));
        processChargePowerRegisterValues(blockValues.mid(2, 1));
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while updating block \"batteryControl\" registers" << error << reply->errorString();
    });
}

void SungrowModbusTcpConnection::updateExportLimit()
{
    // Update registers from Inverter export limit
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Read \"Inverter export limit\" register:" << 13073 << "size:" << 1;
    QModbusReply *reply = readExportLimit();
    if (!reply) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Error occurred while reading \"Inverter export limit\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSungrowModbusTcpConnection()) << "<-- Response from \"Inverter export limit\" register" << 13073 << "size:" << 1 << unit.values();
            processExportLimitRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while updating \"Inverter export limit\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SungrowModbusTcpConnection::updateExportLimitMode()
{
    // Update registers from Inverter export mode
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Read \"Inverter export mode\" register:" << 13086 << "size:" << 1;
    QModbusReply *reply = readExportLimitMode();
    if (!reply) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Error occurred while reading \"Inverter export mode\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSungrowModbusTcpConnection()) << "<-- Response from \"Inverter export mode\" register" << 13086 << "size:" << 1 << unit.values();
            processExportLimitModeRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while updating \"Inverter export mode\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SungrowModbusTcpConnection::updateBatteryMinLevel()
{
    // Update registers from Battery min SOC
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Read \"Battery min SOC\" register:" << 13058 << "size:" << 1;
    QModbusReply *reply = readBatteryMinLevel();
    if (!reply) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Error occurred while reading \"Battery min SOC\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSungrowModbusTcpConnection()) << "<-- Response from \"Battery min SOC\" register" << 13058 << "size:" << 1 << unit.values();
            processBatteryMinLevelRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while updating \"Battery min SOC\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SungrowModbusTcpConnection::updateVersionBlock()
{
    // Update register block "version"
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Read block \"version\" registers from:" << 4949 << "size:" << 34;
    QModbusReply *reply = readBlockVersion();
    if (!reply) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Error occurred while reading block \"version\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSungrowModbusTcpConnection()) << "<-- Response from reading block \"version\" register" << 4949 << "size:" << 34 << blockValues;
            processProtocolNumberRegisterValues(blockValues.mid(0, 2));
            processProtocolVersionRegisterValues(blockValues.mid(2, 2));
            processArmSoftwareVersionRegisterValues(blockValues.mid(4, 15));
            processDspSoftwareVersionRegisterValues(blockValues.mid(19, 15));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while updating block \"version\" registers" << error << reply->errorString();
    });
}

void SungrowModbusTcpConnection::updateIdentificationBlock()
{
    // Update register block "identification"
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Read block \"identification\" registers from:" << 4989 << "size:" << 12;
    QModbusReply *reply = readBlockIdentification();
    if (!reply) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Error occurred while reading block \"identification\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSungrowModbusTcpConnection()) << "<-- Response from reading block \"identification\" register" << 4989 << "size:" << 12 << blockValues;
            processSerialNumberRegisterValues(blockValues.mid(0, 10));
            processDeviceTypeCodeRegisterValues(blockValues.mid(10, 1));
            processNominalOutputPowerRegisterValues(blockValues.mid(11, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while updating block \"identification\" registers" << error << reply->errorString();
    });
}

void SungrowModbusTcpConnection::updateEnergyValues1Block()
{
    // Update register block "energyValues1"
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Read block \"energyValues1\" registers from:" << 5007 << "size:" << 29;
    QModbusReply *reply = readBlockEnergyValues1();
    if (!reply) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Error occurred while reading block \"energyValues1\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSungrowModbusTcpConnection()) << "<-- Response from reading block \"energyValues1\" register" << 5007 << "size:" << 29 << blockValues;
            processInverterTemperatureRegisterValues(blockValues.mid(0, 1));
            processDummy0RegisterValues(blockValues.mid(1, 8));
            processTotalPVPowerRegisterValues(blockValues.mid(9, 2));
            processPhaseAVoltageRegisterValues(blockValues.mid(11, 1));
            processPhaseBVoltageRegisterValues(blockValues.mid(12, 1));
            processPhaseCVoltageRegisterValues(blockValues.mid(13, 1));
            processDummy1RegisterValues(blockValues.mid(14, 11));
            processReactivePowerRegisterValues(blockValues.mid(25, 2));
            processPowerFactorRegisterValues(blockValues.mid(27, 1));
            processGridFrequencyRegisterValues(blockValues.mid(28, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while updating block \"energyValues1\" registers" << error << reply->errorString();
    });
}

void SungrowModbusTcpConnection::updateEnergyValues2Block()
{
    // Update register block "energyValues2"
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Read block \"energyValues2\" registers from:" << 12999 << "size:" << 48;
    QModbusReply *reply = readBlockEnergyValues2();
    if (!reply) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Error occurred while reading block \"energyValues2\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSungrowModbusTcpConnection()) << "<-- Response from reading block \"energyValues2\" register" << 12999 << "size:" << 48 << blockValues;
            processSystemStateRegisterValues(blockValues.mid(0, 1));
            processRunningStateRegisterValues(blockValues.mid(1, 1));
            processDailyPVGenerationRegisterValues(blockValues.mid(2, 1));
            processTotalPVGenerationRegisterValues(blockValues.mid(3, 2));
            processDailyPVExportRegisterValues(blockValues.mid(5, 1));
            processTotalPVExportRegisterValues(blockValues.mid(6, 2));
            processLoadPowerRegisterValues(blockValues.mid(8, 2));
            processExportPowerRegisterValues(blockValues.mid(10, 2));
            processDailyBatteryChargePVRegisterValues(blockValues.mid(12, 1));
            processTotalBatteryChargePVRegisterValues(blockValues.mid(13, 2));
            processDummy2RegisterValues(blockValues.mid(15, 5));
            processBatteryVoltageRegisterValues(blockValues.mid(20, 1));
            processBatteryCurrentRegisterValues(blockValues.mid(21, 1));
            processBatteryPowerRegisterValues(blockValues.mid(22, 1));
            processBatteryLevelRegisterValues(blockValues.mid(23, 1));
            processBatteryHealthStateRegisterValues(blockValues.mid(24, 1));
            processBatteryTemperatureRegisterValues(blockValues.mid(25, 1));
            processDummy3RegisterValues(blockValues.mid(26, 4));
            processGridStateRegisterValues(blockValues.mid(30, 1));
            processPhaseACurrentRegisterValues(blockValues.mid(31, 1));
            processPhaseBCurrentRegisterValues(blockValues.mid(32, 1));
            processPhaseCCurrentRegisterValues(blockValues.mid(33, 1));
            processTotalActivePowerRegisterValues(blockValues.mid(34, 2));
            processDailyImportEnergyRegisterValues(blockValues.mid(36, 1));
            processTotalImportEnergyRegisterValues(blockValues.mid(37, 2));
            processTotalBatteryCapacityRegisterValues(blockValues.mid(39, 1));
            processDummy4RegisterValues(blockValues.mid(40, 6));
            processTotalExportEnergyRegisterValues(blockValues.mid(46, 2));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while updating block \"energyValues2\" registers" << error << reply->errorString();
    });
}

void SungrowModbusTcpConnection::updateBatteryInformationBlock()
{
    // Update register block "batteryInformation"
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Read block \"batteryInformation\" registers from:" << 13054 << "size:" << 3;
    QModbusReply *reply = readBlockBatteryInformation();
    if (!reply) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Error occurred while reading block \"batteryInformation\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSungrowModbusTcpConnection()) << "<-- Response from reading block \"batteryInformation\" register" << 13054 << "size:" << 3 << blockValues;
            processBatteryTypeRegisterValues(blockValues.mid(0, 1));
            processBatteryNominalVoltageRegisterValues(blockValues.mid(1, 1));
            processBatteryCapacityRegisterValues(blockValues.mid(2, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while updating block \"batteryInformation\" registers" << error << reply->errorString();
    });
}

void SungrowModbusTcpConnection::updateBatteryControlBlock()
{
    // Update register block "batteryControl"
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Read block \"batteryControl\" registers from:" << 13049 << "size:" << 3;
    QModbusReply *reply = readBlockBatteryControl();
    if (!reply) {
        qCWarning(dcSungrowModbusTcpConnection()) << "Error occurred while reading block \"batteryControl\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSungrowModbusTcpConnection()) << "<-- Response from reading block \"batteryControl\" register" << 13049 << "size:" << 3 << blockValues;
            processEmsModeSelectionRegisterValues(blockValues.mid(0, 1));
            processChargeCommandRegisterValues(blockValues.mid(1, 1));
            processChargePowerRegisterValues(blockValues.mid(2, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while updating block \"batteryControl\" registers" << error << reply->errorString();
    });
}

QModbusReply *SungrowModbusTcpConnection::readBatteryNominalPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 33046, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readExportLimit()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 13073, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readExportLimitMode()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 13086, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readBatteryMinLevel()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 13058, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readProtocolNumber()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4949, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readProtocolVersion()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4951, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readArmSoftwareVersion()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4953, 15);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readDspSoftwareVersion()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4968, 15);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readSerialNumber()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4989, 10);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readDeviceTypeCode()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4999, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readNominalOutputPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 5000, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readInverterTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 5007, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readDummy0()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 5008, 8);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readTotalPVPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 5016, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readPhaseAVoltage()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 5018, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readPhaseBVoltage()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 5019, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readPhaseCVoltage()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 5020, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readDummy1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 5021, 11);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readReactivePower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 5032, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readPowerFactor()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 5034, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readGridFrequency()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 5035, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readSystemState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 12999, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readRunningState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13000, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readDailyPVGeneration()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13001, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readTotalPVGeneration()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13002, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readDailyPVExport()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13004, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readTotalPVExport()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13005, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readLoadPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13007, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readExportPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13009, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readDailyBatteryChargePV()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13011, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readTotalBatteryChargePV()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13012, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readDummy2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13014, 5);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readBatteryVoltage()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13019, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readBatteryCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13020, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readBatteryPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13021, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readBatteryLevel()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13022, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readBatteryHealthState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13023, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readBatteryTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13024, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readDummy3()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13025, 4);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readGridState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13029, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readPhaseACurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13030, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readPhaseBCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13031, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readPhaseCCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13032, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readTotalActivePower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13033, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readDailyImportEnergy()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13035, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readTotalImportEnergy()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13036, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readTotalBatteryCapacity()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13038, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readDummy4()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13039, 6);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readTotalExportEnergy()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13045, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readBatteryType()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 13054, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readBatteryNominalVoltage()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 13055, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readBatteryCapacity()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 13056, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readEmsModeSelection()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 13049, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readChargeCommand()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 13050, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readChargePower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 13051, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readBlockVersion()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4949, 34);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readBlockIdentification()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4989, 12);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readBlockEnergyValues1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 5007, 29);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readBlockEnergyValues2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 12999, 48);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readBlockBatteryInformation()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 13054, 3);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SungrowModbusTcpConnection::readBlockBatteryControl()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 13049, 3);
    return sendReadRequest(request, m_slaveId);
}

void SungrowModbusTcpConnection::processBatteryNominalPowerRegisterValues(const QVector<quint16> values)
{
    float receivedBatteryNominalPower = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, 1);
    emit batteryNominalPowerReadFinished(receivedBatteryNominalPower);

    if (m_batteryNominalPower != receivedBatteryNominalPower) {
        m_batteryNominalPower = receivedBatteryNominalPower;
        emit batteryNominalPowerChanged(m_batteryNominalPower);
    }
}

void SungrowModbusTcpConnection::processExportLimitRegisterValues(const QVector<quint16> values)
{
    quint16 receivedExportLimit = ModbusDataUtils::convertToUInt16(values);
    emit exportLimitReadFinished(receivedExportLimit);

    if (m_exportLimit != receivedExportLimit) {
        m_exportLimit = receivedExportLimit;
        emit exportLimitChanged(m_exportLimit);
    }
}

void SungrowModbusTcpConnection::processExportLimitModeRegisterValues(const QVector<quint16> values)
{
    quint16 receivedExportLimitMode = ModbusDataUtils::convertToUInt16(values);
    emit exportLimitModeReadFinished(receivedExportLimitMode);

    if (m_exportLimitMode != receivedExportLimitMode) {
        m_exportLimitMode = receivedExportLimitMode;
        emit exportLimitModeChanged(m_exportLimitMode);
    }
}

void SungrowModbusTcpConnection::processBatteryMinLevelRegisterValues(const QVector<quint16> values)
{
    float receivedBatteryMinLevel = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit batteryMinLevelReadFinished(receivedBatteryMinLevel);

    if (m_batteryMinLevel != receivedBatteryMinLevel) {
        m_batteryMinLevel = receivedBatteryMinLevel;
        emit batteryMinLevelChanged(m_batteryMinLevel);
    }
}

void SungrowModbusTcpConnection::processProtocolNumberRegisterValues(const QVector<quint16> values)
{
    quint32 receivedProtocolNumber = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit protocolNumberReadFinished(receivedProtocolNumber);

    if (m_protocolNumber != receivedProtocolNumber) {
        m_protocolNumber = receivedProtocolNumber;
        emit protocolNumberChanged(m_protocolNumber);
    }
}

void SungrowModbusTcpConnection::processProtocolVersionRegisterValues(const QVector<quint16> values)
{
    quint32 receivedProtocolVersion = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit protocolVersionReadFinished(receivedProtocolVersion);

    if (m_protocolVersion != receivedProtocolVersion) {
        m_protocolVersion = receivedProtocolVersion;
        emit protocolVersionChanged(m_protocolVersion);
    }
}

void SungrowModbusTcpConnection::processArmSoftwareVersionRegisterValues(const QVector<quint16> values)
{
    QString receivedArmSoftwareVersion = ModbusDataUtils::convertToString(values);
    emit armSoftwareVersionReadFinished(receivedArmSoftwareVersion);

    if (m_armSoftwareVersion != receivedArmSoftwareVersion) {
        m_armSoftwareVersion = receivedArmSoftwareVersion;
        emit armSoftwareVersionChanged(m_armSoftwareVersion);
    }
}

void SungrowModbusTcpConnection::processDspSoftwareVersionRegisterValues(const QVector<quint16> values)
{
    QString receivedDspSoftwareVersion = ModbusDataUtils::convertToString(values);
    emit dspSoftwareVersionReadFinished(receivedDspSoftwareVersion);

    if (m_dspSoftwareVersion != receivedDspSoftwareVersion) {
        m_dspSoftwareVersion = receivedDspSoftwareVersion;
        emit dspSoftwareVersionChanged(m_dspSoftwareVersion);
    }
}

void SungrowModbusTcpConnection::processSerialNumberRegisterValues(const QVector<quint16> values)
{
    QString receivedSerialNumber = ModbusDataUtils::convertToString(values);
    emit serialNumberReadFinished(receivedSerialNumber);

    if (m_serialNumber != receivedSerialNumber) {
        m_serialNumber = receivedSerialNumber;
        emit serialNumberChanged(m_serialNumber);
    }
}

void SungrowModbusTcpConnection::processDeviceTypeCodeRegisterValues(const QVector<quint16> values)
{
    quint16 receivedDeviceTypeCode = ModbusDataUtils::convertToUInt16(values);
    emit deviceTypeCodeReadFinished(receivedDeviceTypeCode);

    if (m_deviceTypeCode != receivedDeviceTypeCode) {
        m_deviceTypeCode = receivedDeviceTypeCode;
        emit deviceTypeCodeChanged(m_deviceTypeCode);
    }
}

void SungrowModbusTcpConnection::processNominalOutputPowerRegisterValues(const QVector<quint16> values)
{
    float receivedNominalOutputPower = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit nominalOutputPowerReadFinished(receivedNominalOutputPower);

    if (m_nominalOutputPower != receivedNominalOutputPower) {
        m_nominalOutputPower = receivedNominalOutputPower;
        emit nominalOutputPowerChanged(m_nominalOutputPower);
    }
}

void SungrowModbusTcpConnection::processInverterTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedInverterTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit inverterTemperatureReadFinished(receivedInverterTemperature);

    if (m_inverterTemperature != receivedInverterTemperature) {
        m_inverterTemperature = receivedInverterTemperature;
        emit inverterTemperatureChanged(m_inverterTemperature);
    }
}

void SungrowModbusTcpConnection::processDummy0RegisterValues(const QVector<quint16> values)
{
    QVector<quint16> receivedDummy0 = values;
    emit dummy0ReadFinished(receivedDummy0);

    if (m_dummy0 != receivedDummy0) {
        m_dummy0 = receivedDummy0;
        emit dummy0Changed(m_dummy0);
    }
}

void SungrowModbusTcpConnection::processTotalPVPowerRegisterValues(const QVector<quint16> values)
{
    quint32 receivedTotalPVPower = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit totalPVPowerReadFinished(receivedTotalPVPower);

    if (m_totalPVPower != receivedTotalPVPower) {
        m_totalPVPower = receivedTotalPVPower;
        emit totalPVPowerChanged(m_totalPVPower);
    }
}

void SungrowModbusTcpConnection::processPhaseAVoltageRegisterValues(const QVector<quint16> values)
{
    float receivedPhaseAVoltage = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit phaseAVoltageReadFinished(receivedPhaseAVoltage);

    if (m_phaseAVoltage != receivedPhaseAVoltage) {
        m_phaseAVoltage = receivedPhaseAVoltage;
        emit phaseAVoltageChanged(m_phaseAVoltage);
    }
}

void SungrowModbusTcpConnection::processPhaseBVoltageRegisterValues(const QVector<quint16> values)
{
    float receivedPhaseBVoltage = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit phaseBVoltageReadFinished(receivedPhaseBVoltage);

    if (m_phaseBVoltage != receivedPhaseBVoltage) {
        m_phaseBVoltage = receivedPhaseBVoltage;
        emit phaseBVoltageChanged(m_phaseBVoltage);
    }
}

void SungrowModbusTcpConnection::processPhaseCVoltageRegisterValues(const QVector<quint16> values)
{
    float receivedPhaseCVoltage = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit phaseCVoltageReadFinished(receivedPhaseCVoltage);

    if (m_phaseCVoltage != receivedPhaseCVoltage) {
        m_phaseCVoltage = receivedPhaseCVoltage;
        emit phaseCVoltageChanged(m_phaseCVoltage);
    }
}

void SungrowModbusTcpConnection::processDummy1RegisterValues(const QVector<quint16> values)
{
    QVector<quint16> receivedDummy1 = values;
    emit dummy1ReadFinished(receivedDummy1);

    if (m_dummy1 != receivedDummy1) {
        m_dummy1 = receivedDummy1;
        emit dummy1Changed(m_dummy1);
    }
}

void SungrowModbusTcpConnection::processReactivePowerRegisterValues(const QVector<quint16> values)
{
    qint32 receivedReactivePower = ModbusDataUtils::convertToInt32(values, m_endianness);
    emit reactivePowerReadFinished(receivedReactivePower);

    if (m_reactivePower != receivedReactivePower) {
        m_reactivePower = receivedReactivePower;
        emit reactivePowerChanged(m_reactivePower);
    }
}

void SungrowModbusTcpConnection::processPowerFactorRegisterValues(const QVector<quint16> values)
{
    float receivedPowerFactor = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -3);
    emit powerFactorReadFinished(receivedPowerFactor);

    if (m_powerFactor != receivedPowerFactor) {
        m_powerFactor = receivedPowerFactor;
        emit powerFactorChanged(m_powerFactor);
    }
}

void SungrowModbusTcpConnection::processGridFrequencyRegisterValues(const QVector<quint16> values)
{
    float receivedGridFrequency = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit gridFrequencyReadFinished(receivedGridFrequency);

    if (m_gridFrequency != receivedGridFrequency) {
        m_gridFrequency = receivedGridFrequency;
        emit gridFrequencyChanged(m_gridFrequency);
    }
}

void SungrowModbusTcpConnection::processSystemStateRegisterValues(const QVector<quint16> values)
{
    SystemState receivedSystemState = static_cast<SystemState>(ModbusDataUtils::convertToUInt16(values));
    emit systemStateReadFinished(receivedSystemState);

    if (m_systemState != receivedSystemState) {
        m_systemState = receivedSystemState;
        emit systemStateChanged(m_systemState);
    }
}

void SungrowModbusTcpConnection::processRunningStateRegisterValues(const QVector<quint16> values)
{
    quint16 receivedRunningState = ModbusDataUtils::convertToUInt16(values);
    emit runningStateReadFinished(receivedRunningState);

    if (m_runningState != receivedRunningState) {
        m_runningState = receivedRunningState;
        emit runningStateChanged(m_runningState);
    }
}

void SungrowModbusTcpConnection::processDailyPVGenerationRegisterValues(const QVector<quint16> values)
{
    float receivedDailyPVGeneration = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit dailyPVGenerationReadFinished(receivedDailyPVGeneration);

    if (m_dailyPVGeneration != receivedDailyPVGeneration) {
        m_dailyPVGeneration = receivedDailyPVGeneration;
        emit dailyPVGenerationChanged(m_dailyPVGeneration);
    }
}

void SungrowModbusTcpConnection::processTotalPVGenerationRegisterValues(const QVector<quint16> values)
{
    float receivedTotalPVGeneration = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -1);
    emit totalPVGenerationReadFinished(receivedTotalPVGeneration);

    if (m_totalPVGeneration != receivedTotalPVGeneration) {
        m_totalPVGeneration = receivedTotalPVGeneration;
        emit totalPVGenerationChanged(m_totalPVGeneration);
    }
}

void SungrowModbusTcpConnection::processDailyPVExportRegisterValues(const QVector<quint16> values)
{
    float receivedDailyPVExport = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit dailyPVExportReadFinished(receivedDailyPVExport);

    if (m_dailyPVExport != receivedDailyPVExport) {
        m_dailyPVExport = receivedDailyPVExport;
        emit dailyPVExportChanged(m_dailyPVExport);
    }
}

void SungrowModbusTcpConnection::processTotalPVExportRegisterValues(const QVector<quint16> values)
{
    float receivedTotalPVExport = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -1);
    emit totalPVExportReadFinished(receivedTotalPVExport);

    if (m_totalPVExport != receivedTotalPVExport) {
        m_totalPVExport = receivedTotalPVExport;
        emit totalPVExportChanged(m_totalPVExport);
    }
}

void SungrowModbusTcpConnection::processLoadPowerRegisterValues(const QVector<quint16> values)
{
    qint32 receivedLoadPower = ModbusDataUtils::convertToInt32(values, m_endianness);
    emit loadPowerReadFinished(receivedLoadPower);

    if (m_loadPower != receivedLoadPower) {
        m_loadPower = receivedLoadPower;
        emit loadPowerChanged(m_loadPower);
    }
}

void SungrowModbusTcpConnection::processExportPowerRegisterValues(const QVector<quint16> values)
{
    qint32 receivedExportPower = ModbusDataUtils::convertToInt32(values, m_endianness);
    emit exportPowerReadFinished(receivedExportPower);

    if (m_exportPower != receivedExportPower) {
        m_exportPower = receivedExportPower;
        emit exportPowerChanged(m_exportPower);
    }
}

void SungrowModbusTcpConnection::processDailyBatteryChargePVRegisterValues(const QVector<quint16> values)
{
    float receivedDailyBatteryChargePV = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit dailyBatteryChargePVReadFinished(receivedDailyBatteryChargePV);

    if (m_dailyBatteryChargePV != receivedDailyBatteryChargePV) {
        m_dailyBatteryChargePV = receivedDailyBatteryChargePV;
        emit dailyBatteryChargePVChanged(m_dailyBatteryChargePV);
    }
}

void SungrowModbusTcpConnection::processTotalBatteryChargePVRegisterValues(const QVector<quint16> values)
{
    float receivedTotalBatteryChargePV = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -1);
    emit totalBatteryChargePVReadFinished(receivedTotalBatteryChargePV);

    if (m_totalBatteryChargePV != receivedTotalBatteryChargePV) {
        m_totalBatteryChargePV = receivedTotalBatteryChargePV;
        emit totalBatteryChargePVChanged(m_totalBatteryChargePV);
    }
}

void SungrowModbusTcpConnection::processDummy2RegisterValues(const QVector<quint16> values)
{
    QVector<quint16> receivedDummy2 = values;
    emit dummy2ReadFinished(receivedDummy2);

    if (m_dummy2 != receivedDummy2) {
        m_dummy2 = receivedDummy2;
        emit dummy2Changed(m_dummy2);
    }
}

void SungrowModbusTcpConnection::processBatteryVoltageRegisterValues(const QVector<quint16> values)
{
    float receivedBatteryVoltage = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit batteryVoltageReadFinished(receivedBatteryVoltage);

    if (m_batteryVoltage != receivedBatteryVoltage) {
        m_batteryVoltage = receivedBatteryVoltage;
        emit batteryVoltageChanged(m_batteryVoltage);
    }
}

void SungrowModbusTcpConnection::processBatteryCurrentRegisterValues(const QVector<quint16> values)
{
    float receivedBatteryCurrent = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit batteryCurrentReadFinished(receivedBatteryCurrent);

    if (m_batteryCurrent != receivedBatteryCurrent) {
        m_batteryCurrent = receivedBatteryCurrent;
        emit batteryCurrentChanged(m_batteryCurrent);
    }
}

void SungrowModbusTcpConnection::processBatteryPowerRegisterValues(const QVector<quint16> values)
{
    quint16 receivedBatteryPower = ModbusDataUtils::convertToInt16(values);
    emit batteryPowerReadFinished(receivedBatteryPower);

    if (m_batteryPower != receivedBatteryPower) {
        m_batteryPower = receivedBatteryPower;
        emit batteryPowerChanged(m_batteryPower);
    }
}

void SungrowModbusTcpConnection::processBatteryLevelRegisterValues(const QVector<quint16> values)
{
    float receivedBatteryLevel = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit batteryLevelReadFinished(receivedBatteryLevel);

    if (m_batteryLevel != receivedBatteryLevel) {
        m_batteryLevel = receivedBatteryLevel;
        emit batteryLevelChanged(m_batteryLevel);
    }
}

void SungrowModbusTcpConnection::processBatteryHealthStateRegisterValues(const QVector<quint16> values)
{
    float receivedBatteryHealthState = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit batteryHealthStateReadFinished(receivedBatteryHealthState);

    if (m_batteryHealthState != receivedBatteryHealthState) {
        m_batteryHealthState = receivedBatteryHealthState;
        emit batteryHealthStateChanged(m_batteryHealthState);
    }
}

void SungrowModbusTcpConnection::processBatteryTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedBatteryTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit batteryTemperatureReadFinished(receivedBatteryTemperature);

    if (m_batteryTemperature != receivedBatteryTemperature) {
        m_batteryTemperature = receivedBatteryTemperature;
        emit batteryTemperatureChanged(m_batteryTemperature);
    }
}

void SungrowModbusTcpConnection::processDummy3RegisterValues(const QVector<quint16> values)
{
    QVector<quint16> receivedDummy3 = values;
    emit dummy3ReadFinished(receivedDummy3);

    if (m_dummy3 != receivedDummy3) {
        m_dummy3 = receivedDummy3;
        emit dummy3Changed(m_dummy3);
    }
}

void SungrowModbusTcpConnection::processGridStateRegisterValues(const QVector<quint16> values)
{
    quint16 receivedGridState = ModbusDataUtils::convertToUInt16(values);
    emit gridStateReadFinished(receivedGridState);

    if (m_gridState != receivedGridState) {
        m_gridState = receivedGridState;
        emit gridStateChanged(m_gridState);
    }
}

void SungrowModbusTcpConnection::processPhaseACurrentRegisterValues(const QVector<quint16> values)
{
    float receivedPhaseACurrent = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit phaseACurrentReadFinished(receivedPhaseACurrent);

    if (m_phaseACurrent != receivedPhaseACurrent) {
        m_phaseACurrent = receivedPhaseACurrent;
        emit phaseACurrentChanged(m_phaseACurrent);
    }
}

void SungrowModbusTcpConnection::processPhaseBCurrentRegisterValues(const QVector<quint16> values)
{
    float receivedPhaseBCurrent = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit phaseBCurrentReadFinished(receivedPhaseBCurrent);

    if (m_phaseBCurrent != receivedPhaseBCurrent) {
        m_phaseBCurrent = receivedPhaseBCurrent;
        emit phaseBCurrentChanged(m_phaseBCurrent);
    }
}

void SungrowModbusTcpConnection::processPhaseCCurrentRegisterValues(const QVector<quint16> values)
{
    float receivedPhaseCCurrent = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit phaseCCurrentReadFinished(receivedPhaseCCurrent);

    if (m_phaseCCurrent != receivedPhaseCCurrent) {
        m_phaseCCurrent = receivedPhaseCCurrent;
        emit phaseCCurrentChanged(m_phaseCCurrent);
    }
}

void SungrowModbusTcpConnection::processTotalActivePowerRegisterValues(const QVector<quint16> values)
{
    qint32 receivedTotalActivePower = ModbusDataUtils::convertToInt32(values, m_endianness);
    emit totalActivePowerReadFinished(receivedTotalActivePower);

    if (m_totalActivePower != receivedTotalActivePower) {
        m_totalActivePower = receivedTotalActivePower;
        emit totalActivePowerChanged(m_totalActivePower);
    }
}

void SungrowModbusTcpConnection::processDailyImportEnergyRegisterValues(const QVector<quint16> values)
{
    float receivedDailyImportEnergy = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit dailyImportEnergyReadFinished(receivedDailyImportEnergy);

    if (m_dailyImportEnergy != receivedDailyImportEnergy) {
        m_dailyImportEnergy = receivedDailyImportEnergy;
        emit dailyImportEnergyChanged(m_dailyImportEnergy);
    }
}

void SungrowModbusTcpConnection::processTotalImportEnergyRegisterValues(const QVector<quint16> values)
{
    float receivedTotalImportEnergy = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -1);
    emit totalImportEnergyReadFinished(receivedTotalImportEnergy);

    if (m_totalImportEnergy != receivedTotalImportEnergy) {
        m_totalImportEnergy = receivedTotalImportEnergy;
        emit totalImportEnergyChanged(m_totalImportEnergy);
    }
}

void SungrowModbusTcpConnection::processTotalBatteryCapacityRegisterValues(const QVector<quint16> values)
{
    float receivedTotalBatteryCapacity = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit totalBatteryCapacityReadFinished(receivedTotalBatteryCapacity);

    if (m_totalBatteryCapacity != receivedTotalBatteryCapacity) {
        m_totalBatteryCapacity = receivedTotalBatteryCapacity;
        emit totalBatteryCapacityChanged(m_totalBatteryCapacity);
    }
}

void SungrowModbusTcpConnection::processDummy4RegisterValues(const QVector<quint16> values)
{
    QVector<quint16> receivedDummy4 = values;
    emit dummy4ReadFinished(receivedDummy4);

    if (m_dummy4 != receivedDummy4) {
        m_dummy4 = receivedDummy4;
        emit dummy4Changed(m_dummy4);
    }
}

void SungrowModbusTcpConnection::processTotalExportEnergyRegisterValues(const QVector<quint16> values)
{
    float receivedTotalExportEnergy = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -1);
    emit totalExportEnergyReadFinished(receivedTotalExportEnergy);

    if (m_totalExportEnergy != receivedTotalExportEnergy) {
        m_totalExportEnergy = receivedTotalExportEnergy;
        emit totalExportEnergyChanged(m_totalExportEnergy);
    }
}

void SungrowModbusTcpConnection::processBatteryTypeRegisterValues(const QVector<quint16> values)
{
    BatteryType receivedBatteryType = static_cast<BatteryType>(ModbusDataUtils::convertToUInt16(values));
    emit batteryTypeReadFinished(receivedBatteryType);

    if (m_batteryType != receivedBatteryType) {
        m_batteryType = receivedBatteryType;
        emit batteryTypeChanged(m_batteryType);
    }
}

void SungrowModbusTcpConnection::processBatteryNominalVoltageRegisterValues(const QVector<quint16> values)
{
    float receivedBatteryNominalVoltage = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit batteryNominalVoltageReadFinished(receivedBatteryNominalVoltage);

    if (m_batteryNominalVoltage != receivedBatteryNominalVoltage) {
        m_batteryNominalVoltage = receivedBatteryNominalVoltage;
        emit batteryNominalVoltageChanged(m_batteryNominalVoltage);
    }
}

void SungrowModbusTcpConnection::processBatteryCapacityRegisterValues(const QVector<quint16> values)
{
    quint16 receivedBatteryCapacity = ModbusDataUtils::convertToUInt16(values);
    emit batteryCapacityReadFinished(receivedBatteryCapacity);

    if (m_batteryCapacity != receivedBatteryCapacity) {
        m_batteryCapacity = receivedBatteryCapacity;
        emit batteryCapacityChanged(m_batteryCapacity);
    }
}

void SungrowModbusTcpConnection::processEmsModeSelectionRegisterValues(const QVector<quint16> values)
{
    quint16 receivedEmsModeSelection = ModbusDataUtils::convertToUInt16(values);
    emit emsModeSelectionReadFinished(receivedEmsModeSelection);

    if (m_emsModeSelection != receivedEmsModeSelection) {
        m_emsModeSelection = receivedEmsModeSelection;
        emit emsModeSelectionChanged(m_emsModeSelection);
    }
}

void SungrowModbusTcpConnection::processChargeCommandRegisterValues(const QVector<quint16> values)
{
    quint16 receivedChargeCommand = ModbusDataUtils::convertToUInt16(values);
    emit chargeCommandReadFinished(receivedChargeCommand);

    if (m_chargeCommand != receivedChargeCommand) {
        m_chargeCommand = receivedChargeCommand;
        emit chargeCommandChanged(m_chargeCommand);
    }
}

void SungrowModbusTcpConnection::processChargePowerRegisterValues(const QVector<quint16> values)
{
    quint16 receivedChargePower = ModbusDataUtils::convertToUInt16(values);
    emit chargePowerReadFinished(receivedChargePower);

    if (m_chargePower != receivedChargePower) {
        m_chargePower = receivedChargePower;
        emit chargePowerChanged(m_chargePower);
    }
}

void SungrowModbusTcpConnection::handleModbusError(QModbusDevice::Error error)
{
    if (error == QModbusDevice::NoError) {
        // Reset the communication counter and we know we can reach the device
        m_communicationFailedCounter = 0;
        if (!m_communicationWorking)
            qCDebug(dcSungrowModbusTcpConnection()) << "Received a reply without any errors. The communication with the device seems to work now.";

        m_communicationWorking = true;
        evaluateReachableState();
    } else {
        m_communicationFailedCounter++;
        if (m_communicationWorking && m_communicationFailedCounter >= m_communicationFailedMax) {
            m_communicationWorking = false;
            qCWarning(dcSungrowModbusTcpConnection()) << "Received" << m_communicationFailedCounter << "errors while communicating with the RTU master. Mark as not reachable until the communication works again.";
            evaluateReachableState();
        }
    }
}

void SungrowModbusTcpConnection::testReachability()
{
    if (m_checkRechableReply)
        return;

    // Try to read the check reachability register totalPVPower in order to verify if the communication is working or not.
    qCDebug(dcSungrowModbusTcpConnection()) << "--> Test reachability by reading \"Total PV power\" register:" << 5016 << "size:" << 2;
    m_checkRechableReply = readTotalPVPower();
    if (!m_checkRechableReply) {
        qCDebug(dcSungrowModbusTcpConnection()) << "Error occurred verifying reachability by reading \"Total PV power\" register";
        onReachabilityCheckFailed();
        return;
    }

    if (m_checkRechableReply->isFinished()) {
        m_checkRechableReply->deleteLater(); // Broadcast reply returns immediatly
        m_checkRechableReply = nullptr;
        onReachabilityCheckFailed();
        return;
    }

    connect(m_checkRechableReply, &QModbusReply::finished, this, [this](){
        handleModbusError(m_checkRechableReply->error());
        if (m_checkRechableReply->error() != QModbusDevice::NoError)
            onReachabilityCheckFailed();

        m_checkRechableReply->deleteLater();
        m_checkRechableReply = nullptr;
    });

    connect(m_checkRechableReply, &QModbusReply::errorOccurred, this, [this] (QModbusDevice::Error error){
        qCDebug(dcSungrowModbusTcpConnection()) << "Modbus reply error occurred while verifying reachability by reading \"Total PV power\" register" << error << m_checkRechableReply->errorString();
    });
}

void SungrowModbusTcpConnection::verifyInitFinished()
{
    if (m_pendingInitReplies.isEmpty()) {
        finishInitialization(true);
    }
}

void SungrowModbusTcpConnection::finishInitialization(bool success)
{
    if (success) {
        qCDebug(dcSungrowModbusTcpConnection()) << "Initialization finished of SungrowModbusTcpConnection" << hostAddress().toString() << "finished successfully";
    } else {
        qCWarning(dcSungrowModbusTcpConnection()) << "Initialization finished of SungrowModbusTcpConnection" << hostAddress().toString() << "failed.";
    }

    // Cleanup init
    delete m_initObject;
    m_initObject = nullptr;
    m_pendingInitReplies.clear();

    emit initializationFinished(success);
}

void SungrowModbusTcpConnection::verifyUpdateFinished()
{
    if (m_pendingUpdateReplies.isEmpty()) {
        emit updateFinished();
    }
}

void SungrowModbusTcpConnection::onReachabilityCheckFailed()
{
    m_checkReachableRetriesCount++;

    if (m_checkReachableRetriesCount <= m_checkReachableRetries) {
        qCDebug(dcSungrowModbusTcpConnection()) << "Reachability test failed. Retry in on second" << m_checkReachableRetriesCount << "/" << m_checkReachableRetries;
        QTimer::singleShot(1000, this, &SungrowModbusTcpConnection::testReachability);
        return;
    }

    // The test reachability method failed, not retrying any more
    emit checkReachabilityFailed();
}

void SungrowModbusTcpConnection::evaluateReachableState()
{
    bool reachable = m_communicationWorking && connected();
    if (m_reachable == reachable)
        return;

    m_reachable = reachable;
    emit reachableChanged(m_reachable);
    m_checkReachableRetriesCount = 0;
}

QDebug operator<<(QDebug debug, SungrowModbusTcpConnection *sungrowModbusTcpConnection)
{
    debug.nospace().noquote() << "SungrowModbusTcpConnection(" << sungrowModbusTcpConnection->hostAddress().toString() << ":" << sungrowModbusTcpConnection->port() << ")" << "\n";
    debug.nospace().noquote() << "    - Battery nominal power: " << sungrowModbusTcpConnection->batteryNominalPower() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Inverter export limit: " << sungrowModbusTcpConnection->exportLimit() << "\n";
    debug.nospace().noquote() << "    - Inverter export mode: " << sungrowModbusTcpConnection->exportLimitMode() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Battery min SOC: " << sungrowModbusTcpConnection->batteryMinLevel() << " [%]" << "\n";
    debug.nospace().noquote() << "    - Protocol number: " << sungrowModbusTcpConnection->protocolNumber() << "\n";
    debug.nospace().noquote() << "    - Device type code: " << sungrowModbusTcpConnection->protocolVersion() << "\n";
    debug.nospace().noquote() << "    - ARM software version: " << sungrowModbusTcpConnection->armSoftwareVersion() << "\n";
    debug.nospace().noquote() << "    - ARM software version: " << sungrowModbusTcpConnection->dspSoftwareVersion() << "\n";
    debug.nospace().noquote() << "    - Serial number: " << sungrowModbusTcpConnection->serialNumber() << "\n";
    debug.nospace().noquote() << "    - Device type code: " << sungrowModbusTcpConnection->deviceTypeCode() << "\n";
    debug.nospace().noquote() << "    - Nominal output power: " << sungrowModbusTcpConnection->nominalOutputPower() << " [kW]" << "\n";
    debug.nospace().noquote() << "    - Inverter temperature: " << sungrowModbusTcpConnection->inverterTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - none: " << sungrowModbusTcpConnection->dummy0() << "\n";
    debug.nospace().noquote() << "    - Total PV power: " << sungrowModbusTcpConnection->totalPVPower() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Phase A voltage: " << sungrowModbusTcpConnection->phaseAVoltage() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Phase B voltage: " << sungrowModbusTcpConnection->phaseBVoltage() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Phase C voltage: " << sungrowModbusTcpConnection->phaseCVoltage() << " [V]" << "\n";
    debug.nospace().noquote() << "    - none: " << sungrowModbusTcpConnection->dummy1() << "\n";
    debug.nospace().noquote() << "    - Reactive power: " << sungrowModbusTcpConnection->reactivePower() << " [var]" << "\n";
    debug.nospace().noquote() << "    - Power factor: " << sungrowModbusTcpConnection->powerFactor() << "\n";
    debug.nospace().noquote() << "    - Grid frequency: " << sungrowModbusTcpConnection->gridFrequency() << " [Hz]" << "\n";
    debug.nospace().noquote() << "    - System state: " << sungrowModbusTcpConnection->systemState() << "\n";
    debug.nospace().noquote() << "    - Running state: " << sungrowModbusTcpConnection->runningState() << "\n";
    debug.nospace().noquote() << "    - Daily PV generation: " << sungrowModbusTcpConnection->dailyPVGeneration() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Total PV generation: " << sungrowModbusTcpConnection->totalPVGeneration() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Daily PV export: " << sungrowModbusTcpConnection->dailyPVExport() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Total PV export´: " << sungrowModbusTcpConnection->totalPVExport() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Load power: " << sungrowModbusTcpConnection->loadPower() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Export power: " << sungrowModbusTcpConnection->exportPower() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Daily battery charge from PV: " << sungrowModbusTcpConnection->dailyBatteryChargePV() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Total battery charge from PV: " << sungrowModbusTcpConnection->totalBatteryChargePV() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - none: " << sungrowModbusTcpConnection->dummy2() << "\n";
    debug.nospace().noquote() << "    - Battery voltage: " << sungrowModbusTcpConnection->batteryVoltage() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Battery current: " << sungrowModbusTcpConnection->batteryCurrent() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Battery power: " << sungrowModbusTcpConnection->batteryPower() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Battery level: " << sungrowModbusTcpConnection->batteryLevel() << " [%]" << "\n";
    debug.nospace().noquote() << "    - Battery health state: " << sungrowModbusTcpConnection->batteryHealthState() << " [%]" << "\n";
    debug.nospace().noquote() << "    - Battery temperature: " << sungrowModbusTcpConnection->batteryTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - none: " << sungrowModbusTcpConnection->dummy3() << "\n";
    debug.nospace().noquote() << "    - Grid state: " << sungrowModbusTcpConnection->gridState() << "\n";
    debug.nospace().noquote() << "    - Phase A current: " << sungrowModbusTcpConnection->phaseACurrent() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Phase B current: " << sungrowModbusTcpConnection->phaseBCurrent() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Phase C current: " << sungrowModbusTcpConnection->phaseCCurrent() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Total active power: " << sungrowModbusTcpConnection->totalActivePower() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Daily import energy: " << sungrowModbusTcpConnection->dailyImportEnergy() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Total import energy: " << sungrowModbusTcpConnection->totalImportEnergy() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Total battery capacity: " << sungrowModbusTcpConnection->totalBatteryCapacity() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - none: " << sungrowModbusTcpConnection->dummy4() << "\n";
    debug.nospace().noquote() << "    - Total export energy: " << sungrowModbusTcpConnection->totalExportEnergy() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Battery type: " << sungrowModbusTcpConnection->batteryType() << "\n";
    debug.nospace().noquote() << "    - Battery nominal voltage: " << sungrowModbusTcpConnection->batteryNominalVoltage() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Battery capacity: " << sungrowModbusTcpConnection->batteryCapacity() << " [Ah]" << "\n";
    debug.nospace().noquote() << "    - EMS mode (0/2/3/4): " << sungrowModbusTcpConnection->emsModeSelection() << "\n";
    debug.nospace().noquote() << "    - Force charge or discharge: " << sungrowModbusTcpConnection->chargeCommand() << "\n";
    debug.nospace().noquote() << "    - Set batter power: " << sungrowModbusTcpConnection->chargePower() << "\n";
    return debug.quote().space();
}
