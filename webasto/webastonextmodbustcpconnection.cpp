/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Copyright 2013 - 2025, nymea GmbH
* Contact: contact@nymea.io
*
* This fileDescriptor is part of nymea.
* This project including source code and documentation is protected by
* copyright law, and remains the property of nymea GmbH. All rights, including
* reproduction, publication, editing and translation, are reserved. The use of
* this project is subject to the terms of a license agreement to be concluded
* with nymea GmbH in accordance with the terms of use of nymea GmbH, available
* under https://nymea.io/license
*
* GNU Lesser General Public License Usage
* Alternatively, this project may be redistributed and/or modified under the
* terms of the GNU Lesser General Public License as published by the Free
* Software Foundation; version 3. This project is distributed in the hope that
* it will be useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this project. If not, see <https://www.gnu.org/licenses/>.
*
* For any further details and any questions please contact us under
* contact@nymea.io or see our FAQ/Licensing Information on
* https://nymea.io/license/faq
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WARNING
*
* This file has been autogenerated. Any changes in this file may be overwritten.
* If you want to change something, update the register json or the tool.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


#include "webastonextmodbustcpconnection.h"
#include <loggingcategories.h>
#include <math.h>
#include <QTimer>

NYMEA_LOGGING_CATEGORY(dcWebastoNextModbusTcpConnection, "WebastoNextModbusTcpConnection")

WebastoNextModbusTcpConnection::WebastoNextModbusTcpConnection(const QHostAddress &hostAddress, uint port, quint16 slaveId, QObject *parent) :
    ModbusTcpMaster(hostAddress, port, parent),
    m_slaveId(slaveId)
{
    connect(this, &ModbusTcpMaster::connectionStateChanged, this, [this](bool status){
        if (status) {
           qCDebug(dcWebastoNextModbusTcpConnection()) << "Modbus TCP connection" << m_hostAddress.toString() << "connected. Start testing if the connection is reachable...";
            // Cleanup before starting to initialize
            m_pendingInitReplies.clear();
            m_pendingUpdateReplies.clear();
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
            testReachability();
        } else {
            qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus TCP connection diconnected from" << m_hostAddress.toString() << ". The connection is not reachable any more.";
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
        }

        evaluateReachableState();
    });
}

bool WebastoNextModbusTcpConnection::reachable() const
{
    return m_reachable;
}

uint WebastoNextModbusTcpConnection::checkReachableRetries() const
{
    return m_checkReachableRetries;
}

void WebastoNextModbusTcpConnection::setCheckReachableRetries(uint checkReachableRetries)
{
    if (m_checkReachableRetries == checkReachableRetries)
        return;

    m_checkReachableRetries = checkReachableRetries;
    emit checkReachableRetriesChanged(m_checkReachableRetries);
}

ModbusDataUtils::ByteOrder WebastoNextModbusTcpConnection::endianness() const
{
    return m_endianness;
}

void WebastoNextModbusTcpConnection::setEndianness(ModbusDataUtils::ByteOrder endianness)
{
    if (m_endianness == endianness)
        return;

    m_endianness = endianness;
    emit endiannessChanged(m_endianness);
}

WebastoNextModbusTcpConnection::CableState WebastoNextModbusTcpConnection::cableState() const
{
    return m_cableState;
}

quint16 WebastoNextModbusTcpConnection::evseErrorCode() const
{
    return m_evseErrorCode;
}

quint16 WebastoNextModbusTcpConnection::currentL1() const
{
    return m_currentL1;
}

quint16 WebastoNextModbusTcpConnection::currentL2() const
{
    return m_currentL2;
}

quint16 WebastoNextModbusTcpConnection::currentL3() const
{
    return m_currentL3;
}

quint32 WebastoNextModbusTcpConnection::totalActivePower() const
{
    return m_totalActivePower;
}

quint32 WebastoNextModbusTcpConnection::activePowerL1() const
{
    return m_activePowerL1;
}

quint32 WebastoNextModbusTcpConnection::activePowerL2() const
{
    return m_activePowerL2;
}

quint32 WebastoNextModbusTcpConnection::activePowerL3() const
{
    return m_activePowerL3;
}

quint32 WebastoNextModbusTcpConnection::energyConsumed() const
{
    return m_energyConsumed;
}

quint16 WebastoNextModbusTcpConnection::maxChargingCurrent() const
{
    return m_maxChargingCurrent;
}

quint16 WebastoNextModbusTcpConnection::minChargingCurrent() const
{
    return m_minChargingCurrent;
}

quint16 WebastoNextModbusTcpConnection::maxChargingCurrentStation() const
{
    return m_maxChargingCurrentStation;
}

quint16 WebastoNextModbusTcpConnection::maxChargingCurrentCable() const
{
    return m_maxChargingCurrentCable;
}

quint16 WebastoNextModbusTcpConnection::maxChargingCurrentEv() const
{
    return m_maxChargingCurrentEv;
}

quint16 WebastoNextModbusTcpConnection::sessionEnergy() const
{
    return m_sessionEnergy;
}

quint16 WebastoNextModbusTcpConnection::safeCurrent() const
{
    return m_safeCurrent;
}

QModbusReply *WebastoNextModbusTcpConnection::setSafeCurrent(quint16 safeCurrent)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(safeCurrent);
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Write \"Max. charge current under communication failure\" register:" << 2000 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 2000, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 WebastoNextModbusTcpConnection::comTimeout() const
{
    return m_comTimeout;
}

QModbusReply *WebastoNextModbusTcpConnection::setComTimeout(quint16 comTimeout)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(comTimeout);
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Write \"Communication timeout\" register:" << 2002 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 2002, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint32 WebastoNextModbusTcpConnection::chargePower() const
{
    return m_chargePower;
}

QModbusReply *WebastoNextModbusTcpConnection::setChargePower(quint32 chargePower)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt32(chargePower, m_endianness);
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Write \"Set the charge power\" register:" << 5000 << "size:" << 2 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 5000, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 WebastoNextModbusTcpConnection::chargeCurrent() const
{
    return m_chargeCurrent;
}

QModbusReply *WebastoNextModbusTcpConnection::setChargeCurrent(quint16 chargeCurrent)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(chargeCurrent);
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Write \"Set the charge current\" register:" << 5004 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 5004, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

WebastoNextModbusTcpConnection::ChargingAction WebastoNextModbusTcpConnection::chargingAction() const
{
    return m_chargingAction;
}

QModbusReply *WebastoNextModbusTcpConnection::setChargingAction(ChargingAction chargingAction)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(static_cast<quint16>(chargingAction));
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Write \"Start / Cancel charging session\" register:" << 5006 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 5006, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 WebastoNextModbusTcpConnection::lifeBit() const
{
    return m_lifeBit;
}

QModbusReply *WebastoNextModbusTcpConnection::setLifeBit(quint16 lifeBit)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(lifeBit);
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Write \"Life bit\" register:" << 6000 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 6000, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

WebastoNextModbusTcpConnection::ChargerState WebastoNextModbusTcpConnection::chargerState() const
{
    return m_chargerState;
}

WebastoNextModbusTcpConnection::ChargeState WebastoNextModbusTcpConnection::chargeState() const
{
    return m_chargeState;
}

WebastoNextModbusTcpConnection::EvseState WebastoNextModbusTcpConnection::evseState() const
{
    return m_evseState;
}

bool WebastoNextModbusTcpConnection::initialize()
{
    if (!m_reachable) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Tried to initialize but the device is not to be reachable.";
        return false;
    }
    // No init registers defined. Nothing to be done and we are finished.
    emit initializationFinished(true);
    return true;
}

bool WebastoNextModbusTcpConnection::update()
{
    if (!connected())
        return false;

    if (!m_pendingUpdateReplies.isEmpty()) {
        qCDebug(dcWebastoNextModbusTcpConnection()) << "Tried to update but there are still some update replies pending. Waiting for them to be finished...";
        return true;
    }

    QModbusReply *reply = nullptr;

    // Read Cable state
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Cable state\" register:" << 1004 << "size:" << 1;
    reply = readCableState();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Cable state\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Cable state\" register" << 1004 << "size:" << 1 << unit.values();
        processCableStateRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"Cable state\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read ESVE Error codes, 0 = No error
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"ESVE Error codes, 0 = No error\" register:" << 1006 << "size:" << 1;
    reply = readEvseErrorCode();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"ESVE Error codes, 0 = No error\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"ESVE Error codes, 0 = No error\" register" << 1006 << "size:" << 1 << unit.values();
        processEvseErrorCodeRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"ESVE Error codes, 0 = No error\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read Charging current L1
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Charging current L1\" register:" << 1008 << "size:" << 1;
    reply = readCurrentL1();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Charging current L1\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Charging current L1\" register" << 1008 << "size:" << 1 << unit.values();
        processCurrentL1RegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"Charging current L1\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read Charging current L2
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Charging current L2\" register:" << 1010 << "size:" << 1;
    reply = readCurrentL2();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Charging current L2\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Charging current L2\" register" << 1010 << "size:" << 1 << unit.values();
        processCurrentL2RegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"Charging current L2\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read Charging current L3
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Charging current L3\" register:" << 1012 << "size:" << 1;
    reply = readCurrentL3();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Charging current L3\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Charging current L3\" register" << 1012 << "size:" << 1 << unit.values();
        processCurrentL3RegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"Charging current L3\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read Total active charging power
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Total active charging power\" register:" << 1020 << "size:" << 2;
    reply = readTotalActivePower();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Total active charging power\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Total active charging power\" register" << 1020 << "size:" << 2 << unit.values();
        processTotalActivePowerRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"Total active charging power\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read Active power L1
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Active power L1\" register:" << 1024 << "size:" << 2;
    reply = readActivePowerL1();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Active power L1\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Active power L1\" register" << 1024 << "size:" << 2 << unit.values();
        processActivePowerL1RegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"Active power L1\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read Active power L2
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Active power L2\" register:" << 1028 << "size:" << 2;
    reply = readActivePowerL2();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Active power L2\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Active power L2\" register" << 1028 << "size:" << 2 << unit.values();
        processActivePowerL2RegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"Active power L2\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read Active power L3
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Active power L3\" register:" << 1032 << "size:" << 2;
    reply = readActivePowerL3();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Active power L3\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Active power L3\" register" << 1032 << "size:" << 2 << unit.values();
        processActivePowerL3RegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"Active power L3\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read Energy meter reading of the charging station
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Energy meter reading of the charging station\" register:" << 1036 << "size:" << 2;
    reply = readEnergyConsumed();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Energy meter reading of the charging station\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Energy meter reading of the charging station\" register" << 1036 << "size:" << 2 << unit.values();
        processEnergyConsumedRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"Energy meter reading of the charging station\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read The maximal charging current of the hardware (EVSE, Cable, EV)
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"The maximal charging current of the hardware (EVSE, Cable, EV)\" register:" << 1100 << "size:" << 1;
    reply = readMaxChargingCurrent();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"The maximal charging current of the hardware (EVSE, Cable, EV)\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"The maximal charging current of the hardware (EVSE, Cable, EV)\" register" << 1100 << "size:" << 1 << unit.values();
        processMaxChargingCurrentRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"The maximal charging current of the hardware (EVSE, Cable, EV)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read The minimal charging current of the hardware (EVSE, Cable, EV)
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"The minimal charging current of the hardware (EVSE, Cable, EV)\" register:" << 1102 << "size:" << 1;
    reply = readMinChargingCurrent();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"The minimal charging current of the hardware (EVSE, Cable, EV)\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"The minimal charging current of the hardware (EVSE, Cable, EV)\" register" << 1102 << "size:" << 1 << unit.values();
        processMinChargingCurrentRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"The minimal charging current of the hardware (EVSE, Cable, EV)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read The maximal charging current of the station
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"The maximal charging current of the station\" register:" << 1104 << "size:" << 1;
    reply = readMaxChargingCurrentStation();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"The maximal charging current of the station\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"The maximal charging current of the station\" register" << 1104 << "size:" << 1 << unit.values();
        processMaxChargingCurrentStationRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"The maximal charging current of the station\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read The maximal charging current of the cable
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"The maximal charging current of the cable\" register:" << 1106 << "size:" << 1;
    reply = readMaxChargingCurrentCable();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"The maximal charging current of the cable\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"The maximal charging current of the cable\" register" << 1106 << "size:" << 1 << unit.values();
        processMaxChargingCurrentCableRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"The maximal charging current of the cable\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read The maximal charging current of the EV
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"The maximal charging current of the EV\" register:" << 1108 << "size:" << 1;
    reply = readMaxChargingCurrentEv();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"The maximal charging current of the EV\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"The maximal charging current of the EV\" register" << 1108 << "size:" << 1 << unit.values();
        processMaxChargingCurrentEvRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"The maximal charging current of the EV\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read Sum of charged energy for the last session
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Sum of charged energy for the last session\" register:" << 1502 << "size:" << 1;
    reply = readSessionEnergy();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Sum of charged energy for the last session\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Sum of charged energy for the last session\" register" << 1502 << "size:" << 1 << unit.values();
        processSessionEnergyRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"Sum of charged energy for the last session\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read Max. charge current under communication failure
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Max. charge current under communication failure\" register:" << 2000 << "size:" << 1;
    reply = readSafeCurrent();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Max. charge current under communication failure\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Max. charge current under communication failure\" register" << 2000 << "size:" << 1 << unit.values();
        processSafeCurrentRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"Max. charge current under communication failure\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read Communication timeout
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Communication timeout\" register:" << 2002 << "size:" << 1;
    reply = readComTimeout();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Communication timeout\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Communication timeout\" register" << 2002 << "size:" << 1 << unit.values();
        processComTimeoutRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"Communication timeout\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read Set the charge power
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Set the charge power\" register:" << 5000 << "size:" << 2;
    reply = readChargePower();
    if (!reply) {
        qCDebug(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Set the charge power\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Set the charge power\" register" << 5000 << "size:" << 2 << unit.values();
        processChargePowerRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCDebug(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"Set the charge power\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read Set the charge current
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Set the charge current\" register:" << 5004 << "size:" << 1;
    reply = readChargeCurrent();
    if (!reply) {
        qCDebug(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Set the charge current\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Set the charge current\" register" << 5004 << "size:" << 1 << unit.values();
        processChargeCurrentRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCDebug(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"Set the charge current\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read Start / Cancel charging session
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Start / Cancel charging session\" register:" << 5006 << "size:" << 1;
    reply = readChargingAction();
    if (!reply) {
        qCDebug(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Start / Cancel charging session\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Start / Cancel charging session\" register" << 5006 << "size:" << 1 << unit.values();
        processChargingActionRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCDebug(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"Start / Cancel charging session\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read Life bit
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Life bit\" register:" << 6000 << "size:" << 1;
    reply = readLifeBit();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Life bit\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Life bit\" register" << 6000 << "size:" << 1 << unit.values();
        processLifeBitRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while reading \"Life bit\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read states
    reply = readBlockStates();
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read block \"states\" registers from:" << 1000 << "size:" << 3;
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading block \"states\" registers";
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from reading block \"states\" register" << 1000 << "size:" << 3 << blockValues;
        processChargerStateRegisterValues(blockValues.mid(0, 1));
        processChargeStateRegisterValues(blockValues.mid(1, 1));
        processEvseStateRegisterValues(blockValues.mid(2, 1));
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating block \"states\" registers" << error << reply->errorString();
    });

    return true;
}

void WebastoNextModbusTcpConnection::updateCableState()
{
    // Update registers from Cable state
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Cable state\" register:" << 1004 << "size:" << 1;
    QModbusReply *reply = readCableState();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Cable state\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Cable state\" register" << 1004 << "size:" << 1 << unit.values();
            processCableStateRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"Cable state\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateEvseErrorCode()
{
    // Update registers from ESVE Error codes, 0 = No error
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"ESVE Error codes, 0 = No error\" register:" << 1006 << "size:" << 1;
    QModbusReply *reply = readEvseErrorCode();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"ESVE Error codes, 0 = No error\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"ESVE Error codes, 0 = No error\" register" << 1006 << "size:" << 1 << unit.values();
            processEvseErrorCodeRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"ESVE Error codes, 0 = No error\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateCurrentL1()
{
    // Update registers from Charging current L1
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Charging current L1\" register:" << 1008 << "size:" << 1;
    QModbusReply *reply = readCurrentL1();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Charging current L1\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Charging current L1\" register" << 1008 << "size:" << 1 << unit.values();
            processCurrentL1RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"Charging current L1\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateCurrentL2()
{
    // Update registers from Charging current L2
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Charging current L2\" register:" << 1010 << "size:" << 1;
    QModbusReply *reply = readCurrentL2();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Charging current L2\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Charging current L2\" register" << 1010 << "size:" << 1 << unit.values();
            processCurrentL2RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"Charging current L2\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateCurrentL3()
{
    // Update registers from Charging current L3
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Charging current L3\" register:" << 1012 << "size:" << 1;
    QModbusReply *reply = readCurrentL3();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Charging current L3\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Charging current L3\" register" << 1012 << "size:" << 1 << unit.values();
            processCurrentL3RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"Charging current L3\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateTotalActivePower()
{
    // Update registers from Total active charging power
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Total active charging power\" register:" << 1020 << "size:" << 2;
    QModbusReply *reply = readTotalActivePower();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Total active charging power\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Total active charging power\" register" << 1020 << "size:" << 2 << unit.values();
            processTotalActivePowerRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"Total active charging power\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateActivePowerL1()
{
    // Update registers from Active power L1
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Active power L1\" register:" << 1024 << "size:" << 2;
    QModbusReply *reply = readActivePowerL1();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Active power L1\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Active power L1\" register" << 1024 << "size:" << 2 << unit.values();
            processActivePowerL1RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"Active power L1\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateActivePowerL2()
{
    // Update registers from Active power L2
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Active power L2\" register:" << 1028 << "size:" << 2;
    QModbusReply *reply = readActivePowerL2();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Active power L2\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Active power L2\" register" << 1028 << "size:" << 2 << unit.values();
            processActivePowerL2RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"Active power L2\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateActivePowerL3()
{
    // Update registers from Active power L3
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Active power L3\" register:" << 1032 << "size:" << 2;
    QModbusReply *reply = readActivePowerL3();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Active power L3\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Active power L3\" register" << 1032 << "size:" << 2 << unit.values();
            processActivePowerL3RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"Active power L3\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateEnergyConsumed()
{
    // Update registers from Energy meter reading of the charging station
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Energy meter reading of the charging station\" register:" << 1036 << "size:" << 2;
    QModbusReply *reply = readEnergyConsumed();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Energy meter reading of the charging station\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Energy meter reading of the charging station\" register" << 1036 << "size:" << 2 << unit.values();
            processEnergyConsumedRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"Energy meter reading of the charging station\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateMaxChargingCurrent()
{
    // Update registers from The maximal charging current of the hardware (EVSE, Cable, EV)
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"The maximal charging current of the hardware (EVSE, Cable, EV)\" register:" << 1100 << "size:" << 1;
    QModbusReply *reply = readMaxChargingCurrent();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"The maximal charging current of the hardware (EVSE, Cable, EV)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"The maximal charging current of the hardware (EVSE, Cable, EV)\" register" << 1100 << "size:" << 1 << unit.values();
            processMaxChargingCurrentRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"The maximal charging current of the hardware (EVSE, Cable, EV)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateMinChargingCurrent()
{
    // Update registers from The minimal charging current of the hardware (EVSE, Cable, EV)
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"The minimal charging current of the hardware (EVSE, Cable, EV)\" register:" << 1102 << "size:" << 1;
    QModbusReply *reply = readMinChargingCurrent();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"The minimal charging current of the hardware (EVSE, Cable, EV)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"The minimal charging current of the hardware (EVSE, Cable, EV)\" register" << 1102 << "size:" << 1 << unit.values();
            processMinChargingCurrentRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"The minimal charging current of the hardware (EVSE, Cable, EV)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateMaxChargingCurrentStation()
{
    // Update registers from The maximal charging current of the station
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"The maximal charging current of the station\" register:" << 1104 << "size:" << 1;
    QModbusReply *reply = readMaxChargingCurrentStation();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"The maximal charging current of the station\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"The maximal charging current of the station\" register" << 1104 << "size:" << 1 << unit.values();
            processMaxChargingCurrentStationRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"The maximal charging current of the station\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateMaxChargingCurrentCable()
{
    // Update registers from The maximal charging current of the cable
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"The maximal charging current of the cable\" register:" << 1106 << "size:" << 1;
    QModbusReply *reply = readMaxChargingCurrentCable();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"The maximal charging current of the cable\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"The maximal charging current of the cable\" register" << 1106 << "size:" << 1 << unit.values();
            processMaxChargingCurrentCableRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"The maximal charging current of the cable\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateMaxChargingCurrentEv()
{
    // Update registers from The maximal charging current of the EV
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"The maximal charging current of the EV\" register:" << 1108 << "size:" << 1;
    QModbusReply *reply = readMaxChargingCurrentEv();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"The maximal charging current of the EV\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"The maximal charging current of the EV\" register" << 1108 << "size:" << 1 << unit.values();
            processMaxChargingCurrentEvRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"The maximal charging current of the EV\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateSessionEnergy()
{
    // Update registers from Sum of charged energy for the last session
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Sum of charged energy for the last session\" register:" << 1502 << "size:" << 1;
    QModbusReply *reply = readSessionEnergy();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Sum of charged energy for the last session\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Sum of charged energy for the last session\" register" << 1502 << "size:" << 1 << unit.values();
            processSessionEnergyRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"Sum of charged energy for the last session\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateSafeCurrent()
{
    // Update registers from Max. charge current under communication failure
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Max. charge current under communication failure\" register:" << 2000 << "size:" << 1;
    QModbusReply *reply = readSafeCurrent();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Max. charge current under communication failure\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Max. charge current under communication failure\" register" << 2000 << "size:" << 1 << unit.values();
            processSafeCurrentRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"Max. charge current under communication failure\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateComTimeout()
{
    // Update registers from Communication timeout
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Communication timeout\" register:" << 2002 << "size:" << 1;
    QModbusReply *reply = readComTimeout();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Communication timeout\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Communication timeout\" register" << 2002 << "size:" << 1 << unit.values();
            processComTimeoutRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"Communication timeout\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateChargePower()
{
    // Update registers from Set the charge power
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Set the charge power\" register:" << 5000 << "size:" << 2;
    QModbusReply *reply = readChargePower();
    if (!reply) {
        qCDebug(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Set the charge power\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Set the charge power\" register" << 5000 << "size:" << 2 << unit.values();
            processChargePowerRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"Set the charge power\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateChargeCurrent()
{
    // Update registers from Set the charge current
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Set the charge current\" register:" << 5004 << "size:" << 1;
    QModbusReply *reply = readChargeCurrent();
    if (!reply) {
        qCDebug(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Set the charge current\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Set the charge current\" register" << 5004 << "size:" << 1 << unit.values();
            processChargeCurrentRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCDebug(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"Set the charge current\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateChargingAction()
{
    // Update registers from Start / Cancel charging session
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Start / Cancel charging session\" register:" << 5006 << "size:" << 1;
    QModbusReply *reply = readChargingAction();
    if (!reply) {
        qCDebug(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Start / Cancel charging session\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Start / Cancel charging session\" register" << 5006 << "size:" << 1 << unit.values();
            processChargingActionRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCDebug(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"Start / Cancel charging session\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateLifeBit()
{
    // Update registers from Life bit
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Life bit\" register:" << 6000 << "size:" << 1;
    QModbusReply *reply = readLifeBit();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Life bit\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Life bit\" register" << 6000 << "size:" << 1 << unit.values();
            processLifeBitRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"Life bit\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateChargerState()
{
    // Update registers from State of the charging device
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"State of the charging device\" register:" << 1000 << "size:" << 1;
    QModbusReply *reply = readChargerState();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"State of the charging device\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"State of the charging device\" register" << 1000 << "size:" << 1 << unit.values();
            processChargerStateRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"State of the charging device\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateChargeState()
{
    // Update registers from Charge state
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"Charge state\" register:" << 1001 << "size:" << 1;
    QModbusReply *reply = readChargeState();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"Charge state\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"Charge state\" register" << 1001 << "size:" << 1 << unit.values();
            processChargeStateRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"Charge state\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateEvseState()
{
    // Update registers from EVSE state (state of charging station)
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read \"EVSE state (state of charging station)\" register:" << 1002 << "size:" << 1;
    QModbusReply *reply = readEvseState();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading \"EVSE state (state of charging station)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from \"EVSE state (state of charging station)\" register" << 1002 << "size:" << 1 << unit.values();
            processEvseStateRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating \"EVSE state (state of charging station)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void WebastoNextModbusTcpConnection::updateStatesBlock()
{
    // Update register block "states"
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Read block \"states\" registers from:" << 1000 << "size:" << 3;
    QModbusReply *reply = readBlockStates();
    if (!reply) {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Error occurred while reading block \"states\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcWebastoNextModbusTcpConnection()) << "<-- Response from reading block \"states\" register" << 1000 << "size:" << 3 << blockValues;
            processChargerStateRegisterValues(blockValues.mid(0, 1));
            processChargeStateRegisterValues(blockValues.mid(1, 1));
            processEvseStateRegisterValues(blockValues.mid(2, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while updating block \"states\" registers" << error << reply->errorString();
    });
}

QModbusReply *WebastoNextModbusTcpConnection::readCableState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1004, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readEvseErrorCode()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1006, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readCurrentL1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1008, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readCurrentL2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1010, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readCurrentL3()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1012, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readTotalActivePower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1020, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readActivePowerL1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1024, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readActivePowerL2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1028, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readActivePowerL3()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1032, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readEnergyConsumed()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1036, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readMaxChargingCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1100, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readMinChargingCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1102, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readMaxChargingCurrentStation()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1104, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readMaxChargingCurrentCable()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1106, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readMaxChargingCurrentEv()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1108, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readSessionEnergy()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1502, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readSafeCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 2000, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readComTimeout()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 2002, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readChargePower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 5000, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readChargeCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 5004, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readChargingAction()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 5006, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readLifeBit()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 6000, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readChargerState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1000, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readChargeState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1001, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readEvseState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1002, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *WebastoNextModbusTcpConnection::readBlockStates()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1000, 3);
    return sendReadRequest(request, m_slaveId);
}

void WebastoNextModbusTcpConnection::processCableStateRegisterValues(const QVector<quint16> values)
{
    CableState receivedCableState = static_cast<CableState>(ModbusDataUtils::convertToUInt16(values));
    emit cableStateReadFinished(receivedCableState);

    if (m_cableState != receivedCableState) {
        m_cableState = receivedCableState;
        emit cableStateChanged(m_cableState);
    }
}

void WebastoNextModbusTcpConnection::processEvseErrorCodeRegisterValues(const QVector<quint16> values)
{
    quint16 receivedEvseErrorCode = ModbusDataUtils::convertToUInt16(values);
    emit evseErrorCodeReadFinished(receivedEvseErrorCode);

    if (m_evseErrorCode != receivedEvseErrorCode) {
        m_evseErrorCode = receivedEvseErrorCode;
        emit evseErrorCodeChanged(m_evseErrorCode);
    }
}

void WebastoNextModbusTcpConnection::processCurrentL1RegisterValues(const QVector<quint16> values)
{
    quint16 receivedCurrentL1 = ModbusDataUtils::convertToUInt16(values);
    emit currentL1ReadFinished(receivedCurrentL1);

    if (m_currentL1 != receivedCurrentL1) {
        m_currentL1 = receivedCurrentL1;
        emit currentL1Changed(m_currentL1);
    }
}

void WebastoNextModbusTcpConnection::processCurrentL2RegisterValues(const QVector<quint16> values)
{
    quint16 receivedCurrentL2 = ModbusDataUtils::convertToUInt16(values);
    emit currentL2ReadFinished(receivedCurrentL2);

    if (m_currentL2 != receivedCurrentL2) {
        m_currentL2 = receivedCurrentL2;
        emit currentL2Changed(m_currentL2);
    }
}

void WebastoNextModbusTcpConnection::processCurrentL3RegisterValues(const QVector<quint16> values)
{
    quint16 receivedCurrentL3 = ModbusDataUtils::convertToUInt16(values);
    emit currentL3ReadFinished(receivedCurrentL3);

    if (m_currentL3 != receivedCurrentL3) {
        m_currentL3 = receivedCurrentL3;
        emit currentL3Changed(m_currentL3);
    }
}

void WebastoNextModbusTcpConnection::processTotalActivePowerRegisterValues(const QVector<quint16> values)
{
    quint32 receivedTotalActivePower = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit totalActivePowerReadFinished(receivedTotalActivePower);

    if (m_totalActivePower != receivedTotalActivePower) {
        m_totalActivePower = receivedTotalActivePower;
        emit totalActivePowerChanged(m_totalActivePower);
    }
}

void WebastoNextModbusTcpConnection::processActivePowerL1RegisterValues(const QVector<quint16> values)
{
    quint32 receivedActivePowerL1 = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit activePowerL1ReadFinished(receivedActivePowerL1);

    if (m_activePowerL1 != receivedActivePowerL1) {
        m_activePowerL1 = receivedActivePowerL1;
        emit activePowerL1Changed(m_activePowerL1);
    }
}

void WebastoNextModbusTcpConnection::processActivePowerL2RegisterValues(const QVector<quint16> values)
{
    quint32 receivedActivePowerL2 = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit activePowerL2ReadFinished(receivedActivePowerL2);

    if (m_activePowerL2 != receivedActivePowerL2) {
        m_activePowerL2 = receivedActivePowerL2;
        emit activePowerL2Changed(m_activePowerL2);
    }
}

void WebastoNextModbusTcpConnection::processActivePowerL3RegisterValues(const QVector<quint16> values)
{
    quint32 receivedActivePowerL3 = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit activePowerL3ReadFinished(receivedActivePowerL3);

    if (m_activePowerL3 != receivedActivePowerL3) {
        m_activePowerL3 = receivedActivePowerL3;
        emit activePowerL3Changed(m_activePowerL3);
    }
}

void WebastoNextModbusTcpConnection::processEnergyConsumedRegisterValues(const QVector<quint16> values)
{
    quint32 receivedEnergyConsumed = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit energyConsumedReadFinished(receivedEnergyConsumed);

    if (m_energyConsumed != receivedEnergyConsumed) {
        m_energyConsumed = receivedEnergyConsumed;
        emit energyConsumedChanged(m_energyConsumed);
    }
}

void WebastoNextModbusTcpConnection::processMaxChargingCurrentRegisterValues(const QVector<quint16> values)
{
    quint16 receivedMaxChargingCurrent = ModbusDataUtils::convertToUInt16(values);
    emit maxChargingCurrentReadFinished(receivedMaxChargingCurrent);

    if (m_maxChargingCurrent != receivedMaxChargingCurrent) {
        m_maxChargingCurrent = receivedMaxChargingCurrent;
        emit maxChargingCurrentChanged(m_maxChargingCurrent);
    }
}

void WebastoNextModbusTcpConnection::processMinChargingCurrentRegisterValues(const QVector<quint16> values)
{
    quint16 receivedMinChargingCurrent = ModbusDataUtils::convertToUInt16(values);
    emit minChargingCurrentReadFinished(receivedMinChargingCurrent);

    if (m_minChargingCurrent != receivedMinChargingCurrent) {
        m_minChargingCurrent = receivedMinChargingCurrent;
        emit minChargingCurrentChanged(m_minChargingCurrent);
    }
}

void WebastoNextModbusTcpConnection::processMaxChargingCurrentStationRegisterValues(const QVector<quint16> values)
{
    quint16 receivedMaxChargingCurrentStation = ModbusDataUtils::convertToUInt16(values);
    emit maxChargingCurrentStationReadFinished(receivedMaxChargingCurrentStation);

    if (m_maxChargingCurrentStation != receivedMaxChargingCurrentStation) {
        m_maxChargingCurrentStation = receivedMaxChargingCurrentStation;
        emit maxChargingCurrentStationChanged(m_maxChargingCurrentStation);
    }
}

void WebastoNextModbusTcpConnection::processMaxChargingCurrentCableRegisterValues(const QVector<quint16> values)
{
    quint16 receivedMaxChargingCurrentCable = ModbusDataUtils::convertToUInt16(values);
    emit maxChargingCurrentCableReadFinished(receivedMaxChargingCurrentCable);

    if (m_maxChargingCurrentCable != receivedMaxChargingCurrentCable) {
        m_maxChargingCurrentCable = receivedMaxChargingCurrentCable;
        emit maxChargingCurrentCableChanged(m_maxChargingCurrentCable);
    }
}

void WebastoNextModbusTcpConnection::processMaxChargingCurrentEvRegisterValues(const QVector<quint16> values)
{
    quint16 receivedMaxChargingCurrentEv = ModbusDataUtils::convertToUInt16(values);
    emit maxChargingCurrentEvReadFinished(receivedMaxChargingCurrentEv);

    if (m_maxChargingCurrentEv != receivedMaxChargingCurrentEv) {
        m_maxChargingCurrentEv = receivedMaxChargingCurrentEv;
        emit maxChargingCurrentEvChanged(m_maxChargingCurrentEv);
    }
}

void WebastoNextModbusTcpConnection::processSessionEnergyRegisterValues(const QVector<quint16> values)
{
    quint16 receivedSessionEnergy = ModbusDataUtils::convertToUInt16(values);
    emit sessionEnergyReadFinished(receivedSessionEnergy);

    if (m_sessionEnergy != receivedSessionEnergy) {
        m_sessionEnergy = receivedSessionEnergy;
        emit sessionEnergyChanged(m_sessionEnergy);
    }
}

void WebastoNextModbusTcpConnection::processSafeCurrentRegisterValues(const QVector<quint16> values)
{
    quint16 receivedSafeCurrent = ModbusDataUtils::convertToUInt16(values);
    emit safeCurrentReadFinished(receivedSafeCurrent);

    if (m_safeCurrent != receivedSafeCurrent) {
        m_safeCurrent = receivedSafeCurrent;
        emit safeCurrentChanged(m_safeCurrent);
    }
}

void WebastoNextModbusTcpConnection::processComTimeoutRegisterValues(const QVector<quint16> values)
{
    quint16 receivedComTimeout = ModbusDataUtils::convertToUInt16(values);
    emit comTimeoutReadFinished(receivedComTimeout);

    if (m_comTimeout != receivedComTimeout) {
        m_comTimeout = receivedComTimeout;
        emit comTimeoutChanged(m_comTimeout);
    }
}

void WebastoNextModbusTcpConnection::processChargePowerRegisterValues(const QVector<quint16> values)
{
    quint32 receivedChargePower = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit chargePowerReadFinished(receivedChargePower);

    if (m_chargePower != receivedChargePower) {
        m_chargePower = receivedChargePower;
        emit chargePowerChanged(m_chargePower);
    }
}

void WebastoNextModbusTcpConnection::processChargeCurrentRegisterValues(const QVector<quint16> values)
{
    quint16 receivedChargeCurrent = ModbusDataUtils::convertToUInt16(values);
    emit chargeCurrentReadFinished(receivedChargeCurrent);

    if (m_chargeCurrent != receivedChargeCurrent) {
        m_chargeCurrent = receivedChargeCurrent;
        emit chargeCurrentChanged(m_chargeCurrent);
    }
}

void WebastoNextModbusTcpConnection::processChargingActionRegisterValues(const QVector<quint16> values)
{
    ChargingAction receivedChargingAction = static_cast<ChargingAction>(ModbusDataUtils::convertToUInt16(values));
    emit chargingActionReadFinished(receivedChargingAction);

    if (m_chargingAction != receivedChargingAction) {
        m_chargingAction = receivedChargingAction;
        emit chargingActionChanged(m_chargingAction);
    }
}

void WebastoNextModbusTcpConnection::processLifeBitRegisterValues(const QVector<quint16> values)
{
    quint16 receivedLifeBit = ModbusDataUtils::convertToUInt16(values);
    emit lifeBitReadFinished(receivedLifeBit);

    if (m_lifeBit != receivedLifeBit) {
        m_lifeBit = receivedLifeBit;
        emit lifeBitChanged(m_lifeBit);
    }
}

void WebastoNextModbusTcpConnection::processChargerStateRegisterValues(const QVector<quint16> values)
{
    ChargerState receivedChargerState = static_cast<ChargerState>(ModbusDataUtils::convertToUInt16(values));
    emit chargerStateReadFinished(receivedChargerState);

    if (m_chargerState != receivedChargerState) {
        m_chargerState = receivedChargerState;
        emit chargerStateChanged(m_chargerState);
    }
}

void WebastoNextModbusTcpConnection::processChargeStateRegisterValues(const QVector<quint16> values)
{
    ChargeState receivedChargeState = static_cast<ChargeState>(ModbusDataUtils::convertToUInt16(values));
    emit chargeStateReadFinished(receivedChargeState);

    if (m_chargeState != receivedChargeState) {
        m_chargeState = receivedChargeState;
        emit chargeStateChanged(m_chargeState);
    }
}

void WebastoNextModbusTcpConnection::processEvseStateRegisterValues(const QVector<quint16> values)
{
    EvseState receivedEvseState = static_cast<EvseState>(ModbusDataUtils::convertToUInt16(values));
    emit evseStateReadFinished(receivedEvseState);

    if (m_evseState != receivedEvseState) {
        m_evseState = receivedEvseState;
        emit evseStateChanged(m_evseState);
    }
}

void WebastoNextModbusTcpConnection::handleModbusError(QModbusDevice::Error error)
{
    if (error == QModbusDevice::NoError) {
        // Reset the communication counter and we know we can reach the device
        m_communicationFailedCounter = 0;
        if (!m_communicationWorking)
            qCDebug(dcWebastoNextModbusTcpConnection()) << "Received a reply without any errors. The communication with the device seems to work now.";

        m_communicationWorking = true;
        evaluateReachableState();
    } else {
        m_communicationFailedCounter++;
        if (m_communicationWorking && m_communicationFailedCounter >= m_communicationFailedMax) {
            m_communicationWorking = false;
            qCWarning(dcWebastoNextModbusTcpConnection()) << "Received" << m_communicationFailedCounter << "errors while communicating with the RTU master. Mark as not reachable until the communication works again.";
            evaluateReachableState();
        }
    }
}

void WebastoNextModbusTcpConnection::testReachability()
{
    if (m_checkRechableReply)
        return;

    // Try to read the check reachability register maxChargingCurrent in order to verify if the communication is working or not.
    qCDebug(dcWebastoNextModbusTcpConnection()) << "--> Test reachability by reading \"The maximal charging current of the hardware (EVSE, Cable, EV)\" register:" << 1100 << "size:" << 1;
    m_checkRechableReply = readMaxChargingCurrent();
    if (!m_checkRechableReply) {
        qCDebug(dcWebastoNextModbusTcpConnection()) << "Error occurred verifying reachability by reading \"The maximal charging current of the hardware (EVSE, Cable, EV)\" register";
        onReachabilityCheckFailed();
        return;
    }

    if (m_checkRechableReply->isFinished()) {
        m_checkRechableReply->deleteLater(); // Broadcast reply returns immediatly
        m_checkRechableReply = nullptr;
        onReachabilityCheckFailed();
        return;
    }

    connect(m_checkRechableReply, &QModbusReply::finished, this, [this](){
        handleModbusError(m_checkRechableReply->error());
        if (m_checkRechableReply->error() != QModbusDevice::NoError)
            onReachabilityCheckFailed();

        m_checkRechableReply->deleteLater();
        m_checkRechableReply = nullptr;
    });

    connect(m_checkRechableReply, &QModbusReply::errorOccurred, this, [this] (QModbusDevice::Error error){
        qCDebug(dcWebastoNextModbusTcpConnection()) << "Modbus reply error occurred while verifying reachability by reading \"The maximal charging current of the hardware (EVSE, Cable, EV)\" register" << error << m_checkRechableReply->errorString();
    });
}

void WebastoNextModbusTcpConnection::verifyInitFinished()
{
    if (m_pendingInitReplies.isEmpty()) {
        finishInitialization(true);
    }
}

void WebastoNextModbusTcpConnection::finishInitialization(bool success)
{
    if (success) {
        qCDebug(dcWebastoNextModbusTcpConnection()) << "Initialization finished of WebastoNextModbusTcpConnection" << hostAddress().toString() << "finished successfully";
    } else {
        qCWarning(dcWebastoNextModbusTcpConnection()) << "Initialization finished of WebastoNextModbusTcpConnection" << hostAddress().toString() << "failed.";
    }

    // Cleanup init
    delete m_initObject;
    m_initObject = nullptr;
    m_pendingInitReplies.clear();

    emit initializationFinished(success);
}

void WebastoNextModbusTcpConnection::verifyUpdateFinished()
{
    if (m_pendingUpdateReplies.isEmpty()) {
        emit updateFinished();
    }
}

void WebastoNextModbusTcpConnection::onReachabilityCheckFailed()
{
    m_checkReachableRetriesCount++;

    if (m_checkReachableRetriesCount <= m_checkReachableRetries) {
        qCDebug(dcWebastoNextModbusTcpConnection()) << "Reachability test failed. Retry in on second" << m_checkReachableRetriesCount << "/" << m_checkReachableRetries;
        QTimer::singleShot(1000, this, &WebastoNextModbusTcpConnection::testReachability);
        return;
    }

    // The test reachability method failed, not retrying any more
    emit checkReachabilityFailed();
}

void WebastoNextModbusTcpConnection::evaluateReachableState()
{
    bool reachable = m_communicationWorking && connected();
    if (m_reachable == reachable)
        return;

    m_reachable = reachable;
    emit reachableChanged(m_reachable);
    m_checkReachableRetriesCount = 0;
}

QDebug operator<<(QDebug debug, WebastoNextModbusTcpConnection *webastoNextModbusTcpConnection)
{
    debug.nospace().noquote() << "WebastoNextModbusTcpConnection(" << webastoNextModbusTcpConnection->hostAddress().toString() << ":" << webastoNextModbusTcpConnection->port() << ")" << "\n";
    debug.nospace().noquote() << "    - Cable state: " << webastoNextModbusTcpConnection->cableState() << "\n";
    debug.nospace().noquote() << "    - ESVE Error codes, 0 = No error: " << webastoNextModbusTcpConnection->evseErrorCode() << "\n";
    debug.nospace().noquote() << "    - Charging current L1: " << webastoNextModbusTcpConnection->currentL1() << " [mA]" << "\n";
    debug.nospace().noquote() << "    - Charging current L2: " << webastoNextModbusTcpConnection->currentL2() << " [mA]" << "\n";
    debug.nospace().noquote() << "    - Charging current L3: " << webastoNextModbusTcpConnection->currentL3() << " [mA]" << "\n";
    debug.nospace().noquote() << "    - Total active charging power: " << webastoNextModbusTcpConnection->totalActivePower() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Active power L1: " << webastoNextModbusTcpConnection->activePowerL1() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Active power L2: " << webastoNextModbusTcpConnection->activePowerL2() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Active power L3: " << webastoNextModbusTcpConnection->activePowerL3() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Energy meter reading of the charging station: " << webastoNextModbusTcpConnection->energyConsumed() << " [Wh]" << "\n";
    debug.nospace().noquote() << "    - The maximal charging current of the hardware (EVSE, Cable, EV): " << webastoNextModbusTcpConnection->maxChargingCurrent() << " [A]" << "\n";
    debug.nospace().noquote() << "    - The minimal charging current of the hardware (EVSE, Cable, EV): " << webastoNextModbusTcpConnection->minChargingCurrent() << " [A]" << "\n";
    debug.nospace().noquote() << "    - The maximal charging current of the station: " << webastoNextModbusTcpConnection->maxChargingCurrentStation() << " [A]" << "\n";
    debug.nospace().noquote() << "    - The maximal charging current of the cable: " << webastoNextModbusTcpConnection->maxChargingCurrentCable() << " [A]" << "\n";
    debug.nospace().noquote() << "    - The maximal charging current of the EV: " << webastoNextModbusTcpConnection->maxChargingCurrentEv() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Sum of charged energy for the last session: " << webastoNextModbusTcpConnection->sessionEnergy() << " [Wh]" << "\n";
    debug.nospace().noquote() << "    - Max. charge current under communication failure: " << webastoNextModbusTcpConnection->safeCurrent() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Communication timeout: " << webastoNextModbusTcpConnection->comTimeout() << " [s]" << "\n";
    debug.nospace().noquote() << "    - Set the charge power: " << webastoNextModbusTcpConnection->chargePower() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Set the charge current: " << webastoNextModbusTcpConnection->chargeCurrent() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Start / Cancel charging session: " << webastoNextModbusTcpConnection->chargingAction() << "\n";
    debug.nospace().noquote() << "    - Life bit: " << webastoNextModbusTcpConnection->lifeBit() << "\n";
    debug.nospace().noquote() << "    - State of the charging device: " << webastoNextModbusTcpConnection->chargerState() << "\n";
    debug.nospace().noquote() << "    - Charge state: " << webastoNextModbusTcpConnection->chargeState() << "\n";
    debug.nospace().noquote() << "    - EVSE state (state of charging station): " << webastoNextModbusTcpConnection->evseState() << "\n";
    return debug.quote().space();
}

