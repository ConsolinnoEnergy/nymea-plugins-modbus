/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Copyright 2013 - 2024, nymea GmbH
* Contact: contact@nymea.io
*
* This fileDescriptor is part of nymea.
* This project including source code and documentation is protected by
* copyright law, and remains the property of nymea GmbH. All rights, including
* reproduction, publication, editing and translation, are reserved. The use of
* this project is subject to the terms of a license agreement to be concluded
* with nymea GmbH in accordance with the terms of use of nymea GmbH, available
* under https://nymea.io/license
*
* GNU Lesser General Public License Usage
* Alternatively, this project may be redistributed and/or modified under the
* terms of the GNU Lesser General Public License as published by the Free
* Software Foundation; version 3. This project is distributed in the hope that
* it will be useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this project. If not, see <https://www.gnu.org/licenses/>.
*
* For any further details and any questions please contact us under
* contact@nymea.io or see our FAQ/Licensing Information on
* https://nymea.io/license/faq
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WARNING
*
* This file has been autogenerated. Any changes in this file may be overwritten.
* If you want to change something, update the register json or the tool.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


#include "lambdamodbustcpconnection.h"
#include <loggingcategories.h>
#include <math.h>
#include <QTimer>

NYMEA_LOGGING_CATEGORY(dcLambdaModbusTcpConnection, "LambdaModbusTcpConnection")

LambdaModbusTcpConnection::LambdaModbusTcpConnection(const QHostAddress &hostAddress, uint port, quint16 slaveId, QObject *parent) :
    ModbusTCPMaster(hostAddress, port, parent),
    m_slaveId(slaveId)
{
    connect(this, &ModbusTCPMaster::connectionStateChanged, this, [this](bool status){
        if (status) {
           qCDebug(dcLambdaModbusTcpConnection()) << "Modbus TCP connection" << m_hostAddress.toString() << "connected. Start testing if the connection is reachable...";
            // Cleanup before starting to initialize
            m_pendingInitReplies.clear();
            m_pendingUpdateReplies.clear();
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
            testReachability();
        } else {
            qCWarning(dcLambdaModbusTcpConnection()) << "Modbus TCP connection diconnected from" << m_hostAddress.toString() << ". The connection is not reachable any more.";
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
        }

        evaluateReachableState();
    });
}

bool LambdaModbusTcpConnection::reachable() const
{
    return m_reachable;
}

uint LambdaModbusTcpConnection::checkReachableRetries() const
{
    return m_checkReachableRetries;
}

void LambdaModbusTcpConnection::setCheckReachableRetries(uint checkReachableRetries)
{
    if (m_checkReachableRetries == checkReachableRetries)
        return;

    m_checkReachableRetries = checkReachableRetries;
    emit checkReachableRetriesChanged(m_checkReachableRetries);
}

ModbusDataUtils::ByteOrder LambdaModbusTcpConnection::endianness() const
{
    return m_endianness;
}

void LambdaModbusTcpConnection::setEndianness(ModbusDataUtils::ByteOrder endianness)
{
    if (m_endianness == endianness)
        return;

    m_endianness = endianness;
    emit endiannessChanged(m_endianness);
}

qint16 LambdaModbusTcpConnection::actualPvSurplus() const
{
    return m_actualPvSurplus;
}

QModbusReply *LambdaModbusTcpConnection::setActualPvSurplus(qint16 actualPvSurplus)
{
    QVector<quint16> values = ModbusDataUtils::convertFromInt16(actualPvSurplus);
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Write \"actual PV surplus power\" register:" << 102 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 102, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

void LambdaModbusTcpConnection::setDemandPower(float value)
{
   qint16 demandProvided = static_cast<qint16>(value);
    if (m_demandPower != demandProvided) {
        m_demandPower = demandProvided;
    }
}

float LambdaModbusTcpConnection::totalEnergyConsumed() const
{
    return m_totalEnergyConsumed;
}

float LambdaModbusTcpConnection::compressorTotalHeatOutput() const
{
    return m_compressorTotalHeatOutput;
}

float LambdaModbusTcpConnection::hotWaterTemperature() const
{
    return m_hotWaterTemperature;
}

qint16 LambdaModbusTcpConnection::ambientErrorNumber() const
{
    return m_ambientErrorNumber;
}

LambdaModbusTcpConnection::AmbientState LambdaModbusTcpConnection::ambientState() const
{
    return m_ambientState;
}

float LambdaModbusTcpConnection::actualAmbientTemperature() const
{
    return m_actualAmbientTemperature;
}

float LambdaModbusTcpConnection::averageAmbientTemperature() const
{
    return m_averageAmbientTemperature;
}

float LambdaModbusTcpConnection::outdoorTemperature() const
{
    return m_outdoorTemperature;
}

qint16 LambdaModbusTcpConnection::emanagerErrorNumber() const
{
    return m_emanagerErrorNumber;
}

LambdaModbusTcpConnection::EmanagerState LambdaModbusTcpConnection::emanagerState() const
{
    return m_emanagerState;
}

qint16 LambdaModbusTcpConnection::currentPower() const
{
    return m_currentPower;
}

qint16 LambdaModbusTcpConnection::powerSetpoint() const
{
    return m_powerSetpoint;
}

LambdaModbusTcpConnection::HeatpumpErrorState LambdaModbusTcpConnection::heatpumpErrorState() const
{
    return m_heatpumpErrorState;
}

qint16 LambdaModbusTcpConnection::heatpumpErrorNumber() const
{
    return m_heatpumpErrorNumber;
}

LambdaModbusTcpConnection::SystemStatus LambdaModbusTcpConnection::systemStatus() const
{
    return m_systemStatus;
}

LambdaModbusTcpConnection::HeatpumpState LambdaModbusTcpConnection::heatpumpState() const
{
    return m_heatpumpState;
}

float LambdaModbusTcpConnection::heatpumpFlowTemperature() const
{
    return m_heatpumpFlowTemperature;
}

float LambdaModbusTcpConnection::heatpumpReturnTemperature() const
{
    return m_heatpumpReturnTemperature;
}

float LambdaModbusTcpConnection::volumeFlowSink() const
{
    return m_volumeFlowSink;
}

float LambdaModbusTcpConnection::energySourceInletTemperature() const
{
    return m_energySourceInletTemperature;
}

float LambdaModbusTcpConnection::energySourceOutletTemperature() const
{
    return m_energySourceOutletTemperature;
}

float LambdaModbusTcpConnection::volumeFlowSource() const
{
    return m_volumeFlowSource;
}

float LambdaModbusTcpConnection::compressorRating() const
{
    return m_compressorRating;
}

float LambdaModbusTcpConnection::actualHeatingCapacity() const
{
    return m_actualHeatingCapacity;
}

qint16 LambdaModbusTcpConnection::powerActualInverter() const
{
    return m_powerActualInverter;
}

float LambdaModbusTcpConnection::coefficientOfPerformance() const
{
    return m_coefficientOfPerformance;
}

qint16 LambdaModbusTcpConnection::bufferErrorNumber() const
{
    return m_bufferErrorNumber;
}

LambdaModbusTcpConnection::BufferState LambdaModbusTcpConnection::bufferState() const
{
    return m_bufferState;
}

float LambdaModbusTcpConnection::bufferTemperatureHigh() const
{
    return m_bufferTemperatureHigh;
}

float LambdaModbusTcpConnection::bufferTemperatureLow() const
{
    return m_bufferTemperatureLow;
}

float LambdaModbusTcpConnection::heatingcircuitErrorNumber() const
{
    return m_heatingcircuitErrorNumber;
}

LambdaModbusTcpConnection::HeatingcircuitState LambdaModbusTcpConnection::heatingcircuitState() const
{
    return m_heatingcircuitState;
}

float LambdaModbusTcpConnection::flowTemperature() const
{
    return m_flowTemperature;
}

float LambdaModbusTcpConnection::returnTemperature() const
{
    return m_returnTemperature;
}

float LambdaModbusTcpConnection::roomTemperature() const
{
    return m_roomTemperature;
}

float LambdaModbusTcpConnection::setpointFlowTemperature() const
{
    return m_setpointFlowTemperature;
}

LambdaModbusTcpConnection::HeatingcircuitMode LambdaModbusTcpConnection::heatingcircuitMode() const
{
    return m_heatingcircuitMode;
}

bool LambdaModbusTcpConnection::initialize()
{
    if (!m_reachable) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Tried to initialize but the device is not to be reachable.";
        return false;
    }
    // No init registers defined. Nothing to be done and we are finished.
    emit initializationFinished(true);
    return true;
}

bool LambdaModbusTcpConnection::update()
{
    if (!connected())
        return false;

    if (!m_pendingUpdateReplies.isEmpty()) {
        qCDebug(dcLambdaModbusTcpConnection()) << "Tried to update but there are still some update replies pending. Waiting for them to be finished...";
        return true;
    }

    QModbusReply *reply = nullptr;

    // Read actual PV surplus power
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"actual PV surplus power\" register:" << 102 << "size:" << 1;
    reply = readActualPvSurplus();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"actual PV surplus power\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"actual PV surplus power\" register" << 102 << "size:" << 1 << unit.values();
        processActualPvSurplusRegisterValues(unit.values());
        update2();//JoOb-previous: verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while reading \"actual PV surplus power\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
    return true;
}

// Split up update, so that modbus calls are sent one after the other.
void LambdaModbusTcpConnection::update2()
{
    QModbusReply *reply = nullptr;
    // Read Accumulated electrical energy consumption of compressor unit since last statistic reset
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Accumulated electrical energy consumption of compressor unit since last statistic reset\" register:" << 1020 << "size:" << 2;
    reply = readTotalEnergyConsumed();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Accumulated electrical energy consumption of compressor unit since last statistic reset\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Accumulated electrical energy consumption of compressor unit since last statistic reset\" register" << 1020 << "size:" << 2 << unit.values();
        processTotalEnergyConsumedRegisterValues(unit.values());
        update3();//JoOb-previous: verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while reading \"Accumulated electrical energy consumption of compressor unit since last statistic reset\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::update3()
{
    QModbusReply *reply = nullptr;
    // Read Accumulated thermal energy output of compressor unit since last statistic reset
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Accumulated thermal energy output of compressor unit since last statistic reset\" register:" << 1022 << "size:" << 2;
    reply = readCompressorTotalHeatOutput();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Accumulated thermal energy output of compressor unit since last statistic reset\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Accumulated thermal energy output of compressor unit since last statistic reset\" register" << 1022 << "size:" << 2 << unit.values();
        processCompressorTotalHeatOutputRegisterValues(unit.values());
        update4();//JoOb-previous: verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while reading \"Accumulated thermal energy output of compressor unit since last statistic reset\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::update4()
{
    QModbusReply *reply = nullptr;
    // Read Actual temperature boiler high sensor
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Actual temperature boiler high sensor\" register:" << 2002 << "size:" << 1;
    reply = readHotWaterTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Actual temperature boiler high sensor\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Actual temperature boiler high sensor\" register" << 2002 << "size:" << 1 << unit.values();
        processHotWaterTemperatureRegisterValues(unit.values());
        update5();//JoOb-previous: verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while reading \"Actual temperature boiler high sensor\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::update5()
{
    QModbusReply *reply = nullptr;
    // Read ambient
    reply = readBlockAmbient();
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"ambient\" registers from:" << 0 << "size:" << 5;
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"ambient\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"ambient\" register" << 0 << "size:" << 5 << blockValues;
        processAmbientErrorNumberRegisterValues(blockValues.mid(0, 1));
        processAmbientStateRegisterValues(blockValues.mid(1, 1));
        processActualAmbientTemperatureRegisterValues(blockValues.mid(2, 1));
        processAverageAmbientTemperatureRegisterValues(blockValues.mid(3, 1));
        processOutdoorTemperatureRegisterValues(blockValues.mid(4, 1));
        update6();//JoOb-previous: verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"ambient\" registers" << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::update6()
{
    QModbusReply *reply = nullptr;

    // Read emanager
    reply = readBlockEmanager();
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"emanager\" registers from:" << 100 << "size:" << 2;
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"emanager\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"emanager\" register" << 100 << "size:" << 2 << blockValues;
        processEmanagerErrorNumberRegisterValues(blockValues.mid(0, 1));
        processEmanagerStateRegisterValues(blockValues.mid(1, 1));
        update7();//JoOb-previous: verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"emanager\" registers" << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::update7()
{
    QModbusReply *reply = nullptr;

    // Read power
    reply = readBlockPower();
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"power\" registers from:" << 103 << "size:" << 2;
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"power\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"power\" register" << 103 << "size:" << 2 << blockValues;
        processCurrentPowerRegisterValues(blockValues.mid(0, 1));
        processPowerSetpointRegisterValues(blockValues.mid(1, 1));
        update8();//JoOb-previous: verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"power\" registers" << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::update8()
{
    QModbusReply *reply = nullptr;

    // Read heatpump
    reply = readBlockHeatpump();
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"heatpump\" registers from:" << 1000 << "size:" << 20;
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"heatpump\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"heatpump\" register" << 1000 << "size:" << 14 << blockValues;
        processHeatpumpErrorStateRegisterValues(blockValues.mid(0, 1));
        processHeatpumpErrorNumberRegisterValues(blockValues.mid(1, 1));
        processSystemStatusRegisterValues(blockValues.mid(2, 1));
        processHeatpumpStateRegisterValues(blockValues.mid(3, 1));
        processHeatpumpFlowTemperatureRegisterValues(blockValues.mid(4, 1));
        processHeatpumpReturnTemperatureRegisterValues(blockValues.mid(5, 1));
        processVolumeFlowSinkRegisterValues(blockValues.mid(6, 1));
        processEnergySourceInletTemperatureRegisterValues(blockValues.mid(7, 1));
        processEnergySourceOutletTemperatureRegisterValues(blockValues.mid(8, 1));
        processVolumeFlowSourceRegisterValues(blockValues.mid(9, 1));
        processCompressorRatingRegisterValues(blockValues.mid(10, 1));
        processActualHeatingCapacityRegisterValues(blockValues.mid(11, 1));
        processPowerActualInverterRegisterValues(blockValues.mid(12, 1));
        processCoefficientOfPerformanceRegisterValues(blockValues.mid(13, 1));
        update9();//JoOb-previous: verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"heatpump\" registers" << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::update9()
{
    QModbusReply *reply = nullptr;

    // Read buffer
    reply = readBlockBuffer();
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"buffer\" registers from:" << 3000 << "size:" << 4;
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"buffer\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"buffer\" register" << 3000 << "size:" << 4 << blockValues;
        processBufferErrorNumberRegisterValues(blockValues.mid(0, 1));
        processBufferStateRegisterValues(blockValues.mid(1, 1));
        processBufferTemperatureHighRegisterValues(blockValues.mid(2, 1));
        processBufferTemperatureLowRegisterValues(blockValues.mid(3, 1));
        update10();//JoOb-previous: verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"buffer\" registers" << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::update10()
{
    QModbusReply *reply = nullptr;

    // Read heatcirc
    reply = readBlockHeatcirc();
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"heatcirc\" registers from:" << 5000 << "size:" << 7;
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"heatcirc\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"heatcirc\" register" << 5000 << "size:" << 7 << blockValues;
        processHeatingcircuitErrorNumberRegisterValues(blockValues.mid(0, 1));
        processHeatingcircuitStateRegisterValues(blockValues.mid(1, 1));
        processFlowTemperatureRegisterValues(blockValues.mid(2, 1));
        processReturnTemperatureRegisterValues(blockValues.mid(3, 1));
        processRoomTemperatureRegisterValues(blockValues.mid(4, 1));
        processSetpointFlowTemperatureRegisterValues(blockValues.mid(5, 1));
        processHeatingcircuitModeRegisterValues(blockValues.mid(6, 1));
        
	// JoOb: manual write to address 102
        updateWrite();

        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"heatcirc\" registers" << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateWrite()
{
    QModbusReply *reply = nullptr;
    //quint16 pwrDmnd = 0;

    // JoOb: Write powerDemand not working (FC6 not supported )
    //reply = setPowerDemand(pwrDmnd);    
    
    
    // JoOb: sendRawRequest is working successfull    
    quint16 startAddress = 102, numberOfRegisters = 1; // hard coded register to be changed
    quint8 payloadInBytes = 2;
    
    quint8 outputHigh = (m_demandPower>>8) & 0xFF;
    quint8 outputLow = m_demandPower & 0xFF;
    qCDebug(dcLambdaModbusTcpConnection()) << "demand power value: " << m_demandPower << "; highByte: " << outputHigh << "; lowByte: " << outputLow;

    QModbusRequest request(QModbusRequest::WriteMultipleRegisters, startAddress, numberOfRegisters,
    payloadInBytes, outputHigh, outputLow);

    //QModbusRequest request(QModbusRequest::WriteMultipleRegisters, QByteArray::fromHex("00660001020001")); // joOb
    reply = m_modbusTcpClient->sendRawRequest(request, m_slaveId);

    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) 
            << "Write powerDemand failed because the reply could not be created.";
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        if (reply->error() != QModbusDevice::NoError) {
            qCWarning(dcLambdaModbusTcpConnection())
                    << "Write powerDemand finished with error" << reply->errorString();
            return;
        }

        qCDebug(dcLambdaModbusTcpConnection()) << "Write powerDemand finished successfully";
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
            if (reply->error() == QModbusDevice::ProtocolError) {
                QModbusResponse response = reply->rawResult();
                if (response.isException()) {
                    qCDebug(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while writing powerDemand" << hostAddress().toString() << exceptionToString(response.exceptionCode());
                }
            } else {
                qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while writing powerDemand" << hostAddress().toString() << error << reply->errorString();
            }
        });   
}

void LambdaModbusTcpConnection::updateActualPvSurplus()
{
    // Update registers from actual PV surplus power
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"actual PV surplus power\" register:" << 102 << "size:" << 1;
    QModbusReply *reply = readActualPvSurplus();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"actual PV surplus power\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"actual PV surplus power\" register" << 102 << "size:" << 1 << unit.values();
            processActualPvSurplusRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"actual PV surplus power\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateTotalEnergyConsumed()
{
    // Update registers from Accumulated electrical energy consumption of compressor unit since last statistic reset
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Accumulated electrical energy consumption of compressor unit since last statistic reset\" register:" << 1020 << "size:" << 2;
    QModbusReply *reply = readTotalEnergyConsumed();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Accumulated electrical energy consumption of compressor unit since last statistic reset\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Accumulated electrical energy consumption of compressor unit since last statistic reset\" register" << 1020 << "size:" << 2 << unit.values();
            processTotalEnergyConsumedRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Accumulated electrical energy consumption of compressor unit since last statistic reset\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateCompressorTotalHeatOutput()
{
    // Update registers from Accumulated thermal energy output of compressor unit since last statistic reset
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Accumulated thermal energy output of compressor unit since last statistic reset\" register:" << 1022 << "size:" << 2;
    QModbusReply *reply = readCompressorTotalHeatOutput();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Accumulated thermal energy output of compressor unit since last statistic reset\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Accumulated thermal energy output of compressor unit since last statistic reset\" register" << 1022 << "size:" << 2 << unit.values();
            processCompressorTotalHeatOutputRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Accumulated thermal energy output of compressor unit since last statistic reset\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateHotWaterTemperature()
{
    // Update registers from Actual temperature boiler high sensor
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Actual temperature boiler high sensor\" register:" << 2002 << "size:" << 1;
    QModbusReply *reply = readHotWaterTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Actual temperature boiler high sensor\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Actual temperature boiler high sensor\" register" << 2002 << "size:" << 1 << unit.values();
            processHotWaterTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Actual temperature boiler high sensor\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateAmbientErrorNumber()
{
    // Update registers from ambient error number
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"ambient error number\" register:" << 0 << "size:" << 1;
    QModbusReply *reply = readAmbientErrorNumber();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"ambient error number\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"ambient error number\" register" << 0 << "size:" << 1 << unit.values();
            processAmbientErrorNumberRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"ambient error number\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateAmbientState()
{
    // Update registers from operating state for ambient module
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"operating state for ambient module\" register:" << 1 << "size:" << 1;
    QModbusReply *reply = readAmbientState();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"operating state for ambient module\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"operating state for ambient module\" register" << 1 << "size:" << 1 << unit.values();
            processAmbientStateRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"operating state for ambient module\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateActualAmbientTemperature()
{
    // Update registers from actual ambient temperature
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"actual ambient temperature\" register:" << 2 << "size:" << 1;
    QModbusReply *reply = readActualAmbientTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"actual ambient temperature\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"actual ambient temperature\" register" << 2 << "size:" << 1 << unit.values();
            processActualAmbientTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"actual ambient temperature\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateAverageAmbientTemperature()
{
    // Update registers from Arithmetic average temperature of the last 60 minutes
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Arithmetic average temperature of the last 60 minutes\" register:" << 3 << "size:" << 1;
    QModbusReply *reply = readAverageAmbientTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Arithmetic average temperature of the last 60 minutes\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Arithmetic average temperature of the last 60 minutes\" register" << 3 << "size:" << 1 << unit.values();
            processAverageAmbientTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Arithmetic average temperature of the last 60 minutes\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateOutdoorTemperature()
{
    // Update registers from calculated ambient temperature
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"calculated ambient temperature\" register:" << 4 << "size:" << 1;
    QModbusReply *reply = readOutdoorTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"calculated ambient temperature\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"calculated ambient temperature\" register" << 4 << "size:" << 1 << unit.values();
            processOutdoorTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"calculated ambient temperature\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateEmanagerErrorNumber()
{
    // Update registers from E-Manager error number, 0: no error
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"E-Manager error number, 0: no error\" register:" << 100 << "size:" << 1;
    QModbusReply *reply = readEmanagerErrorNumber();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"E-Manager error number, 0: no error\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"E-Manager error number, 0: no error\" register" << 100 << "size:" << 1 << unit.values();
            processEmanagerErrorNumberRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"E-Manager error number, 0: no error\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateEmanagerState()
{
    // Update registers from operating state for E-Manager module
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"operating state for E-Manager module\" register:" << 101 << "size:" << 1;
    QModbusReply *reply = readEmanagerState();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"operating state for E-Manager module\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"operating state for E-Manager module\" register" << 101 << "size:" << 1 << unit.values();
            processEmanagerStateRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"operating state for E-Manager module\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateCurrentPower()
{
    // Update registers from actual power consumption of all configured heat pumps
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"actual power consumption of all configured heat pumps\" register:" << 103 << "size:" << 1;
    QModbusReply *reply = readCurrentPower();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"actual power consumption of all configured heat pumps\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"actual power consumption of all configured heat pumps\" register" << 103 << "size:" << 1 << unit.values();
            processCurrentPowerRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"actual power consumption of all configured heat pumps\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updatePowerSetpoint()
{
    // Update registers from realized power consumption setpoint of all configured heat pumps
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"realized power consumption setpoint of all configured heat pumps\" register:" << 104 << "size:" << 1;
    QModbusReply *reply = readPowerSetpoint();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"realized power consumption setpoint of all configured heat pumps\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"realized power consumption setpoint of all configured heat pumps\" register" << 104 << "size:" << 1 << unit.values();
            processPowerSetpointRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"realized power consumption setpoint of all configured heat pumps\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateHeatpumpErrorState()
{
    // Update registers from error state for heat pump module
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"error state for heat pump module\" register:" << 1000 << "size:" << 1;
    QModbusReply *reply = readHeatpumpErrorState();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"error state for heat pump module\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"error state for heat pump module\" register" << 1000 << "size:" << 1 << unit.values();
            processHeatpumpErrorStateRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"error state for heat pump module\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateHeatpumpErrorNumber()
{
    // Update registers from active heat pump error numbers
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"active heat pump error numbers\" register:" << 1001 << "size:" << 1;
    QModbusReply *reply = readHeatpumpErrorNumber();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"active heat pump error numbers\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"active heat pump error numbers\" register" << 1001 << "size:" << 1 << unit.values();
            processHeatpumpErrorNumberRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"active heat pump error numbers\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateSystemStatus()
{
    // Update registers from System status of the heat pump
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"System status of the heat pump\" register:" << 1002 << "size:" << 1;
    QModbusReply *reply = readSystemStatus();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"System status of the heat pump\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"System status of the heat pump\" register" << 1002 << "size:" << 1 << unit.values();
            processSystemStatusRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"System status of the heat pump\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateHeatpumpState()
{
    // Update registers from Operating state of the heat pump
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Operating state of the heat pump\" register:" << 1003 << "size:" << 1;
    QModbusReply *reply = readHeatpumpState();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Operating state of the heat pump\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Operating state of the heat pump\" register" << 1003 << "size:" << 1 << unit.values();
            processHeatpumpStateRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Operating state of the heat pump\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateHeatpumpFlowTemperature()
{
    // Update registers from Flow line temperature of the heat pump
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Flow line temperature of the heat pump\" register:" << 1004 << "size:" << 1;
    QModbusReply *reply = readHeatpumpFlowTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Flow line temperature of the heat pump\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Flow line temperature of the heat pump\" register" << 1004 << "size:" << 1 << unit.values();
            processHeatpumpFlowTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Flow line temperature of the heat pump\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateHeatpumpReturnTemperature()
{
    // Update registers from Return line temperature of the heat pump
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Return line temperature of the heat pump\" register:" << 1005 << "size:" << 1;
    QModbusReply *reply = readHeatpumpReturnTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Return line temperature of the heat pump\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Return line temperature of the heat pump\" register" << 1005 << "size:" << 1 << unit.values();
            processHeatpumpReturnTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Return line temperature of the heat pump\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateVolumeFlowSink()
{
    // Update registers from Volume flow heat sink
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Volume flow heat sink\" register:" << 1006 << "size:" << 1;
    QModbusReply *reply = readVolumeFlowSink();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Volume flow heat sink\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Volume flow heat sink\" register" << 1006 << "size:" << 1 << unit.values();
            processVolumeFlowSinkRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Volume flow heat sink\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateEnergySourceInletTemperature()
{
    // Update registers from Heat source inlet temperature
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Heat source inlet temperature\" register:" << 1007 << "size:" << 1;
    QModbusReply *reply = readEnergySourceInletTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Heat source inlet temperature\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Heat source inlet temperature\" register" << 1007 << "size:" << 1 << unit.values();
            processEnergySourceInletTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Heat source inlet temperature\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateEnergySourceOutletTemperature()
{
    // Update registers from Heat source outlet temperature
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Heat source outlet temperature\" register:" << 1008 << "size:" << 1;
    QModbusReply *reply = readEnergySourceOutletTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Heat source outlet temperature\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Heat source outlet temperature\" register" << 1008 << "size:" << 1 << unit.values();
            processEnergySourceOutletTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Heat source outlet temperature\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateVolumeFlowSource()
{
    // Update registers from  Volume flow energy source
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \" Volume flow energy source\" register:" << 1009 << "size:" << 1;
    QModbusReply *reply = readVolumeFlowSource();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \" Volume flow energy source\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \" Volume flow energy source\" register" << 1009 << "size:" << 1 << unit.values();
            processVolumeFlowSourceRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \" Volume flow energy source\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateCompressorRating()
{
    // Update registers from Compressor unit rating
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Compressor unit rating\" register:" << 1010 << "size:" << 1;
    QModbusReply *reply = readCompressorRating();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Compressor unit rating\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Compressor unit rating\" register" << 1010 << "size:" << 1 << unit.values();
            processCompressorRatingRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Compressor unit rating\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateActualHeatingCapacity()
{
    // Update registers from Actual heating capacity
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Actual heating capacity\" register:" << 1011 << "size:" << 1;
    QModbusReply *reply = readActualHeatingCapacity();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Actual heating capacity\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Actual heating capacity\" register" << 1011 << "size:" << 1 << unit.values();
            processActualHeatingCapacityRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Actual heating capacity\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updatePowerActualInverter()
{
    // Update registers from Frequency inverter actual power consumption
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Frequency inverter actual power consumption\" register:" << 1012 << "size:" << 1;
    QModbusReply *reply = readPowerActualInverter();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Frequency inverter actual power consumption\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Frequency inverter actual power consumption\" register" << 1012 << "size:" << 1 << unit.values();
            processPowerActualInverterRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Frequency inverter actual power consumption\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateCoefficientOfPerformance()
{
    // Update registers from Coefficient of performance
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Coefficient of performance\" register:" << 1013 << "size:" << 1;
    QModbusReply *reply = readCoefficientOfPerformance();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Coefficient of performance\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Coefficient of performance\" register" << 1013 << "size:" << 1 << unit.values();
            processCoefficientOfPerformanceRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Coefficient of performance\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateBufferErrorNumber()
{
    // Update registers from buffer error number, 0: no error
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"buffer error number, 0: no error\" register:" << 3000 << "size:" << 1;
    QModbusReply *reply = readBufferErrorNumber();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"buffer error number, 0: no error\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"buffer error number, 0: no error\" register" << 3000 << "size:" << 1 << unit.values();
            processBufferErrorNumberRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"buffer error number, 0: no error\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateBufferState()
{
    // Update registers from Operating state of the buffer
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Operating state of the buffer\" register:" << 3001 << "size:" << 1;
    QModbusReply *reply = readBufferState();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Operating state of the buffer\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Operating state of the buffer\" register" << 3001 << "size:" << 1 << unit.values();
            processBufferStateRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Operating state of the buffer\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateBufferTemperatureHigh()
{
    // Update registers from Actual temperature buffer high sensor
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Actual temperature buffer high sensor\" register:" << 3002 << "size:" << 1;
    QModbusReply *reply = readBufferTemperatureHigh();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Actual temperature buffer high sensor\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Actual temperature buffer high sensor\" register" << 3002 << "size:" << 1 << unit.values();
            processBufferTemperatureHighRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Actual temperature buffer high sensor\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateBufferTemperatureLow()
{
    // Update registers from Actual temperature buffer low sensor
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Actual temperature buffer low sensor\" register:" << 3003 << "size:" << 1;
    QModbusReply *reply = readBufferTemperatureLow();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Actual temperature buffer low sensor\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Actual temperature buffer low sensor\" register" << 3003 << "size:" << 1 << unit.values();
            processBufferTemperatureLowRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Actual temperature buffer low sensor\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateHeatingcircuitErrorNumber()
{
    // Update registers from heating circuit error number, 0: no error
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"heating circuit error number, 0: no error\" register:" << 5000 << "size:" << 1;
    QModbusReply *reply = readHeatingcircuitErrorNumber();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"heating circuit error number, 0: no error\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"heating circuit error number, 0: no error\" register" << 5000 << "size:" << 1 << unit.values();
            processHeatingcircuitErrorNumberRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"heating circuit error number, 0: no error\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateHeatingcircuitState()
{
    // Update registers from Operating state of the heating circuit
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Operating state of the heating circuit\" register:" << 5001 << "size:" << 1;
    QModbusReply *reply = readHeatingcircuitState();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Operating state of the heating circuit\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Operating state of the heating circuit\" register" << 5001 << "size:" << 1 << unit.values();
            processHeatingcircuitStateRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Operating state of the heating circuit\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateFlowTemperature()
{
    // Update registers from Actual temperature flow line sensor
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Actual temperature flow line sensor\" register:" << 5002 << "size:" << 1;
    QModbusReply *reply = readFlowTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Actual temperature flow line sensor\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Actual temperature flow line sensor\" register" << 5002 << "size:" << 1 << unit.values();
            processFlowTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Actual temperature flow line sensor\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateReturnTemperature()
{
    // Update registers from Actual temperature return line sensor
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Actual temperature return line sensor\" register:" << 5003 << "size:" << 1;
    QModbusReply *reply = readReturnTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Actual temperature return line sensor\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Actual temperature return line sensor\" register" << 5003 << "size:" << 1 << unit.values();
            processReturnTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Actual temperature return line sensor\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateRoomTemperature()
{
    // Update registers from actual temperatur room device sensor
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"actual temperatur room device sensor\" register:" << 5004 << "size:" << 1;
    QModbusReply *reply = readRoomTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"actual temperatur room device sensor\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"actual temperatur room device sensor\" register" << 5004 << "size:" << 1 << unit.values();
            processRoomTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"actual temperatur room device sensor\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateSetpointFlowTemperature()
{
    // Update registers from Setpoint flow temperature
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Setpoint flow temperature\" register:" << 5005 << "size:" << 1;
    QModbusReply *reply = readSetpointFlowTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Setpoint flow temperature\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Setpoint flow temperature\" register" << 5005 << "size:" << 1 << unit.values();
            processSetpointFlowTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Setpoint flow temperature\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateHeatingcircuitMode()
{
    // Update registers from Operating mode of the heating circuit
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Operating mode of the heating circuit\" register:" << 5006 << "size:" << 1;
    QModbusReply *reply = readHeatingcircuitMode();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Operating mode of the heating circuit\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Operating mode of the heating circuit\" register" << 5006 << "size:" << 1 << unit.values();
            processHeatingcircuitModeRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Operating mode of the heating circuit\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateAmbientBlock()
{
    // Update register block "ambient"
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"ambient\" registers from:" << 0 << "size:" << 5;
    QModbusReply *reply = readBlockAmbient();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"ambient\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"ambient\" register" << 0 << "size:" << 5 << blockValues;
            processAmbientErrorNumberRegisterValues(blockValues.mid(0, 1));
            processAmbientStateRegisterValues(blockValues.mid(1, 1));
            processActualAmbientTemperatureRegisterValues(blockValues.mid(2, 1));
            processAverageAmbientTemperatureRegisterValues(blockValues.mid(3, 1));
            processOutdoorTemperatureRegisterValues(blockValues.mid(4, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"ambient\" registers" << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateEmanagerBlock()
{
    // Update register block "emanager"
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"emanager\" registers from:" << 100 << "size:" << 2;
    QModbusReply *reply = readBlockEmanager();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"emanager\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"emanager\" register" << 100 << "size:" << 2 << blockValues;
            processEmanagerErrorNumberRegisterValues(blockValues.mid(0, 1));
            processEmanagerStateRegisterValues(blockValues.mid(1, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"emanager\" registers" << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updatePowerBlock()
{
    // Update register block "power"
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"power\" registers from:" << 103 << "size:" << 2;
    QModbusReply *reply = readBlockPower();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"power\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"power\" register" << 103 << "size:" << 2 << blockValues;
            processCurrentPowerRegisterValues(blockValues.mid(0, 1));
            processPowerSetpointRegisterValues(blockValues.mid(1, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"power\" registers" << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateHeatpumpBlock()
{
    // Update register block "heatpump"
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"heatpump\" registers from:" << 1000 << "size:" << 14;
    QModbusReply *reply = readBlockHeatpump();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"heatpump\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"heatpump\" register" << 1000 << "size:" << 14 << blockValues;
            processHeatpumpErrorStateRegisterValues(blockValues.mid(0, 1));
            processHeatpumpErrorNumberRegisterValues(blockValues.mid(1, 1));
            processSystemStatusRegisterValues(blockValues.mid(2, 1));
            processHeatpumpStateRegisterValues(blockValues.mid(3, 1));
            processHeatpumpFlowTemperatureRegisterValues(blockValues.mid(4, 1));
            processHeatpumpReturnTemperatureRegisterValues(blockValues.mid(5, 1));
            processVolumeFlowSinkRegisterValues(blockValues.mid(6, 1));
            processEnergySourceInletTemperatureRegisterValues(blockValues.mid(7, 1));
            processEnergySourceOutletTemperatureRegisterValues(blockValues.mid(8, 1));
            processVolumeFlowSourceRegisterValues(blockValues.mid(9, 1));
            processCompressorRatingRegisterValues(blockValues.mid(10, 1));
            processActualHeatingCapacityRegisterValues(blockValues.mid(11, 1));
            processPowerActualInverterRegisterValues(blockValues.mid(12, 1));
            processCoefficientOfPerformanceRegisterValues(blockValues.mid(13, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"heatpump\" registers" << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateBufferBlock()
{
    // Update register block "buffer"
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"buffer\" registers from:" << 3000 << "size:" << 4;
    QModbusReply *reply = readBlockBuffer();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"buffer\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"buffer\" register" << 3000 << "size:" << 4 << blockValues;
            processBufferErrorNumberRegisterValues(blockValues.mid(0, 1));
            processBufferStateRegisterValues(blockValues.mid(1, 1));
            processBufferTemperatureHighRegisterValues(blockValues.mid(2, 1));
            processBufferTemperatureLowRegisterValues(blockValues.mid(3, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"buffer\" registers" << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateHeatcircBlock()
{
    // Update register block "heatcirc"
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"heatcirc\" registers from:" << 5000 << "size:" << 7;
    QModbusReply *reply = readBlockHeatcirc();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"heatcirc\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"heatcirc\" register" << 5000 << "size:" << 7 << blockValues;
            processHeatingcircuitErrorNumberRegisterValues(blockValues.mid(0, 1));
            processHeatingcircuitStateRegisterValues(blockValues.mid(1, 1));
            processFlowTemperatureRegisterValues(blockValues.mid(2, 1));
            processReturnTemperatureRegisterValues(blockValues.mid(3, 1));
            processRoomTemperatureRegisterValues(blockValues.mid(4, 1));
            processSetpointFlowTemperatureRegisterValues(blockValues.mid(5, 1));
            processHeatingcircuitModeRegisterValues(blockValues.mid(6, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"heatcirc\" registers" << error << reply->errorString();
    });
}

QModbusReply *LambdaModbusTcpConnection::readActualPvSurplus()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 102, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readTotalEnergyConsumed()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1020, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readCompressorTotalHeatOutput()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1022, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readHotWaterTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 2002, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readAmbientErrorNumber()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 0, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readAmbientState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readActualAmbientTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 2, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readAverageAmbientTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 3, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readOutdoorTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readEmanagerErrorNumber()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 100, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readEmanagerState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 101, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readCurrentPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 103, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readPowerSetpoint()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 104, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readHeatpumpErrorState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1000, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readHeatpumpErrorNumber()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1001, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readSystemStatus()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1002, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readHeatpumpState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1003, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readHeatpumpFlowTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1004, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readHeatpumpReturnTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1005, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readVolumeFlowSink()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1006, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readEnergySourceInletTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1007, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readEnergySourceOutletTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1008, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readVolumeFlowSource()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1009, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readCompressorRating()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1010, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readActualHeatingCapacity()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1011, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readPowerActualInverter()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1012, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readCoefficientOfPerformance()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1013, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readBufferErrorNumber()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 3000, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readBufferState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 3001, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readBufferTemperatureHigh()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 3002, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readBufferTemperatureLow()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 3003, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readHeatingcircuitErrorNumber()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 5000, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readHeatingcircuitState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 5001, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readFlowTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 5002, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readReturnTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 5003, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readRoomTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 5004, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readSetpointFlowTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 5005, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readHeatingcircuitMode()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 5006, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readBlockAmbient()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 0, 5);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readBlockEmanager()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 100, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readBlockPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 103, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readBlockHeatpump()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1000, 14);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readBlockBuffer()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 3000, 4);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readBlockHeatcirc()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 5000, 7);
    return sendReadRequest(request, m_slaveId);
}

void LambdaModbusTcpConnection::processActualPvSurplusRegisterValues(const QVector<quint16> values)
{
    qint16 receivedActualPvSurplus = ModbusDataUtils::convertToInt16(values);
    emit actualPvSurplusReadFinished(receivedActualPvSurplus);

    if (m_actualPvSurplus != receivedActualPvSurplus) {
        m_actualPvSurplus = receivedActualPvSurplus;
        emit actualPvSurplusChanged(m_actualPvSurplus);
    }
}

void LambdaModbusTcpConnection::processTotalEnergyConsumedRegisterValues(const QVector<quint16> values)
{
    float receivedTotalEnergyConsumed = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -3);
    emit totalEnergyConsumedReadFinished(receivedTotalEnergyConsumed);

    if (m_totalEnergyConsumed != receivedTotalEnergyConsumed) {
        m_totalEnergyConsumed = receivedTotalEnergyConsumed;
        emit totalEnergyConsumedChanged(m_totalEnergyConsumed);
    }
}

void LambdaModbusTcpConnection::processCompressorTotalHeatOutputRegisterValues(const QVector<quint16> values)
{
    float receivedCompressorTotalHeatOutput = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -3);
    emit compressorTotalHeatOutputReadFinished(receivedCompressorTotalHeatOutput);

    if (m_compressorTotalHeatOutput != receivedCompressorTotalHeatOutput) {
        m_compressorTotalHeatOutput = receivedCompressorTotalHeatOutput;
        emit compressorTotalHeatOutputChanged(m_compressorTotalHeatOutput);
    }
}

void LambdaModbusTcpConnection::processHotWaterTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedHotWaterTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit hotWaterTemperatureReadFinished(receivedHotWaterTemperature);

    if (m_hotWaterTemperature != receivedHotWaterTemperature) {
        m_hotWaterTemperature = receivedHotWaterTemperature;
        emit hotWaterTemperatureChanged(m_hotWaterTemperature);
    }
}

void LambdaModbusTcpConnection::processAmbientErrorNumberRegisterValues(const QVector<quint16> values)
{
    qint16 receivedAmbientErrorNumber = ModbusDataUtils::convertToInt16(values);
    emit ambientErrorNumberReadFinished(receivedAmbientErrorNumber);

    if (m_ambientErrorNumber != receivedAmbientErrorNumber) {
        m_ambientErrorNumber = receivedAmbientErrorNumber;
        emit ambientErrorNumberChanged(m_ambientErrorNumber);
    }
}

void LambdaModbusTcpConnection::processAmbientStateRegisterValues(const QVector<quint16> values)
{
    AmbientState receivedAmbientState = static_cast<AmbientState>(ModbusDataUtils::convertToUInt16(values));
    emit ambientStateReadFinished(receivedAmbientState);

    if (m_ambientState != receivedAmbientState) {
        m_ambientState = receivedAmbientState;
        emit ambientStateChanged(m_ambientState);
    }
}

void LambdaModbusTcpConnection::processActualAmbientTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedActualAmbientTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit actualAmbientTemperatureReadFinished(receivedActualAmbientTemperature);

    if (m_actualAmbientTemperature != receivedActualAmbientTemperature) {
        m_actualAmbientTemperature = receivedActualAmbientTemperature;
        emit actualAmbientTemperatureChanged(m_actualAmbientTemperature);
    }
}

void LambdaModbusTcpConnection::processAverageAmbientTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedAverageAmbientTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit averageAmbientTemperatureReadFinished(receivedAverageAmbientTemperature);

    if (m_averageAmbientTemperature != receivedAverageAmbientTemperature) {
        m_averageAmbientTemperature = receivedAverageAmbientTemperature;
        emit averageAmbientTemperatureChanged(m_averageAmbientTemperature);
    }
}

void LambdaModbusTcpConnection::processOutdoorTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedOutdoorTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit outdoorTemperatureReadFinished(receivedOutdoorTemperature);

    if (m_outdoorTemperature != receivedOutdoorTemperature) {
        m_outdoorTemperature = receivedOutdoorTemperature;
        emit outdoorTemperatureChanged(m_outdoorTemperature);
    }
}

void LambdaModbusTcpConnection::processEmanagerErrorNumberRegisterValues(const QVector<quint16> values)
{
    qint16 receivedEmanagerErrorNumber = ModbusDataUtils::convertToInt16(values);
    emit emanagerErrorNumberReadFinished(receivedEmanagerErrorNumber);

    if (m_emanagerErrorNumber != receivedEmanagerErrorNumber) {
        m_emanagerErrorNumber = receivedEmanagerErrorNumber;
        emit emanagerErrorNumberChanged(m_emanagerErrorNumber);
    }
}

void LambdaModbusTcpConnection::processEmanagerStateRegisterValues(const QVector<quint16> values)
{
    EmanagerState receivedEmanagerState = static_cast<EmanagerState>(ModbusDataUtils::convertToUInt16(values));
    emit emanagerStateReadFinished(receivedEmanagerState);

    if (m_emanagerState != receivedEmanagerState) {
        m_emanagerState = receivedEmanagerState;
        emit emanagerStateChanged(m_emanagerState);
    }
}

void LambdaModbusTcpConnection::processCurrentPowerRegisterValues(const QVector<quint16> values)
{
    qint16 receivedCurrentPower = ModbusDataUtils::convertToInt16(values);
    emit currentPowerReadFinished(receivedCurrentPower);

    if (m_currentPower != receivedCurrentPower) {
        m_currentPower = receivedCurrentPower;
        emit currentPowerChanged(m_currentPower);
    }
}

void LambdaModbusTcpConnection::processPowerSetpointRegisterValues(const QVector<quint16> values)
{
    qint16 receivedPowerSetpoint = ModbusDataUtils::convertToInt16(values);
    emit powerSetpointReadFinished(receivedPowerSetpoint);

    if (m_powerSetpoint != receivedPowerSetpoint) {
        m_powerSetpoint = receivedPowerSetpoint;
        emit powerSetpointChanged(m_powerSetpoint);
    }
}

void LambdaModbusTcpConnection::processHeatpumpErrorStateRegisterValues(const QVector<quint16> values)
{
    HeatpumpErrorState receivedHeatpumpErrorState = static_cast<HeatpumpErrorState>(ModbusDataUtils::convertToUInt16(values));
    emit heatpumpErrorStateReadFinished(receivedHeatpumpErrorState);

    if (m_heatpumpErrorState != receivedHeatpumpErrorState) {
        m_heatpumpErrorState = receivedHeatpumpErrorState;
        emit heatpumpErrorStateChanged(m_heatpumpErrorState);
    }
}

void LambdaModbusTcpConnection::processHeatpumpErrorNumberRegisterValues(const QVector<quint16> values)
{
    qint16 receivedHeatpumpErrorNumber = ModbusDataUtils::convertToInt16(values);
    emit heatpumpErrorNumberReadFinished(receivedHeatpumpErrorNumber);

    if (m_heatpumpErrorNumber != receivedHeatpumpErrorNumber) {
        m_heatpumpErrorNumber = receivedHeatpumpErrorNumber;
        emit heatpumpErrorNumberChanged(m_heatpumpErrorNumber);
    }
}

void LambdaModbusTcpConnection::processSystemStatusRegisterValues(const QVector<quint16> values)
{
    SystemStatus receivedSystemStatus = static_cast<SystemStatus>(ModbusDataUtils::convertToUInt16(values));
    emit systemStatusReadFinished(receivedSystemStatus);

    if (m_systemStatus != receivedSystemStatus) {
        m_systemStatus = receivedSystemStatus;
        emit systemStatusChanged(m_systemStatus);
    }
}

void LambdaModbusTcpConnection::processHeatpumpStateRegisterValues(const QVector<quint16> values)
{
    HeatpumpState receivedHeatpumpState = static_cast<HeatpumpState>(ModbusDataUtils::convertToUInt16(values));
    emit heatpumpStateReadFinished(receivedHeatpumpState);

    if (m_heatpumpState != receivedHeatpumpState) {
        m_heatpumpState = receivedHeatpumpState;
        emit heatpumpStateChanged(m_heatpumpState);
    }
}

void LambdaModbusTcpConnection::processHeatpumpFlowTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedHeatpumpFlowTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -2);
    emit heatpumpFlowTemperatureReadFinished(receivedHeatpumpFlowTemperature);

    if (m_heatpumpFlowTemperature != receivedHeatpumpFlowTemperature) {
        m_heatpumpFlowTemperature = receivedHeatpumpFlowTemperature;
        emit heatpumpFlowTemperatureChanged(m_heatpumpFlowTemperature);
    }
}

void LambdaModbusTcpConnection::processHeatpumpReturnTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedHeatpumpReturnTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -2);
    emit heatpumpReturnTemperatureReadFinished(receivedHeatpumpReturnTemperature);

    if (m_heatpumpReturnTemperature != receivedHeatpumpReturnTemperature) {
        m_heatpumpReturnTemperature = receivedHeatpumpReturnTemperature;
        emit heatpumpReturnTemperatureChanged(m_heatpumpReturnTemperature);
    }
}

void LambdaModbusTcpConnection::processVolumeFlowSinkRegisterValues(const QVector<quint16> values)
{
    float receivedVolumeFlowSink = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -2);
    emit volumeFlowSinkReadFinished(receivedVolumeFlowSink);

    if (m_volumeFlowSink != receivedVolumeFlowSink) {
        m_volumeFlowSink = receivedVolumeFlowSink;
        emit volumeFlowSinkChanged(m_volumeFlowSink);
    }
}

void LambdaModbusTcpConnection::processEnergySourceInletTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedEnergySourceInletTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -2);
    emit energySourceInletTemperatureReadFinished(receivedEnergySourceInletTemperature);

    if (m_energySourceInletTemperature != receivedEnergySourceInletTemperature) {
        m_energySourceInletTemperature = receivedEnergySourceInletTemperature;
        emit energySourceInletTemperatureChanged(m_energySourceInletTemperature);
    }
}

void LambdaModbusTcpConnection::processEnergySourceOutletTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedEnergySourceOutletTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -2);
    emit energySourceOutletTemperatureReadFinished(receivedEnergySourceOutletTemperature);

    if (m_energySourceOutletTemperature != receivedEnergySourceOutletTemperature) {
        m_energySourceOutletTemperature = receivedEnergySourceOutletTemperature;
        emit energySourceOutletTemperatureChanged(m_energySourceOutletTemperature);
    }
}

void LambdaModbusTcpConnection::processVolumeFlowSourceRegisterValues(const QVector<quint16> values)
{
    float receivedVolumeFlowSource = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -2);
    emit volumeFlowSourceReadFinished(receivedVolumeFlowSource);

    if (m_volumeFlowSource != receivedVolumeFlowSource) {
        m_volumeFlowSource = receivedVolumeFlowSource;
        emit volumeFlowSourceChanged(m_volumeFlowSource);
    }
}

void LambdaModbusTcpConnection::processCompressorRatingRegisterValues(const QVector<quint16> values)
{
    float receivedCompressorRating = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit compressorRatingReadFinished(receivedCompressorRating);

    if (m_compressorRating != receivedCompressorRating) {
        m_compressorRating = receivedCompressorRating;
        emit compressorRatingChanged(m_compressorRating);
    }
}

void LambdaModbusTcpConnection::processActualHeatingCapacityRegisterValues(const QVector<quint16> values)
{
    float receivedActualHeatingCapacity = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit actualHeatingCapacityReadFinished(receivedActualHeatingCapacity);

    if (m_actualHeatingCapacity != receivedActualHeatingCapacity) {
        m_actualHeatingCapacity = receivedActualHeatingCapacity;
        emit actualHeatingCapacityChanged(m_actualHeatingCapacity);
    }
}

void LambdaModbusTcpConnection::processPowerActualInverterRegisterValues(const QVector<quint16> values)
{
    qint16 receivedPowerActualInverter = ModbusDataUtils::convertToInt16(values);
    emit powerActualInverterReadFinished(receivedPowerActualInverter);

    if (m_powerActualInverter != receivedPowerActualInverter) {
        m_powerActualInverter = receivedPowerActualInverter;
        emit powerActualInverterChanged(m_powerActualInverter);
    }
}

void LambdaModbusTcpConnection::processCoefficientOfPerformanceRegisterValues(const QVector<quint16> values)
{
    float receivedCoefficientOfPerformance = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -2);
    emit coefficientOfPerformanceReadFinished(receivedCoefficientOfPerformance);

    if (m_coefficientOfPerformance != receivedCoefficientOfPerformance) {
        m_coefficientOfPerformance = receivedCoefficientOfPerformance;
        emit coefficientOfPerformanceChanged(m_coefficientOfPerformance);
    }
}

void LambdaModbusTcpConnection::processBufferErrorNumberRegisterValues(const QVector<quint16> values)
{
    qint16 receivedBufferErrorNumber = ModbusDataUtils::convertToInt16(values);
    emit bufferErrorNumberReadFinished(receivedBufferErrorNumber);

    if (m_bufferErrorNumber != receivedBufferErrorNumber) {
        m_bufferErrorNumber = receivedBufferErrorNumber;
        emit bufferErrorNumberChanged(m_bufferErrorNumber);
    }
}

void LambdaModbusTcpConnection::processBufferStateRegisterValues(const QVector<quint16> values)
{
    BufferState receivedBufferState = static_cast<BufferState>(ModbusDataUtils::convertToUInt16(values));
    emit bufferStateReadFinished(receivedBufferState);

    if (m_bufferState != receivedBufferState) {
        m_bufferState = receivedBufferState;
        emit bufferStateChanged(m_bufferState);
    }
}

void LambdaModbusTcpConnection::processBufferTemperatureHighRegisterValues(const QVector<quint16> values)
{
    float receivedBufferTemperatureHigh = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit bufferTemperatureHighReadFinished(receivedBufferTemperatureHigh);

    if (m_bufferTemperatureHigh != receivedBufferTemperatureHigh) {
        m_bufferTemperatureHigh = receivedBufferTemperatureHigh;
        emit bufferTemperatureHighChanged(m_bufferTemperatureHigh);
    }
}

void LambdaModbusTcpConnection::processBufferTemperatureLowRegisterValues(const QVector<quint16> values)
{
    float receivedBufferTemperatureLow = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit bufferTemperatureLowReadFinished(receivedBufferTemperatureLow);

    if (m_bufferTemperatureLow != receivedBufferTemperatureLow) {
        m_bufferTemperatureLow = receivedBufferTemperatureLow;
        emit bufferTemperatureLowChanged(m_bufferTemperatureLow);
    }
}

void LambdaModbusTcpConnection::processHeatingcircuitErrorNumberRegisterValues(const QVector<quint16> values)
{
    float receivedHeatingcircuitErrorNumber = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit heatingcircuitErrorNumberReadFinished(receivedHeatingcircuitErrorNumber);

    if (m_heatingcircuitErrorNumber != receivedHeatingcircuitErrorNumber) {
        m_heatingcircuitErrorNumber = receivedHeatingcircuitErrorNumber;
        emit heatingcircuitErrorNumberChanged(m_heatingcircuitErrorNumber);
    }
}

void LambdaModbusTcpConnection::processHeatingcircuitStateRegisterValues(const QVector<quint16> values)
{
    HeatingcircuitState receivedHeatingcircuitState = static_cast<HeatingcircuitState>(ModbusDataUtils::convertToUInt16(values));
    emit heatingcircuitStateReadFinished(receivedHeatingcircuitState);

    if (m_heatingcircuitState != receivedHeatingcircuitState) {
        m_heatingcircuitState = receivedHeatingcircuitState;
        emit heatingcircuitStateChanged(m_heatingcircuitState);
    }
}

void LambdaModbusTcpConnection::processFlowTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedFlowTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit flowTemperatureReadFinished(receivedFlowTemperature);

    if (m_flowTemperature != receivedFlowTemperature) {
        m_flowTemperature = receivedFlowTemperature;
        emit flowTemperatureChanged(m_flowTemperature);
    }
}

void LambdaModbusTcpConnection::processReturnTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedReturnTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit returnTemperatureReadFinished(receivedReturnTemperature);

    if (m_returnTemperature != receivedReturnTemperature) {
        m_returnTemperature = receivedReturnTemperature;
        emit returnTemperatureChanged(m_returnTemperature);
    }
}

void LambdaModbusTcpConnection::processRoomTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedRoomTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit roomTemperatureReadFinished(receivedRoomTemperature);

    if (m_roomTemperature != receivedRoomTemperature) {
        m_roomTemperature = receivedRoomTemperature;
        emit roomTemperatureChanged(m_roomTemperature);
    }
}

void LambdaModbusTcpConnection::processSetpointFlowTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedSetpointFlowTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit setpointFlowTemperatureReadFinished(receivedSetpointFlowTemperature);

    if (m_setpointFlowTemperature != receivedSetpointFlowTemperature) {
        m_setpointFlowTemperature = receivedSetpointFlowTemperature;
        emit setpointFlowTemperatureChanged(m_setpointFlowTemperature);
    }
}

void LambdaModbusTcpConnection::processHeatingcircuitModeRegisterValues(const QVector<quint16> values)
{
    HeatingcircuitMode receivedHeatingcircuitMode = static_cast<HeatingcircuitMode>(ModbusDataUtils::convertToUInt16(values));
    emit heatingcircuitModeReadFinished(receivedHeatingcircuitMode);

    if (m_heatingcircuitMode != receivedHeatingcircuitMode) {
        m_heatingcircuitMode = receivedHeatingcircuitMode;
        emit heatingcircuitModeChanged(m_heatingcircuitMode);
    }
}

void LambdaModbusTcpConnection::handleModbusError(QModbusDevice::Error error)
{
    if (error == QModbusDevice::NoError) {
        // Reset the communication counter and we know we can reach the device
        m_communicationFailedCounter = 0;
        if (!m_communicationWorking)
            qCDebug(dcLambdaModbusTcpConnection()) << "Received a reply without any errors. The communication with the device seems to work now.";

        m_communicationWorking = true;
        evaluateReachableState();
    } else {
        m_communicationFailedCounter++;
        if (m_communicationWorking && m_communicationFailedCounter >= m_communicationFailedMax) {
            m_communicationWorking = false;
            qCWarning(dcLambdaModbusTcpConnection()) << "Received" << m_communicationFailedCounter << "errors while communicating with the RTU master. Mark as not reachable until the communication works again.";
            evaluateReachableState();
        }
    }
}

void LambdaModbusTcpConnection::testReachability()
{
    if (m_checkRechableReply)
        return;

    // Try to read the check reachability register systemStatus in order to verify if the communication is working or not.
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Test reachability by reading \"System status of the heat pump\" register:" << 1002 << "size:" << 1;
    m_checkRechableReply = readSystemStatus();
    if (!m_checkRechableReply) {
        qCDebug(dcLambdaModbusTcpConnection()) << "Error occurred verifying reachability by reading \"System status of the heat pump\" register";
        onReachabilityCheckFailed();
        return;
    }

    if (m_checkRechableReply->isFinished()) {
        m_checkRechableReply->deleteLater(); // Broadcast reply returns immediatly
        m_checkRechableReply = nullptr;
        onReachabilityCheckFailed();
        return;
    }

    connect(m_checkRechableReply, &QModbusReply::finished, this, [this](){
        handleModbusError(m_checkRechableReply->error());
        if (m_checkRechableReply->error() != QModbusDevice::NoError)
            onReachabilityCheckFailed();

        m_checkRechableReply->deleteLater();
        m_checkRechableReply = nullptr;
    });

    connect(m_checkRechableReply, &QModbusReply::errorOccurred, this, [this] (QModbusDevice::Error error){
        qCDebug(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while verifying reachability by reading \"System status of the heat pump\" register" << error << m_checkRechableReply->errorString();
    });
}

void LambdaModbusTcpConnection::verifyInitFinished()
{
    if (m_pendingInitReplies.isEmpty()) {
        finishInitialization(true);
    }
}

void LambdaModbusTcpConnection::finishInitialization(bool success)
{
    if (success) {
        qCDebug(dcLambdaModbusTcpConnection()) << "Initialization finished of LambdaModbusTcpConnection" << hostAddress().toString() << "finished successfully";
    } else {
        qCWarning(dcLambdaModbusTcpConnection()) << "Initialization finished of LambdaModbusTcpConnection" << hostAddress().toString() << "failed.";
    }

    // Cleanup init
    delete m_initObject;
    m_initObject = nullptr;
    m_pendingInitReplies.clear();

    emit initializationFinished(success);
}

void LambdaModbusTcpConnection::verifyUpdateFinished()
{
    if (m_pendingUpdateReplies.isEmpty()) {
        emit updateFinished();
    }
}

void LambdaModbusTcpConnection::onReachabilityCheckFailed()
{
    m_checkReachableRetriesCount++;

    if (m_checkReachableRetriesCount <= m_checkReachableRetries) {
        qCDebug(dcLambdaModbusTcpConnection()) << "Reachability test failed. Retry in on second" << m_checkReachableRetriesCount << "/" << m_checkReachableRetries;
        QTimer::singleShot(1000, this, &LambdaModbusTcpConnection::testReachability);
        return;
    }

    // The test reachability method failed, not retrying any more
    emit checkReachabilityFailed();
}

void LambdaModbusTcpConnection::evaluateReachableState()
{
    bool reachable = m_communicationWorking && connected();
    if (m_reachable == reachable)
        return;

    m_reachable = reachable;
    emit reachableChanged(m_reachable);
    m_checkReachableRetriesCount = 0;
}

QDebug operator<<(QDebug debug, LambdaModbusTcpConnection *lambdaModbusTcpConnection)
{
    debug.nospace().noquote() << "LambdaModbusTcpConnection(" << lambdaModbusTcpConnection->hostAddress().toString() << ":" << lambdaModbusTcpConnection->port() << ")" << "\n";
    debug.nospace().noquote() << "    - actual PV surplus power: " << lambdaModbusTcpConnection->actualPvSurplus() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Accumulated electrical energy consumption of compressor unit since last statistic reset: " << lambdaModbusTcpConnection->totalEnergyConsumed() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Accumulated thermal energy output of compressor unit since last statistic reset: " << lambdaModbusTcpConnection->compressorTotalHeatOutput() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Actual temperature boiler high sensor: " << lambdaModbusTcpConnection->hotWaterTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - ambient error number: " << lambdaModbusTcpConnection->ambientErrorNumber() << "\n";
    debug.nospace().noquote() << "    - operating state for ambient module: " << lambdaModbusTcpConnection->ambientState() << "\n";
    debug.nospace().noquote() << "    - actual ambient temperature: " << lambdaModbusTcpConnection->actualAmbientTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - Arithmetic average temperature of the last 60 minutes: " << lambdaModbusTcpConnection->averageAmbientTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - calculated ambient temperature: " << lambdaModbusTcpConnection->outdoorTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - E-Manager error number, 0: no error: " << lambdaModbusTcpConnection->emanagerErrorNumber() << "\n";
    debug.nospace().noquote() << "    - operating state for E-Manager module: " << lambdaModbusTcpConnection->emanagerState() << "\n";
    debug.nospace().noquote() << "    - actual power consumption of all configured heat pumps: " << lambdaModbusTcpConnection->currentPower() << " [W]" << "\n";
    debug.nospace().noquote() << "    - realized power consumption setpoint of all configured heat pumps: " << lambdaModbusTcpConnection->powerSetpoint() << " [W]" << "\n";
    debug.nospace().noquote() << "    - error state for heat pump module: " << lambdaModbusTcpConnection->heatpumpErrorState() << "\n";
    debug.nospace().noquote() << "    - active heat pump error numbers: " << lambdaModbusTcpConnection->heatpumpErrorNumber() << "\n";
    debug.nospace().noquote() << "    - System status of the heat pump: " << lambdaModbusTcpConnection->systemStatus() << "\n";
    debug.nospace().noquote() << "    - Operating state of the heat pump: " << lambdaModbusTcpConnection->heatpumpState() << "\n";
    debug.nospace().noquote() << "    - Flow line temperature of the heat pump: " << lambdaModbusTcpConnection->heatpumpFlowTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - Return line temperature of the heat pump: " << lambdaModbusTcpConnection->heatpumpReturnTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - Volume flow heat sink: " << lambdaModbusTcpConnection->volumeFlowSink() << " [l/min]" << "\n";
    debug.nospace().noquote() << "    - Heat source inlet temperature: " << lambdaModbusTcpConnection->energySourceInletTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - Heat source outlet temperature: " << lambdaModbusTcpConnection->energySourceOutletTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    -  Volume flow energy source: " << lambdaModbusTcpConnection->volumeFlowSource() << " [l/min]" << "\n";
    debug.nospace().noquote() << "    - Compressor unit rating: " << lambdaModbusTcpConnection->compressorRating() << " [%]" << "\n";
    debug.nospace().noquote() << "    - Actual heating capacity: " << lambdaModbusTcpConnection->actualHeatingCapacity() << " [kW]" << "\n";
    debug.nospace().noquote() << "    - Frequency inverter actual power consumption: " << lambdaModbusTcpConnection->powerActualInverter() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Coefficient of performance: " << lambdaModbusTcpConnection->coefficientOfPerformance() << " [%]" << "\n";
    debug.nospace().noquote() << "    - buffer error number, 0: no error: " << lambdaModbusTcpConnection->bufferErrorNumber() << "\n";
    debug.nospace().noquote() << "    - Operating state of the buffer: " << lambdaModbusTcpConnection->bufferState() << "\n";
    debug.nospace().noquote() << "    - Actual temperature buffer high sensor: " << lambdaModbusTcpConnection->bufferTemperatureHigh() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - Actual temperature buffer low sensor: " << lambdaModbusTcpConnection->bufferTemperatureLow() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - heating circuit error number, 0: no error: " << lambdaModbusTcpConnection->heatingcircuitErrorNumber() << "\n";
    debug.nospace().noquote() << "    - Operating state of the heating circuit: " << lambdaModbusTcpConnection->heatingcircuitState() << "\n";
    debug.nospace().noquote() << "    - Actual temperature flow line sensor: " << lambdaModbusTcpConnection->flowTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - Actual temperature return line sensor: " << lambdaModbusTcpConnection->returnTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - actual temperatur room device sensor: " << lambdaModbusTcpConnection->roomTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - Setpoint flow temperature: " << lambdaModbusTcpConnection->setpointFlowTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - Operating mode of the heating circuit: " << lambdaModbusTcpConnection->heatingcircuitMode() << "\n";
    return debug.quote().space();
}

QString LambdaModbusTcpConnection::exceptionToString(QModbusPdu::ExceptionCode exception)
{
    QString exceptionString;
    switch (exception) {
    case QModbusPdu::IllegalFunction:
        exceptionString = "Illegal function";
        break;
    case QModbusPdu::IllegalDataAddress:
        exceptionString = "Illegal data address";
        break;
    case QModbusPdu::IllegalDataValue:
        exceptionString = "Illegal data value";
        break;
    case QModbusPdu::ServerDeviceFailure:
        exceptionString = "Server device failure";
        break;
    case QModbusPdu::Acknowledge:
        exceptionString = "Acknowledge";
        break;
    case QModbusPdu::ServerDeviceBusy:
        exceptionString = "Server device busy";
        break;
    case QModbusPdu::NegativeAcknowledge:
        exceptionString = "Negative acknowledge";
        break;
    case QModbusPdu::MemoryParityError:
        exceptionString = "Memory parity error";
        break;
    case QModbusPdu::GatewayPathUnavailable:
        exceptionString = "Gateway path unavailable";
        break;
    case QModbusPdu::GatewayTargetDeviceFailedToRespond:
        exceptionString = "Gateway target device failed to respond";
        break;
    case QModbusPdu::ExtendedException:
        exceptionString = "Extended exception";
        break;
    }
    return exceptionString;
}
