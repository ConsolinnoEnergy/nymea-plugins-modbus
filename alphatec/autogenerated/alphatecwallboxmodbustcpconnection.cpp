/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Copyright 2013 - 2022, nymea GmbH
* Contact: contact@nymea.io
*
* This fileDescriptor is part of nymea.
* This project including source code and documentation is protected by
* copyright law, and remains the property of nymea GmbH. All rights, including
* reproduction, publication, editing and translation, are reserved. The use of
* this project is subject to the terms of a license agreement to be concluded
* with nymea GmbH in accordance with the terms of use of nymea GmbH, available
* under https://nymea.io/license
*
* GNU Lesser General Public License Usage
* Alternatively, this project may be redistributed and/or modified under the
* terms of the GNU Lesser General Public License as published by the Free
* Software Foundation; version 3. This project is distributed in the hope that
* it will be useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this project. If not, see <https://www.gnu.org/licenses/>.
*
* For any further details and any questions please contact us under
* contact@nymea.io or see our FAQ/Licensing Information on
* https://nymea.io/license/faq
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WARNING
*
* This file has been autogenerated. Any changes in this file may be overwritten.
* If you want to change something, update the register json or the tool.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


#include "alphatecwallboxmodbustcpconnection.h"
#include <loggingcategories.h>
#include <math.h>
#include <QTimer>

NYMEA_LOGGING_CATEGORY(dcAlphatecWallboxModbusTcpConnection, "AlphatecWallboxModbusTcpConnection")

AlphatecWallboxModbusTcpConnection::AlphatecWallboxModbusTcpConnection(const QHostAddress &hostAddress, uint port, quint16 slaveId, QObject *parent) :
    ModbusTCPMaster(hostAddress, port, parent),
    m_slaveId(slaveId)
{
    connect(this, &ModbusTCPMaster::connectionStateChanged, this, [this](bool status){
        if (status) {
           qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "Modbus TCP connection" << m_hostAddress.toString() << "connected. Start testing if the connection is reachable...";
            // Cleanup before starting to initialize
            m_pendingInitReplies.clear();
            m_pendingUpdateReplies.clear();
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
            testReachability();
        } else {
            qCWarning(dcAlphatecWallboxModbusTcpConnection()) << "Modbus TCP connection diconnected from" << m_hostAddress.toString() << ". The connection is not reachable any more.";
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
        }

        evaluateReachableState();
    });
}

bool AlphatecWallboxModbusTcpConnection::reachable() const
{
    return m_reachable;
}

uint AlphatecWallboxModbusTcpConnection::checkReachableRetries() const
{
    return m_checkReachableRetries;
}

void AlphatecWallboxModbusTcpConnection::setCheckReachableRetries(uint checkReachableRetries)
{
    if (m_checkReachableRetries == checkReachableRetries)
        return;

    m_checkReachableRetries = checkReachableRetries;
    emit checkReachableRetriesChanged(m_checkReachableRetries);
}

ModbusDataUtils::ByteOrder AlphatecWallboxModbusTcpConnection::endianness() const
{
    return m_endianness;
}

void AlphatecWallboxModbusTcpConnection::setEndianness(ModbusDataUtils::ByteOrder endianness)
{
    if (m_endianness == endianness)
        return;

    m_endianness = endianness;
    emit endiannessChanged(m_endianness);
}

quint32 AlphatecWallboxModbusTcpConnection::evseStatus() const
{
    return m_evseStatus;
}

quint32 AlphatecWallboxModbusTcpConnection::chargePower() const
{
    return m_chargePower;
}

quint16 AlphatecWallboxModbusTcpConnection::writeChargeLimit() const
{
    return m_writeChargeLimit;
}

QModbusReply *AlphatecWallboxModbusTcpConnection::setWriteChargeLimit(quint16 writeChargeLimit)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(writeChargeLimit);
    qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "--> Write \"maxIntensitySocket\" register:" << 5 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 5, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

bool AlphatecWallboxModbusTcpConnection::initialize()
{
    if (!m_reachable) {
        qCWarning(dcAlphatecWallboxModbusTcpConnection()) << "Tried to initialize but the device is not to be reachable.";
        return false;
    }
    // No init registers defined. Nothing to be done and we are finished.
    emit initializationFinished(true);
    return true;
}

bool AlphatecWallboxModbusTcpConnection::update()
{
    if (!connected())
        return false;

    if (!m_pendingUpdateReplies.isEmpty()) {
        qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "Tried to update but there are still some update replies pending. Waiting for them to be finished...";
        return true;
    }

    QModbusReply *reply = nullptr;

    // Read EvseStatus
    qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "--> Read \"EvseStatus\" register:" << 0 << "size:" << 1;
    reply = readEvseStatus();
    if (!reply) {
        qCWarning(dcAlphatecWallboxModbusTcpConnection()) << "Error occurred while reading \"EvseStatus\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "<-- Response from \"EvseStatus\" register" << 0 << "size:" << 1 << unit.values();
        processEvseStatusRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlphatecWallboxModbusTcpConnection()) << "Modbus reply error occurred while reading \"EvseStatus\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read chargePower
    qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "--> Read \"chargePower\" register:" << 2 << "size:" << 1;
    reply = readChargePower();
    if (!reply) {
        qCWarning(dcAlphatecWallboxModbusTcpConnection()) << "Error occurred while reading \"chargePower\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "<-- Response from \"chargePower\" register" << 2 << "size:" << 1 << unit.values();
        processChargePowerRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlphatecWallboxModbusTcpConnection()) << "Modbus reply error occurred while reading \"chargePower\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    // Read maxIntensitySocket
    qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "--> Read \"maxIntensitySocket\" register:" << 5 << "size:" << 1;
    reply = readWriteChargeLimit();
    if (!reply) {
        qCWarning(dcAlphatecWallboxModbusTcpConnection()) << "Error occurred while reading \"maxIntensitySocket\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "<-- Response from \"maxIntensitySocket\" register" << 5 << "size:" << 1 << unit.values();
        processWriteChargeLimitRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlphatecWallboxModbusTcpConnection()) << "Modbus reply error occurred while reading \"maxIntensitySocket\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
    return true;
}

void AlphatecWallboxModbusTcpConnection::updateEvseStatus()
{
    // Update registers from EvseStatus
    qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "--> Read \"EvseStatus\" register:" << 0 << "size:" << 1;
    QModbusReply *reply = readEvseStatus();
    if (!reply) {
        qCWarning(dcAlphatecWallboxModbusTcpConnection()) << "Error occurred while reading \"EvseStatus\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "<-- Response from \"EvseStatus\" register" << 0 << "size:" << 1 << unit.values();
            processEvseStatusRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlphatecWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"EvseStatus\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlphatecWallboxModbusTcpConnection::updateChargePower()
{
    // Update registers from chargePower
    qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "--> Read \"chargePower\" register:" << 2 << "size:" << 1;
    QModbusReply *reply = readChargePower();
    if (!reply) {
        qCWarning(dcAlphatecWallboxModbusTcpConnection()) << "Error occurred while reading \"chargePower\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "<-- Response from \"chargePower\" register" << 2 << "size:" << 1 << unit.values();
            processChargePowerRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlphatecWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"chargePower\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlphatecWallboxModbusTcpConnection::updateWriteChargeLimit()
{
    // Update registers from maxIntensitySocket
    qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "--> Read \"maxIntensitySocket\" register:" << 5 << "size:" << 1;
    QModbusReply *reply = readWriteChargeLimit();
    if (!reply) {
        qCWarning(dcAlphatecWallboxModbusTcpConnection()) << "Error occurred while reading \"maxIntensitySocket\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "<-- Response from \"maxIntensitySocket\" register" << 5 << "size:" << 1 << unit.values();
            processWriteChargeLimitRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlphatecWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"maxIntensitySocket\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

QModbusReply *AlphatecWallboxModbusTcpConnection::readEvseStatus()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 0, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlphatecWallboxModbusTcpConnection::readChargePower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 2, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlphatecWallboxModbusTcpConnection::readWriteChargeLimit()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 5, 1);
    return sendReadRequest(request, m_slaveId);
}

void AlphatecWallboxModbusTcpConnection::processEvseStatusRegisterValues(const QVector<quint16> values)
{
    quint32 receivedEvseStatus = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit evseStatusReadFinished(receivedEvseStatus);

    if (m_evseStatus != receivedEvseStatus) {
        m_evseStatus = receivedEvseStatus;
        emit evseStatusChanged(m_evseStatus);
    }
}

void AlphatecWallboxModbusTcpConnection::processChargePowerRegisterValues(const QVector<quint16> values)
{
    quint32 receivedChargePower = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit chargePowerReadFinished(receivedChargePower);

    if (m_chargePower != receivedChargePower) {
        m_chargePower = receivedChargePower;
        emit chargePowerChanged(m_chargePower);
    }
}

void AlphatecWallboxModbusTcpConnection::processWriteChargeLimitRegisterValues(const QVector<quint16> values)
{
    quint16 receivedWriteChargeLimit = ModbusDataUtils::convertToUInt16(values);
    emit writeChargeLimitReadFinished(receivedWriteChargeLimit);

    if (m_writeChargeLimit != receivedWriteChargeLimit) {
        m_writeChargeLimit = receivedWriteChargeLimit;
        emit writeChargeLimitChanged(m_writeChargeLimit);
    }
}

void AlphatecWallboxModbusTcpConnection::handleModbusError(QModbusDevice::Error error)
{
    if (error == QModbusDevice::NoError) {
        // Reset the communication counter and we know we can reach the device
        m_communicationFailedCounter = 0;
        if (!m_communicationWorking)
            qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "Received a reply without any errors. The communication with the device seems to work now.";

        m_communicationWorking = true;
        evaluateReachableState();
    } else {
        m_communicationFailedCounter++;
        if (m_communicationWorking && m_communicationFailedCounter >= m_communicationFailedMax) {
            m_communicationWorking = false;
            qCWarning(dcAlphatecWallboxModbusTcpConnection()) << "Received" << m_communicationFailedCounter << "errors while communicating with the RTU master. Mark as not reachable until the communication works again.";
            evaluateReachableState();
        }
    }
}

void AlphatecWallboxModbusTcpConnection::testReachability()
{
    if (m_checkRechableReply)
        return;

    // Try to read the check reachability register evseStatus in order to verify if the communication is working or not.
    qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "--> Test reachability by reading \"EvseStatus\" register:" << 0 << "size:" << 1;
    m_checkRechableReply = readEvseStatus();
    if (!m_checkRechableReply) {
        qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "Error occurred verifying reachability by reading \"EvseStatus\" register";
        onReachabilityCheckFailed();
        return;
    }

    if (m_checkRechableReply->isFinished()) {
        m_checkRechableReply->deleteLater(); // Broadcast reply returns immediatly
        m_checkRechableReply = nullptr;
        onReachabilityCheckFailed();
        return;
    }

    connect(m_checkRechableReply, &QModbusReply::finished, this, [this](){
        handleModbusError(m_checkRechableReply->error());
        if (m_checkRechableReply->error() != QModbusDevice::NoError)
            onReachabilityCheckFailed();

        m_checkRechableReply->deleteLater();
        m_checkRechableReply = nullptr;
    });

    connect(m_checkRechableReply, &QModbusReply::errorOccurred, this, [this] (QModbusDevice::Error error){
        qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "Modbus reply error occurred while verifying reachability by reading \"EvseStatus\" register" << error << m_checkRechableReply->errorString();
    });
}

void AlphatecWallboxModbusTcpConnection::verifyInitFinished()
{
    if (m_pendingInitReplies.isEmpty()) {
        finishInitialization(true);
    }
}

void AlphatecWallboxModbusTcpConnection::finishInitialization(bool success)
{
    if (success) {
        qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "Initialization finished of AlphatecWallboxModbusTcpConnection" << hostAddress().toString() << "finished successfully";
    } else {
        qCWarning(dcAlphatecWallboxModbusTcpConnection()) << "Initialization finished of AlphatecWallboxModbusTcpConnection" << hostAddress().toString() << "failed.";
    }

    // Cleanup init
    delete m_initObject;
    m_initObject = nullptr;
    m_pendingInitReplies.clear();

    emit initializationFinished(success);
}

void AlphatecWallboxModbusTcpConnection::verifyUpdateFinished()
{
    if (m_pendingUpdateReplies.isEmpty()) {
        emit updateFinished();
    }
}

void AlphatecWallboxModbusTcpConnection::onReachabilityCheckFailed()
{
    m_checkReachableRetriesCount++;

    if (m_checkReachableRetriesCount <= m_checkReachableRetries) {
        qCDebug(dcAlphatecWallboxModbusTcpConnection()) << "Reachability test failed. Retry in on second" << m_checkReachableRetriesCount << "/" << m_checkReachableRetries;
        QTimer::singleShot(1000, this, &AlphatecWallboxModbusTcpConnection::testReachability);
        return;
    }

    // The test reachability method failed, not retrying any more
    emit checkReachabilityFailed();
}

void AlphatecWallboxModbusTcpConnection::evaluateReachableState()
{
    bool reachable = m_communicationWorking && connected();
    if (m_reachable == reachable)
        return;

    m_reachable = reachable;
    emit reachableChanged(m_reachable);
    m_checkReachableRetriesCount = 0;
}

QDebug operator<<(QDebug debug, AlphatecWallboxModbusTcpConnection *alphatecWallboxModbusTcpConnection)
{
    debug.nospace().noquote() << "AlphatecWallboxModbusTcpConnection(" << alphatecWallboxModbusTcpConnection->hostAddress().toString() << ":" << alphatecWallboxModbusTcpConnection->port() << ")" << "\n";
    debug.nospace().noquote() << "    - EvseStatus: " << alphatecWallboxModbusTcpConnection->evseStatus() << "\n";
    debug.nospace().noquote() << "    - chargePower: " << alphatecWallboxModbusTcpConnection->chargePower() << " [Ampere]" << "\n";
    debug.nospace().noquote() << "    - maxIntensitySocket: " << alphatecWallboxModbusTcpConnection->writeChargeLimit() << " [Ampere]" << "\n";
    return debug.quote().space();
}

