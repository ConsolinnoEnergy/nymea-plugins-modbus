/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Copyright 2013 - 2024, nymea GmbH
* Contact: contact@nymea.io
*
* This fileDescriptor is part of nymea.
* This project including source code and documentation is protected by
* copyright law, and remains the property of nymea GmbH. All rights, including
* reproduction, publication, editing and translation, are reserved. The use of
* this project is subject to the terms of a license agreement to be concluded
* with nymea GmbH in accordance with the terms of use of nymea GmbH, available
* under https://nymea.io/license
*
* GNU Lesser General Public License Usage
* Alternatively, this project may be redistributed and/or modified under the
* terms of the GNU Lesser General Public License as published by the Free
* Software Foundation; version 3. This project is distributed in the hope that
* it will be useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this project. If not, see <https://www.gnu.org/licenses/>.
*
* For any further details and any questions please contact us under
* contact@nymea.io or see our FAQ/Licensing Information on
* https://nymea.io/license/faq
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WARNING
*
* This file has been autogenerated. Any changes in this file may be overwritten.
* If you want to change something, update the register json or the tool.
* Nicht ganz richtig. Diese Datei wurde autogeneriert, und dann abgewandelt. Ist jetzt
* also nicht mehr autogeneriert, und wird auch nicht überschrieben beim Kompilieren.
* Bei änderungen in solax-registers.json oder im Python Script das die Modbus Klassen
* erzeugt muss dann diese Datei nachbearbeitet werden.
*
* Die Änderungen sind beschränkt auf die Methoden update() und initialize().
* Der Solax Inverter hat das Problem, das bei Modbus TCP Nymea die Anfragen schneller
* raus schickt, als sie der Inverter bearbeiten kann. Dies führt zu Modbus Fehlern,
* es kommen dann gar keine Antworten mehr vom Wechselrichter.
* Die Lösung dafür ist, die nächste Modbus Anfrage erst dann los zu schicken, wenn
* die vorherige abgearbeitet wurde. Die Methoden update() und initialize() wurden
* aufgesplittet, so das jede Modbusanfrage in einer eigenen Methode sitzt.
* Die erste Modbusanfrage wird losgeschickt. Wenn deren Antwort da ist, triggert das
* die nächste Methode mit der nächsten Modbusanfrage.
*
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


#include "lambdamodbustcpconnection.h"
#include <loggingcategories.h>
#include <math.h>
#include <QTimer>

NYMEA_LOGGING_CATEGORY(dcLambdaModbusTcpConnection, "LambdaModbusTcpConnection")

LambdaModbusTcpConnection::LambdaModbusTcpConnection(const QHostAddress &hostAddress, uint port, quint16 slaveId, QObject *parent) :
    ModbusTCPMaster(hostAddress, port, parent),
    m_slaveId(slaveId)
{
    connect(this, &ModbusTCPMaster::connectionStateChanged, this, [this](bool status){
        if (status) {
           qCDebug(dcLambdaModbusTcpConnection()) << "Modbus TCP connection" << m_hostAddress.toString() << "connected. Start testing if the connection is reachable...";
            // Cleanup before starting to initialize
            m_pendingInitReplies.clear();
            m_pendingUpdateReplies.clear();
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
            testReachability();
        } else {
            qCWarning(dcLambdaModbusTcpConnection()) << "Modbus TCP connection diconnected from" << m_hostAddress.toString() << ". The connection is not reachable any more.";
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
        }

        evaluateReachableState();
    });
}

bool LambdaModbusTcpConnection::reachable() const
{
    return m_reachable;
}

uint LambdaModbusTcpConnection::checkReachableRetries() const
{
    return m_checkReachableRetries;
}

void LambdaModbusTcpConnection::setCheckReachableRetries(uint checkReachableRetries)
{
    if (m_checkReachableRetries == checkReachableRetries)
        return;

    m_checkReachableRetries = checkReachableRetries;
    emit checkReachableRetriesChanged(m_checkReachableRetries);
}

ModbusDataUtils::ByteOrder LambdaModbusTcpConnection::endianness() const
{
    return m_endianness;
}

void LambdaModbusTcpConnection::setEndianness(ModbusDataUtils::ByteOrder endianness)
{
    if (m_endianness == endianness)
        return;

    m_endianness = endianness;
    emit endiannessChanged(m_endianness);
}

float LambdaModbusTcpConnection::outdoorTemperature() const
{
    return m_outdoorTemperature;
}

quint16 LambdaModbusTcpConnection::powerDemand() const
{
    return m_powerDemand;
}

QModbusReply *LambdaModbusTcpConnection::setPowerDemand(quint16 powerDemand)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(powerDemand);
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Write \"power demand written by EMS\" register:" << 103 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 103, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

LambdaModbusTcpConnection::SystemStatus LambdaModbusTcpConnection::systemStatus() const
{
    return m_systemStatus;
}

qint16 LambdaModbusTcpConnection::powerActual() const
{
    return m_powerActual;
}

qint16 LambdaModbusTcpConnection::powerSetpoint() const
{
    return m_powerSetpoint;
}

float LambdaModbusTcpConnection::flowTemperature() const
{
    return m_flowTemperature;
}

float LambdaModbusTcpConnection::returnTemperature() const
{
    return m_returnTemperature;
}

float LambdaModbusTcpConnection::heatSourceInletTemperature() const
{
    return m_heatSourceInletTemperature;
}

float LambdaModbusTcpConnection::heatSourceOutletTemperature() const
{
    return m_heatSourceOutletTemperature;
}

float LambdaModbusTcpConnection::roomTemperature() const
{
    return m_roomTemperature;
}

float LambdaModbusTcpConnection::hotWaterTemperature() const
{
    return m_hotWaterTemperature;
}

bool LambdaModbusTcpConnection::initialize()
{
    if (!m_reachable) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Tried to initialize but the device is not to be reachable.";
        return false;
    }
    // No init registers defined. Nothing to be done and we are finished.
    emit initializationFinished(true);
    return true;
}

bool LambdaModbusTcpConnection::update()
{
    if (!connected())
        return false;

    if (!m_pendingUpdateReplies.isEmpty()) {
        qCDebug(dcLambdaModbusTcpConnection()) << "Tried to update but there are still some update replies pending. Waiting for them to be finished...";
        return true;
    }

    QModbusReply *reply = nullptr;

    // Read Outdoor temperature
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Outdoor temperature\" register:" << 3 << "size:" << 1;
    reply = readOutdoorTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Outdoor temperature\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Outdoor temperature\" register" << 3 << "size:" << 1 << unit.values();
        processOutdoorTemperatureRegisterValues(unit.values());
        update2();//JoOb-previous: verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while reading \"Outdoor temperature\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
    return true;
}

// Split up update, so that modbus calls are sent one after the other.
void LambdaModbusTcpConnection::update2()
{
    QModbusReply *reply = nullptr;

    // Read power demand written by EMS
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"power demand written by EMS\" register:" << 103 << "size:" << 1;
    reply = readPowerDemand();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"power demand written by EMS\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"power demand written by EMS\" register" << 103 << "size:" << 1 << unit.values();
        processPowerDemandRegisterValues(unit.values());
        update3();//JoOb-previous: verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while reading \"power demand written by EMS\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::update3()
{
    QModbusReply *reply = nullptr;


    // Read System status
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"System status\" register:" << 1003 << "size:" << 1;
    reply = readSystemStatus();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"System status\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"System status\" register" << 1003 << "size:" << 1 << unit.values();
        processSystemStatusRegisterValues(unit.values());
        update4();//JoOb-previous: verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while reading \"System status\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}



void LambdaModbusTcpConnection::update4()
    {
        QModbusReply *reply = nullptr;
        
    // Read lineTemp
    reply = readBlockLineTemp();
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"lineTemp\" registers from:" << 1005 << "size:" << 2;
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"lineTemp\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"lineTemp\" register" << 1005 << "size:" << 2 << blockValues;
        processFlowTemperatureRegisterValues(blockValues.mid(0, 1));
        processReturnTemperatureRegisterValues(blockValues.mid(1, 1));
        update5();//JoOb-previous: verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"lineTemp\" registers" << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::update5()
    {
        QModbusReply *reply = nullptr;

    // Read heatSource
    reply = readBlockHeatSource();
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"heatSource\" registers from:" << 1008 << "size:" << 2;
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"heatSource\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"heatSource\" register" << 1008 << "size:" << 2 << blockValues;
        processHeatSourceInletTemperatureRegisterValues(blockValues.mid(0, 1));
        processHeatSourceOutletTemperatureRegisterValues(blockValues.mid(1, 1));
        update6();//JoOb-previous: verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"heatSource\" registers" << error << reply->errorString();
    });

}

void LambdaModbusTcpConnection::update6()
    {
        QModbusReply *reply = nullptr;

    // Read heatingCircuit
    reply = readBlockHeatingCircuit();
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"heatingCircuit\" registers from:" << 5005 << "size:" << 2;
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"heatingCircuit\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"heatingCircuit\" register" << 5005 << "size:" << 2 << blockValues;
        processRoomTemperatureRegisterValues(blockValues.mid(0, 1));
        processHotWaterTemperatureRegisterValues(blockValues.mid(1, 1));
        update7();//JoOb-previous: verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"heatingCircuit\" registers" << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::update7()
    {
        QModbusReply *reply = nullptr;

    // Read power
    reply = readBlockPower();
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"power\" registers from:" << 104 << "size:" << 2;
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"power\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"power\" register" << 104 << "size:" << 2 << blockValues;
        processPowerActualRegisterValues(blockValues.mid(0, 1));
        processPowerSetpointRegisterValues(blockValues.mid(1, 1));
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"power\" registers" << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateOutdoorTemperature()
{
    // Update registers from Outdoor temperature
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Outdoor temperature\" register:" << 3 << "size:" << 1;
    QModbusReply *reply = readOutdoorTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Outdoor temperature\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Outdoor temperature\" register" << 3 << "size:" << 1 << unit.values();
            processOutdoorTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Outdoor temperature\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updatePowerDemand()
{
    // Update registers from power demand written by EMS
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"power demand written by EMS\" register:" << 103 << "size:" << 1;
    QModbusReply *reply = readPowerDemand();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"power demand written by EMS\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"power demand written by EMS\" register" << 103 << "size:" << 1 << unit.values();
            processPowerDemandRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"power demand written by EMS\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateSystemStatus()
{
    // Update registers from System status
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"System status\" register:" << 1003 << "size:" << 1;
    QModbusReply *reply = readSystemStatus();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"System status\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"System status\" register" << 1003 << "size:" << 1 << unit.values();
            processSystemStatusRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"System status\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updatePowerActual()
{
    // Update registers from actual power consumption of all configured heat pumps
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"actual power consumption of all configured heat pumps\" register:" << 104 << "size:" << 1;
    QModbusReply *reply = readPowerActual();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"actual power consumption of all configured heat pumps\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"actual power consumption of all configured heat pumps\" register" << 104 << "size:" << 1 << unit.values();
            processPowerActualRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"actual power consumption of all configured heat pumps\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updatePowerSetpoint()
{
    // Update registers from realized power consumption setpoint of all configured heat pumps
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"realized power consumption setpoint of all configured heat pumps\" register:" << 105 << "size:" << 1;
    QModbusReply *reply = readPowerSetpoint();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"realized power consumption setpoint of all configured heat pumps\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"realized power consumption setpoint of all configured heat pumps\" register" << 105 << "size:" << 1 << unit.values();
            processPowerSetpointRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"realized power consumption setpoint of all configured heat pumps\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateFlowTemperature()
{
    // Update registers from Flow
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Flow\" register:" << 1005 << "size:" << 1;
    QModbusReply *reply = readFlowTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Flow\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Flow\" register" << 1005 << "size:" << 1 << unit.values();
            processFlowTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Flow\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateReturnTemperature()
{
    // Update registers from Return
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Return\" register:" << 1006 << "size:" << 1;
    QModbusReply *reply = readReturnTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Return\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Return\" register" << 1006 << "size:" << 1 << unit.values();
            processReturnTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Return\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateHeatSourceInletTemperature()
{
    // Update registers from Heat source inlet temperature
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Heat source inlet temperature\" register:" << 1008 << "size:" << 1;
    QModbusReply *reply = readHeatSourceInletTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Heat source inlet temperature\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Heat source inlet temperature\" register" << 1008 << "size:" << 1 << unit.values();
            processHeatSourceInletTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Heat source inlet temperature\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateHeatSourceOutletTemperature()
{
    // Update registers from Heat source outlet temperature
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Heat source outlet temperature\" register:" << 1009 << "size:" << 1;
    QModbusReply *reply = readHeatSourceOutletTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Heat source outlet temperature\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Heat source outlet temperature\" register" << 1009 << "size:" << 1 << unit.values();
            processHeatSourceOutletTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Heat source outlet temperature\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateRoomTemperature()
{
    // Update registers from actual temperatur room device sensor
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"actual temperatur room device sensor\" register:" << 5005 << "size:" << 1;
    QModbusReply *reply = readRoomTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"actual temperatur room device sensor\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"actual temperatur room device sensor\" register" << 5005 << "size:" << 1 << unit.values();
            processRoomTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"actual temperatur room device sensor\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateHotWaterTemperature()
{
    // Update registers from Hot water temperature
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read \"Hot water temperature\" register:" << 5006 << "size:" << 1;
    QModbusReply *reply = readHotWaterTemperature();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading \"Hot water temperature\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from \"Hot water temperature\" register" << 5006 << "size:" << 1 << unit.values();
            processHotWaterTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating \"Hot water temperature\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updatePowerBlock()
{
    // Update register block "power"
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"power\" registers from:" << 104 << "size:" << 2;
    QModbusReply *reply = readBlockPower();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"power\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"power\" register" << 104 << "size:" << 2 << blockValues;
            processPowerActualRegisterValues(blockValues.mid(0, 1));
            processPowerSetpointRegisterValues(blockValues.mid(1, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"power\" registers" << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateLineTempBlock()
{
    // Update register block "lineTemp"
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"lineTemp\" registers from:" << 1005 << "size:" << 2;
    QModbusReply *reply = readBlockLineTemp();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"lineTemp\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"lineTemp\" register" << 1005 << "size:" << 2 << blockValues;
            processFlowTemperatureRegisterValues(blockValues.mid(0, 1));
            processReturnTemperatureRegisterValues(blockValues.mid(1, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"lineTemp\" registers" << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateHeatSourceBlock()
{
    // Update register block "heatSource"
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"heatSource\" registers from:" << 1008 << "size:" << 2;
    QModbusReply *reply = readBlockHeatSource();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"heatSource\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"heatSource\" register" << 1008 << "size:" << 2 << blockValues;
            processHeatSourceInletTemperatureRegisterValues(blockValues.mid(0, 1));
            processHeatSourceOutletTemperatureRegisterValues(blockValues.mid(1, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"heatSource\" registers" << error << reply->errorString();
    });
}

void LambdaModbusTcpConnection::updateHeatingCircuitBlock()
{
    // Update register block "heatingCircuit"
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Read block \"heatingCircuit\" registers from:" << 5005 << "size:" << 2;
    QModbusReply *reply = readBlockHeatingCircuit();
    if (!reply) {
        qCWarning(dcLambdaModbusTcpConnection()) << "Error occurred while reading block \"heatingCircuit\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcLambdaModbusTcpConnection()) << "<-- Response from reading block \"heatingCircuit\" register" << 5005 << "size:" << 2 << blockValues;
            processRoomTemperatureRegisterValues(blockValues.mid(0, 1));
            processHotWaterTemperatureRegisterValues(blockValues.mid(1, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while updating block \"heatingCircuit\" registers" << error << reply->errorString();
    });
}

QModbusReply *LambdaModbusTcpConnection::readOutdoorTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 3, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readPowerDemand()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 103, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readSystemStatus()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1003, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readPowerActual()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 104, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readPowerSetpoint()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 105, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readFlowTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1005, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readReturnTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1006, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readHeatSourceInletTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1008, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readHeatSourceOutletTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1009, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readRoomTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 5005, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readHotWaterTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 5006, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readBlockPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 104, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readBlockLineTemp()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1005, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readBlockHeatSource()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1008, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *LambdaModbusTcpConnection::readBlockHeatingCircuit()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 5005, 2);
    return sendReadRequest(request, m_slaveId);
}

void LambdaModbusTcpConnection::processOutdoorTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedOutdoorTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit outdoorTemperatureReadFinished(receivedOutdoorTemperature);

    if (m_outdoorTemperature != receivedOutdoorTemperature) {
        m_outdoorTemperature = receivedOutdoorTemperature;
        emit outdoorTemperatureChanged(m_outdoorTemperature);
    }
}

void LambdaModbusTcpConnection::processPowerDemandRegisterValues(const QVector<quint16> values)
{
    quint16 receivedPowerDemand = ModbusDataUtils::convertToUInt16(values);
    emit powerDemandReadFinished(receivedPowerDemand);

    if (m_powerDemand != receivedPowerDemand) {
        m_powerDemand = receivedPowerDemand;
        emit powerDemandChanged(m_powerDemand);
    }
}

void LambdaModbusTcpConnection::processSystemStatusRegisterValues(const QVector<quint16> values)
{
    SystemStatus receivedSystemStatus = static_cast<SystemStatus>(ModbusDataUtils::convertToUInt16(values));
    emit systemStatusReadFinished(receivedSystemStatus);

    if (m_systemStatus != receivedSystemStatus) {
        m_systemStatus = receivedSystemStatus;
        emit systemStatusChanged(m_systemStatus);
    }
}

void LambdaModbusTcpConnection::processPowerActualRegisterValues(const QVector<quint16> values)
{
    qint16 receivedPowerActual = ModbusDataUtils::convertToInt16(values);
    emit powerActualReadFinished(receivedPowerActual);

    if (m_powerActual != receivedPowerActual) {
        m_powerActual = receivedPowerActual;
        emit powerActualChanged(m_powerActual);
    }
}

void LambdaModbusTcpConnection::processPowerSetpointRegisterValues(const QVector<quint16> values)
{
    qint16 receivedPowerSetpoint = ModbusDataUtils::convertToInt16(values);
    emit powerSetpointReadFinished(receivedPowerSetpoint);

    if (m_powerSetpoint != receivedPowerSetpoint) {
        m_powerSetpoint = receivedPowerSetpoint;
        emit powerSetpointChanged(m_powerSetpoint);
    }
}

void LambdaModbusTcpConnection::processFlowTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedFlowTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -2);
    emit flowTemperatureReadFinished(receivedFlowTemperature);

    if (m_flowTemperature != receivedFlowTemperature) {
        m_flowTemperature = receivedFlowTemperature;
        emit flowTemperatureChanged(m_flowTemperature);
    }
}

void LambdaModbusTcpConnection::processReturnTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedReturnTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -2);
    emit returnTemperatureReadFinished(receivedReturnTemperature);

    if (m_returnTemperature != receivedReturnTemperature) {
        m_returnTemperature = receivedReturnTemperature;
        emit returnTemperatureChanged(m_returnTemperature);
    }
}

void LambdaModbusTcpConnection::processHeatSourceInletTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedHeatSourceInletTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -2);
    emit heatSourceInletTemperatureReadFinished(receivedHeatSourceInletTemperature);

    if (m_heatSourceInletTemperature != receivedHeatSourceInletTemperature) {
        m_heatSourceInletTemperature = receivedHeatSourceInletTemperature;
        emit heatSourceInletTemperatureChanged(m_heatSourceInletTemperature);
    }
}

void LambdaModbusTcpConnection::processHeatSourceOutletTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedHeatSourceOutletTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -2);
    emit heatSourceOutletTemperatureReadFinished(receivedHeatSourceOutletTemperature);

    if (m_heatSourceOutletTemperature != receivedHeatSourceOutletTemperature) {
        m_heatSourceOutletTemperature = receivedHeatSourceOutletTemperature;
        emit heatSourceOutletTemperatureChanged(m_heatSourceOutletTemperature);
    }
}

void LambdaModbusTcpConnection::processRoomTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedRoomTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit roomTemperatureReadFinished(receivedRoomTemperature);

    if (m_roomTemperature != receivedRoomTemperature) {
        m_roomTemperature = receivedRoomTemperature;
        emit roomTemperatureChanged(m_roomTemperature);
    }
}

void LambdaModbusTcpConnection::processHotWaterTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedHotWaterTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit hotWaterTemperatureReadFinished(receivedHotWaterTemperature);

    if (m_hotWaterTemperature != receivedHotWaterTemperature) {
        m_hotWaterTemperature = receivedHotWaterTemperature;
        emit hotWaterTemperatureChanged(m_hotWaterTemperature);
    }
}

void LambdaModbusTcpConnection::handleModbusError(QModbusDevice::Error error)
{
    if (error == QModbusDevice::NoError) {
        // Reset the communication counter and we know we can reach the device
        m_communicationFailedCounter = 0;
        if (!m_communicationWorking)
            qCDebug(dcLambdaModbusTcpConnection()) << "Received a reply without any errors. The communication with the device seems to work now.";

        m_communicationWorking = true;
        evaluateReachableState();
    } else {
        m_communicationFailedCounter++;
        if (m_communicationWorking && m_communicationFailedCounter >= m_communicationFailedMax) {
            m_communicationWorking = false;
            qCWarning(dcLambdaModbusTcpConnection()) << "Received" << m_communicationFailedCounter << "errors while communicating with the RTU master. Mark as not reachable until the communication works again.";
            evaluateReachableState();
        }
    }
}

void LambdaModbusTcpConnection::testReachability()
{
    if (m_checkRechableReply)
        return;

    // Try to read the check reachability register powerDemand in order to verify if the communication is working or not.
    qCDebug(dcLambdaModbusTcpConnection()) << "--> Test reachability by reading \"power demand written by EMS\" register:" << 103 << "size:" << 1;
    m_checkRechableReply = readPowerDemand();
    if (!m_checkRechableReply) {
        qCDebug(dcLambdaModbusTcpConnection()) << "Error occurred verifying reachability by reading \"power demand written by EMS\" register";
        onReachabilityCheckFailed();
        return;
    }

    if (m_checkRechableReply->isFinished()) {
        m_checkRechableReply->deleteLater(); // Broadcast reply returns immediatly
        m_checkRechableReply = nullptr;
        onReachabilityCheckFailed();
        return;
    }

    connect(m_checkRechableReply, &QModbusReply::finished, this, [this](){
        handleModbusError(m_checkRechableReply->error());
        if (m_checkRechableReply->error() != QModbusDevice::NoError)
            onReachabilityCheckFailed();

        m_checkRechableReply->deleteLater();
        m_checkRechableReply = nullptr;
    });

    connect(m_checkRechableReply, &QModbusReply::errorOccurred, this, [this] (QModbusDevice::Error error){
        qCDebug(dcLambdaModbusTcpConnection()) << "Modbus reply error occurred while verifying reachability by reading \"power demand written by EMS\" register" << error << m_checkRechableReply->errorString();
    });
}

void LambdaModbusTcpConnection::verifyInitFinished()
{
    if (m_pendingInitReplies.isEmpty()) {
        finishInitialization(true);
    }
}

void LambdaModbusTcpConnection::finishInitialization(bool success)
{
    if (success) {
        qCDebug(dcLambdaModbusTcpConnection()) << "Initialization finished of LambdaModbusTcpConnection" << hostAddress().toString() << "finished successfully";
    } else {
        qCWarning(dcLambdaModbusTcpConnection()) << "Initialization finished of LambdaModbusTcpConnection" << hostAddress().toString() << "failed.";
    }

    // Cleanup init
    delete m_initObject;
    m_initObject = nullptr;
    m_pendingInitReplies.clear();

    emit initializationFinished(success);
}

void LambdaModbusTcpConnection::verifyUpdateFinished()
{
    if (m_pendingUpdateReplies.isEmpty()) {
        emit updateFinished();
    }
}

void LambdaModbusTcpConnection::onReachabilityCheckFailed()
{
    m_checkReachableRetriesCount++;

    if (m_checkReachableRetriesCount <= m_checkReachableRetries) {
        qCDebug(dcLambdaModbusTcpConnection()) << "Reachability test failed. Retry in on second" << m_checkReachableRetriesCount << "/" << m_checkReachableRetries;
        QTimer::singleShot(1000, this, &LambdaModbusTcpConnection::testReachability);
        return;
    }

    // The test reachability method failed, not retrying any more
    emit checkReachabilityFailed();
}

void LambdaModbusTcpConnection::evaluateReachableState()
{
    bool reachable = m_communicationWorking && connected();
    if (m_reachable == reachable)
        return;

    m_reachable = reachable;
    emit reachableChanged(m_reachable);
    m_checkReachableRetriesCount = 0;
}

QDebug operator<<(QDebug debug, LambdaModbusTcpConnection *lambdaModbusTcpConnection)
{
    debug.nospace().noquote() << "LambdaModbusTcpConnection(" << lambdaModbusTcpConnection->hostAddress().toString() << ":" << lambdaModbusTcpConnection->port() << ")" << "\n";
    debug.nospace().noquote() << "    - Outdoor temperature: " << lambdaModbusTcpConnection->outdoorTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - power demand written by EMS: " << lambdaModbusTcpConnection->powerDemand() << " [W]" << "\n";
    debug.nospace().noquote() << "    - System status: " << lambdaModbusTcpConnection->systemStatus() << "\n";
    debug.nospace().noquote() << "    - actual power consumption of all configured heat pumps: " << lambdaModbusTcpConnection->powerActual() << " [W]" << "\n";
    debug.nospace().noquote() << "    - realized power consumption setpoint of all configured heat pumps: " << lambdaModbusTcpConnection->powerSetpoint() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Flow: " << lambdaModbusTcpConnection->flowTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - Return: " << lambdaModbusTcpConnection->returnTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - Heat source inlet temperature: " << lambdaModbusTcpConnection->heatSourceInletTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - Heat source outlet temperature: " << lambdaModbusTcpConnection->heatSourceOutletTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - actual temperatur room device sensor: " << lambdaModbusTcpConnection->roomTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - Hot water temperature: " << lambdaModbusTcpConnection->hotWaterTemperature() << " [°C]" << "\n";
    return debug.quote().space();
}

