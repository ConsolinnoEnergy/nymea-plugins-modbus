/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Copyright 2013 - 2025, nymea GmbH
* Contact: contact@nymea.io
*
* This fileDescriptor is part of nymea.
* This project including source code and documentation is protected by
* copyright law, and remains the property of nymea GmbH. All rights, including
* reproduction, publication, editing and translation, are reserved. The use of
* this project is subject to the terms of a license agreement to be concluded
* with nymea GmbH in accordance with the terms of use of nymea GmbH, available
* under https://nymea.io/license
*
* GNU Lesser General Public License Usage
* Alternatively, this project may be redistributed and/or modified under the
* terms of the GNU Lesser General Public License as published by the Free
* Software Foundation; version 3. This project is distributed in the hope that
* it will be useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this project. If not, see <https://www.gnu.org/licenses/>.
*
* For any further details and any questions please contact us under
* contact@nymea.io or see our FAQ/Licensing Information on
* https://nymea.io/license/faq
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WARNING
*
* This file has been autogenerated. Any changes in this file may be overwritten.
* If you want to change something, update the register json or the tool.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


#include "solaxevcstandalonemodbustcpconnection.h"
#include <loggingcategories.h>
#include <math.h>
#include <QTimer>

NYMEA_LOGGING_CATEGORY(dcSolaxEvcStandaloneModbusTcpConnection, "SolaxEvcStandaloneModbusTcpConnection")

SolaxEvcStandaloneModbusTcpConnection::SolaxEvcStandaloneModbusTcpConnection(const QHostAddress &hostAddress, uint port, quint16 slaveId, QObject *parent) :
    ModbusTcpMaster(hostAddress, port, parent),
    m_slaveId(slaveId)
{
    connect(this, &ModbusTcpMaster::connectionStateChanged, this, [this](bool status){
        if (status) {
           qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "Modbus TCP connection" << m_hostAddress.toString() << "connected. Start testing if the connection is reachable...";
            // Cleanup before starting to initialize
            m_pendingInitReplies.clear();
            m_pendingUpdateReplies.clear();
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
            testReachability();
        } else {
            qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Modbus TCP connection diconnected from" << m_hostAddress.toString() << ". The connection is not reachable any more.";
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
        }

        evaluateReachableState();
    });

}

bool SolaxEvcStandaloneModbusTcpConnection::reachable() const
{
    return m_reachable;
}

uint SolaxEvcStandaloneModbusTcpConnection::checkReachableRetries() const
{
    return m_checkReachableRetries;
}

void SolaxEvcStandaloneModbusTcpConnection::setCheckReachableRetries(uint checkReachableRetries)
{
    if (m_checkReachableRetries == checkReachableRetries)
        return;

    m_checkReachableRetries = checkReachableRetries;
    emit checkReachableRetriesChanged(m_checkReachableRetries);
}

ModbusDataUtils::ByteOrder SolaxEvcStandaloneModbusTcpConnection::endianness() const
{
    return m_endianness;
}

void SolaxEvcStandaloneModbusTcpConnection::setEndianness(ModbusDataUtils::ByteOrder endianness)
{
    if (m_endianness == endianness)
        return;

    m_endianness = endianness;
    emit endiannessChanged(m_endianness);
}

quint16 SolaxEvcStandaloneModbusTcpConnection::deviceMode() const
{
    return m_deviceMode;
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::setDeviceMode(quint16 deviceMode)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(deviceMode);
    qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "--> Write \"Device mode\" register:" << 1549 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1549, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

QString SolaxEvcStandaloneModbusTcpConnection::serialNumber() const
{
    return m_serialNumber;
}

quint16 SolaxEvcStandaloneModbusTcpConnection::firmwareVersion() const
{
    return m_firmwareVersion;
}

SolaxEvcStandaloneModbusTcpConnection::ControlCommand SolaxEvcStandaloneModbusTcpConnection::controlCommand() const
{
    return m_controlCommand;
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::setControlCommand(ControlCommand controlCommand)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt32(static_cast<quint32>((0x0C80 << 16) | controlCommand), ModbusDataUtils::ByteOrderLittleEndian);
    qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "--> Write \"Control command\" register:" << 1575 << "size:" << 2 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1575, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

float SolaxEvcStandaloneModbusTcpConnection::maxCurrent() const
{
    return m_maxCurrent;
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::setMaxCurrent(float maxCurrent)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt32(static_cast<quint32>(maxCurrent  * 1.0 / pow(10, -2)), ModbusDataUtils::ByteOrderLittleEndian);
    qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "--> Write \"Maximum current fast mode\" register:" << 1615 << "size:" << 2 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1615, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

float SolaxEvcStandaloneModbusTcpConnection::currentPhaseA() const
{
    return m_currentPhaseA;
}

float SolaxEvcStandaloneModbusTcpConnection::currentPhaseB() const
{
    return m_currentPhaseB;
}

float SolaxEvcStandaloneModbusTcpConnection::currentPhaseC() const
{
    return m_currentPhaseC;
}

float SolaxEvcStandaloneModbusTcpConnection::currentPe() const
{
    return m_currentPe;
}

quint16 SolaxEvcStandaloneModbusTcpConnection::powerPhaseA() const
{
    return m_powerPhaseA;
}

quint16 SolaxEvcStandaloneModbusTcpConnection::powerPhaseB() const
{
    return m_powerPhaseB;
}

quint16 SolaxEvcStandaloneModbusTcpConnection::powerPhaseC() const
{
    return m_powerPhaseC;
}

quint16 SolaxEvcStandaloneModbusTcpConnection::totalPower() const
{
    return m_totalPower;
}

float SolaxEvcStandaloneModbusTcpConnection::frequencyPhaseA() const
{
    return m_frequencyPhaseA;
}

float SolaxEvcStandaloneModbusTcpConnection::frequencyPhaseB() const
{
    return m_frequencyPhaseB;
}

float SolaxEvcStandaloneModbusTcpConnection::frequencyPhaseC() const
{
    return m_frequencyPhaseC;
}

float SolaxEvcStandaloneModbusTcpConnection::sessionEnergy() const
{
    return m_sessionEnergy;
}

float SolaxEvcStandaloneModbusTcpConnection::totalEnergy() const
{
    return m_totalEnergy;
}

SolaxEvcStandaloneModbusTcpConnection::State SolaxEvcStandaloneModbusTcpConnection::state() const
{
    return m_state;
}

quint32 SolaxEvcStandaloneModbusTcpConnection::faultCode() const
{
    return m_faultCode;
}

quint16 SolaxEvcStandaloneModbusTcpConnection::typeCase() const
{
    return m_typeCase;
}

quint16 SolaxEvcStandaloneModbusTcpConnection::typePower() const
{
    return m_typePower;
}

bool SolaxEvcStandaloneModbusTcpConnection::initialize()
{
    if (!m_reachable) {
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Tried to initialize but the device is not to be reachable.";
        return false;
    }
    if (m_initObject) {
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Tried to initialize but the init process is already running.";
        return false;
    }

    // Parent object for the init process
    m_initObject = new QObject(this);

    QModbusReply *reply = nullptr;

    // Read Version
    qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "--> Read init \"Version\" register:" << 1536 << "size:" << 14;
    reply = readSerialNumber();
    if (!reply) {
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Error occurred while reading \"Version\" registers from" << hostAddress().toString() << errorString();
        finishInitialization(false);
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, m_initObject, [this, reply](){
        handleModbusError(reply->error());
        m_pendingInitReplies.removeAll(reply);
        if (reply->error() != QModbusDevice::NoError) {
            finishInitialization(false);
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "<-- Response from init \"Version\" register" << 1536 << "size:" << 14 << unit.values();
        processSerialNumberRegisterValues(unit.values());
        initialize1();
    });

    connect(reply, &QModbusReply::errorOccurred, m_initObject, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Modbus reply error occurred while reading \"Version\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
    
    return true;
}

void SolaxEvcStandaloneModbusTcpConnection::initialize1()
{
    QModbusReply *reply = nullptr;

    // Read Firmware version
    qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "--> Read init \"Firmware version\" register:" << 37 << "size:" << 1;
    reply = readFirmwareVersion();
    if (!reply) {
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Error occurred while reading \"Firmware version\" registers from" << hostAddress().toString() << errorString();
        finishInitialization(false);
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, m_initObject, [this, reply](){
        handleModbusError(reply->error());
        m_pendingInitReplies.removeAll(reply);
        if (reply->error() != QModbusDevice::NoError) {
            finishInitialization(false);
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "<-- Response from init \"Firmware version\" register" << 37 << "size:" << 1 << unit.values();
        processFirmwareVersionRegisterValues(unit.values());
        verifyInitFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, m_initObject, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Modbus reply error occurred while reading \"Firmware version\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
    return;
}

bool SolaxEvcStandaloneModbusTcpConnection::update()
{
    if (!connected())
        return false;

    if (!m_pendingUpdateReplies.isEmpty()) {
        qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "Tried to update but there are still some update replies pending. Waiting for them to be finished...";
        return true;
    }

    QModbusReply *reply = nullptr;

    // Read Device mode
    qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "--> Read \"Device mode\" register:" << 1549 << "size:" << 1;
    reply = readDeviceMode();
    if (!reply) {
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Error occurred while reading \"Device mode\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "<-- Response from \"Device mode\" register" << 1549 << "size:" << 1 << unit.values();
        processDeviceModeRegisterValues(unit.values());
        update1();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Modbus reply error occurred while reading \"Device mode\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    return true;
}

void SolaxEvcStandaloneModbusTcpConnection::update1() {
    QModbusReply *reply = nullptr;

    // Read Control command
    qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "--> Read \"Control command\" register:" << 1575 << "size:" << 2;
    reply = readControlCommand();
    if (!reply) {
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Error occurred while reading \"Control command\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "<-- Response from \"Control command\" register" << 1575 << "size:" << 2 << unit.values();
        processControlCommandRegisterValues(unit.values());
        update2();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Modbus reply error occurred while reading \"Control command\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxEvcStandaloneModbusTcpConnection::update2() {
    QModbusReply *reply = nullptr;
    // Read Maximum current fast mode
    qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "--> Read \"Maximum current fast mode\" register:" << 1615 << "size:" << 2;
    reply = readMaxCurrent();
    if (!reply) {
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Error occurred while reading \"Maximum current fast mode\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "<-- Response from \"Maximum current fast mode\" register" << 1615 << "size:" << 2 << unit.values();
        processMaxCurrentRegisterValues(unit.values());
        update3();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Modbus reply error occurred while reading \"Maximum current fast mode\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxEvcStandaloneModbusTcpConnection::update3() {
    QModbusReply *reply = nullptr;
    // Read meterValues
    reply = readBlockMeterValues();
    qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "--> Read block \"meterValues\" registers from:" << 4 << "size:" << 14;
    if (!reply) {
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Error occurred while reading block \"meterValues\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "<-- Response from reading block \"meterValues\" register" << 4 << "size:" << 14 << blockValues;
        processCurrentPhaseARegisterValues(blockValues.mid(0, 1));
        processCurrentPhaseBRegisterValues(blockValues.mid(1, 1));
        processCurrentPhaseCRegisterValues(blockValues.mid(2, 1));
        processCurrentPeRegisterValues(blockValues.mid(3, 1));
        processPowerPhaseARegisterValues(blockValues.mid(4, 1));
        processPowerPhaseBRegisterValues(blockValues.mid(5, 1));
        processPowerPhaseCRegisterValues(blockValues.mid(6, 1));
        processTotalPowerRegisterValues(blockValues.mid(7, 1));
        processFrequencyPhaseARegisterValues(blockValues.mid(8, 1));
        processFrequencyPhaseBRegisterValues(blockValues.mid(9, 1));
        processFrequencyPhaseCRegisterValues(blockValues.mid(10, 1));
        processSessionEnergyRegisterValues(blockValues.mid(11, 1));
        processTotalEnergyRegisterValues(blockValues.mid(12, 2));
        update4();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Modbus reply error occurred while updating block \"meterValues\" registers" << error << reply->errorString();
    });
}

void SolaxEvcStandaloneModbusTcpConnection::update4() {
    QModbusReply *reply = nullptr;
    // Read wallboxStatus
    reply = readBlockWallboxStatus();
    qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "--> Read block \"wallboxStatus\" registers from:" << 29 << "size:" << 5;
    if (!reply) {
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Error occurred while reading block \"wallboxStatus\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "<-- Response from reading block \"wallboxStatus\" register" << 29 << "size:" << 5 << blockValues;
        processStateRegisterValues(blockValues.mid(0, 1));
        processFaultCodeRegisterValues(blockValues.mid(1, 2));
        processTypeCaseRegisterValues(blockValues.mid(3, 1));
        processTypePowerRegisterValues(blockValues.mid(4, 1));
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Modbus reply error occurred while updating block \"wallboxStatus\" registers" << error << reply->errorString();
    });

    return;
}

void SolaxEvcStandaloneModbusTcpConnection::updateDeviceMode()
{
    // Update registers from Device mode
    qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "--> Read \"Device mode\" register:" << 1549 << "size:" << 1;
    QModbusReply *reply = readDeviceMode();
    if (!reply) {
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Error occurred while reading \"Device mode\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "<-- Response from \"Device mode\" register" << 1549 << "size:" << 1 << unit.values();
            processDeviceModeRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Modbus reply error occurred while updating \"Device mode\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxEvcStandaloneModbusTcpConnection::updateControlCommand()
{
    // Update registers from Control command
    qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "--> Read \"Control command\" register:" << 1575 << "size:" << 2;
    QModbusReply *reply = readControlCommand();
    if (!reply) {
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Error occurred while reading \"Control command\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "<-- Response from \"Control command\" register" << 1575 << "size:" << 2 << unit.values();
            processControlCommandRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Modbus reply error occurred while updating \"Control command\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxEvcStandaloneModbusTcpConnection::updateMaxCurrent()
{
    // Update registers from Maximum current fast mode
    qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "--> Read \"Maximum current fast mode\" register:" << 1615 << "size:" << 2;
    QModbusReply *reply = readMaxCurrent();
    if (!reply) {
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Error occurred while reading \"Maximum current fast mode\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "<-- Response from \"Maximum current fast mode\" register" << 1615 << "size:" << 2 << unit.values();
            processMaxCurrentRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Modbus reply error occurred while updating \"Maximum current fast mode\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxEvcStandaloneModbusTcpConnection::updateMeterValuesBlock()
{
    // Update register block "meterValues"
    qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "--> Read block \"meterValues\" registers from:" << 4 << "size:" << 14;
    QModbusReply *reply = readBlockMeterValues();
    if (!reply) {
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Error occurred while reading block \"meterValues\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "<-- Response from reading block \"meterValues\" register" << 4 << "size:" << 14 << blockValues;
            processCurrentPhaseARegisterValues(blockValues.mid(0, 1));
            processCurrentPhaseBRegisterValues(blockValues.mid(1, 1));
            processCurrentPhaseCRegisterValues(blockValues.mid(2, 1));
            processCurrentPeRegisterValues(blockValues.mid(3, 1));
            processPowerPhaseARegisterValues(blockValues.mid(4, 1));
            processPowerPhaseBRegisterValues(blockValues.mid(5, 1));
            processPowerPhaseCRegisterValues(blockValues.mid(6, 1));
            processTotalPowerRegisterValues(blockValues.mid(7, 1));
            processFrequencyPhaseARegisterValues(blockValues.mid(8, 1));
            processFrequencyPhaseBRegisterValues(blockValues.mid(9, 1));
            processFrequencyPhaseCRegisterValues(blockValues.mid(10, 1));
            processSessionEnergyRegisterValues(blockValues.mid(11, 1));
            processTotalEnergyRegisterValues(blockValues.mid(12, 2));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Modbus reply error occurred while updating block \"meterValues\" registers" << error << reply->errorString();
    });
}

void SolaxEvcStandaloneModbusTcpConnection::updateWallboxStatusBlock()
{
    // Update register block "wallboxStatus"
    qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "--> Read block \"wallboxStatus\" registers from:" << 29 << "size:" << 5;
    QModbusReply *reply = readBlockWallboxStatus();
    if (!reply) {
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Error occurred while reading block \"wallboxStatus\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "<-- Response from reading block \"wallboxStatus\" register" << 29 << "size:" << 5 << blockValues;
            processStateRegisterValues(blockValues.mid(0, 1));
            processFaultCodeRegisterValues(blockValues.mid(1, 2));
            processTypeCaseRegisterValues(blockValues.mid(3, 1));
            processTypePowerRegisterValues(blockValues.mid(4, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Modbus reply error occurred while updating block \"wallboxStatus\" registers" << error << reply->errorString();
    });
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readDeviceMode()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1549, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readSerialNumber()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1536, 14);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readFirmwareVersion()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 37, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readControlCommand()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1575, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readMaxCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1615, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readCurrentPhaseA()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readCurrentPhaseB()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 5, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readCurrentPhaseC()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 6, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readCurrentPe()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 7, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readPowerPhaseA()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 8, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readPowerPhaseB()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 9, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readPowerPhaseC()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 10, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readTotalPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 11, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readFrequencyPhaseA()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 12, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readFrequencyPhaseB()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 13, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readFrequencyPhaseC()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 14, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readSessionEnergy()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 15, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readTotalEnergy()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 16, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 29, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readFaultCode()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 30, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readTypeCase()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 32, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readTypePower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 33, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readBlockMeterValues()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4, 14);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcStandaloneModbusTcpConnection::readBlockWallboxStatus()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 29, 5);
    return sendReadRequest(request, m_slaveId);
}

void SolaxEvcStandaloneModbusTcpConnection::processDeviceModeRegisterValues(const QVector<quint16> values)
{
    quint16 receivedDeviceMode = ModbusDataUtils::convertToUInt16(values);
    emit deviceModeReadFinished(receivedDeviceMode);

    if (m_deviceMode != receivedDeviceMode) {
        m_deviceMode = receivedDeviceMode;
        emit deviceModeChanged(m_deviceMode);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processSerialNumberRegisterValues(const QVector<quint16> values)
{
    QString receivedSerialNumber = ModbusDataUtils::convertToString(values);
    emit serialNumberReadFinished(receivedSerialNumber);

    if (m_serialNumber != receivedSerialNumber) {
        m_serialNumber = receivedSerialNumber;
        emit serialNumberChanged(m_serialNumber);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processFirmwareVersionRegisterValues(const QVector<quint16> values)
{
    quint16 receivedFirmwareVersion = ModbusDataUtils::convertToUInt16(values);
    emit firmwareVersionReadFinished(receivedFirmwareVersion);

    if (m_firmwareVersion != receivedFirmwareVersion) {
        m_firmwareVersion = receivedFirmwareVersion;
        emit firmwareVersionChanged(m_firmwareVersion);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processControlCommandRegisterValues(const QVector<quint16> values)
{
    ControlCommand receivedControlCommand = static_cast<ControlCommand>(ModbusDataUtils::convertToUInt32(values, m_endianness));
    emit controlCommandReadFinished(receivedControlCommand);

    if (m_controlCommand != receivedControlCommand) {
        m_controlCommand = receivedControlCommand;
        emit controlCommandChanged(m_controlCommand);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processMaxCurrentRegisterValues(const QVector<quint16> values)
{
    float receivedMaxCurrent = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -2);
    emit maxCurrentReadFinished(receivedMaxCurrent);

    if (m_maxCurrent != receivedMaxCurrent) {
        m_maxCurrent = receivedMaxCurrent;
        emit maxCurrentChanged(m_maxCurrent);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processCurrentPhaseARegisterValues(const QVector<quint16> values)
{
    float receivedCurrentPhaseA = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit currentPhaseAReadFinished(receivedCurrentPhaseA);

    if (m_currentPhaseA != receivedCurrentPhaseA) {
        m_currentPhaseA = receivedCurrentPhaseA;
        emit currentPhaseAChanged(m_currentPhaseA);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processCurrentPhaseBRegisterValues(const QVector<quint16> values)
{
    float receivedCurrentPhaseB = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit currentPhaseBReadFinished(receivedCurrentPhaseB);

    if (m_currentPhaseB != receivedCurrentPhaseB) {
        m_currentPhaseB = receivedCurrentPhaseB;
        emit currentPhaseBChanged(m_currentPhaseB);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processCurrentPhaseCRegisterValues(const QVector<quint16> values)
{
    float receivedCurrentPhaseC = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit currentPhaseCReadFinished(receivedCurrentPhaseC);

    if (m_currentPhaseC != receivedCurrentPhaseC) {
        m_currentPhaseC = receivedCurrentPhaseC;
        emit currentPhaseCChanged(m_currentPhaseC);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processCurrentPeRegisterValues(const QVector<quint16> values)
{
    float receivedCurrentPe = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -3);
    emit currentPeReadFinished(receivedCurrentPe);

    if (m_currentPe != receivedCurrentPe) {
        m_currentPe = receivedCurrentPe;
        emit currentPeChanged(m_currentPe);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processPowerPhaseARegisterValues(const QVector<quint16> values)
{
    quint16 receivedPowerPhaseA = ModbusDataUtils::convertToUInt16(values);
    emit powerPhaseAReadFinished(receivedPowerPhaseA);

    if (m_powerPhaseA != receivedPowerPhaseA) {
        m_powerPhaseA = receivedPowerPhaseA;
        emit powerPhaseAChanged(m_powerPhaseA);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processPowerPhaseBRegisterValues(const QVector<quint16> values)
{
    quint16 receivedPowerPhaseB = ModbusDataUtils::convertToUInt16(values);
    emit powerPhaseBReadFinished(receivedPowerPhaseB);

    if (m_powerPhaseB != receivedPowerPhaseB) {
        m_powerPhaseB = receivedPowerPhaseB;
        emit powerPhaseBChanged(m_powerPhaseB);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processPowerPhaseCRegisterValues(const QVector<quint16> values)
{
    quint16 receivedPowerPhaseC = ModbusDataUtils::convertToUInt16(values);
    emit powerPhaseCReadFinished(receivedPowerPhaseC);

    if (m_powerPhaseC != receivedPowerPhaseC) {
        m_powerPhaseC = receivedPowerPhaseC;
        emit powerPhaseCChanged(m_powerPhaseC);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processTotalPowerRegisterValues(const QVector<quint16> values)
{
    quint16 receivedTotalPower = ModbusDataUtils::convertToUInt16(values);
    emit totalPowerReadFinished(receivedTotalPower);

    if (m_totalPower != receivedTotalPower) {
        m_totalPower = receivedTotalPower;
        emit totalPowerChanged(m_totalPower);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processFrequencyPhaseARegisterValues(const QVector<quint16> values)
{
    float receivedFrequencyPhaseA = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit frequencyPhaseAReadFinished(receivedFrequencyPhaseA);

    if (m_frequencyPhaseA != receivedFrequencyPhaseA) {
        m_frequencyPhaseA = receivedFrequencyPhaseA;
        emit frequencyPhaseAChanged(m_frequencyPhaseA);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processFrequencyPhaseBRegisterValues(const QVector<quint16> values)
{
    float receivedFrequencyPhaseB = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit frequencyPhaseBReadFinished(receivedFrequencyPhaseB);

    if (m_frequencyPhaseB != receivedFrequencyPhaseB) {
        m_frequencyPhaseB = receivedFrequencyPhaseB;
        emit frequencyPhaseBChanged(m_frequencyPhaseB);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processFrequencyPhaseCRegisterValues(const QVector<quint16> values)
{
    float receivedFrequencyPhaseC = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit frequencyPhaseCReadFinished(receivedFrequencyPhaseC);

    if (m_frequencyPhaseC != receivedFrequencyPhaseC) {
        m_frequencyPhaseC = receivedFrequencyPhaseC;
        emit frequencyPhaseCChanged(m_frequencyPhaseC);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processSessionEnergyRegisterValues(const QVector<quint16> values)
{
    float receivedSessionEnergy = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit sessionEnergyReadFinished(receivedSessionEnergy);

    if (m_sessionEnergy != receivedSessionEnergy) {
        m_sessionEnergy = receivedSessionEnergy;
        emit sessionEnergyChanged(m_sessionEnergy);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processTotalEnergyRegisterValues(const QVector<quint16> values)
{
    float receivedTotalEnergy = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -1);
    emit totalEnergyReadFinished(receivedTotalEnergy);

    if (m_totalEnergy != receivedTotalEnergy) {
        m_totalEnergy = receivedTotalEnergy;
        emit totalEnergyChanged(m_totalEnergy);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processStateRegisterValues(const QVector<quint16> values)
{
    State receivedState = static_cast<State>(ModbusDataUtils::convertToUInt16(values));
    emit stateReadFinished(receivedState);

    if (m_state != receivedState) {
        m_state = receivedState;
        emit stateChanged(m_state);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processFaultCodeRegisterValues(const QVector<quint16> values)
{
    quint32 receivedFaultCode = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit faultCodeReadFinished(receivedFaultCode);

    if (m_faultCode != receivedFaultCode) {
        m_faultCode = receivedFaultCode;
        emit faultCodeChanged(m_faultCode);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processTypeCaseRegisterValues(const QVector<quint16> values)
{
    quint16 receivedTypeCase = ModbusDataUtils::convertToUInt16(values);
    emit typeCaseReadFinished(receivedTypeCase);

    if (m_typeCase != receivedTypeCase) {
        m_typeCase = receivedTypeCase;
        emit typeCaseChanged(m_typeCase);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::processTypePowerRegisterValues(const QVector<quint16> values)
{
    quint16 receivedTypePower = ModbusDataUtils::convertToUInt16(values);
    emit typePowerReadFinished(receivedTypePower);

    if (m_typePower != receivedTypePower) {
        m_typePower = receivedTypePower;
        emit typePowerChanged(m_typePower);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::handleModbusError(QModbusDevice::Error error)
{
    if (error == QModbusDevice::NoError) {
        // Reset the communication counter and we know we can reach the device
        m_communicationFailedCounter = 0;
        if (!m_communicationWorking)
            qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "Received a reply without any errors. The communication with the device seems to work now.";

        m_communicationWorking = true;
        evaluateReachableState();
    } else {
        m_communicationFailedCounter++;
        if (m_communicationWorking && m_communicationFailedCounter >= m_communicationFailedMax) {
            m_communicationWorking = false;
            qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Received" << m_communicationFailedCounter << "errors while communicating with the RTU master. Mark as not reachable until the communication works again.";
            evaluateReachableState();
        }
    }
}

void SolaxEvcStandaloneModbusTcpConnection::testReachability()
{
    if (m_checkRechableReply)
        return;

    // Try to read the check reachability register firmwareVersion in order to verify if the communication is working or not.
    qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "--> Test reachability by reading \"Firmware version\" register:" << 37 << "size:" << 1;
    m_checkRechableReply = readFirmwareVersion();
    if (!m_checkRechableReply) {
        qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "Error occurred verifying reachability by reading \"Firmware version\" register";
        onReachabilityCheckFailed();
        return;
    }

    if (m_checkRechableReply->isFinished()) {
        m_checkRechableReply->deleteLater(); // Broadcast reply returns immediatly
        m_checkRechableReply = nullptr;
        onReachabilityCheckFailed();
        return;
    }

    connect(m_checkRechableReply, &QModbusReply::finished, this, [this](){
        handleModbusError(m_checkRechableReply->error());
        if (m_checkRechableReply->error() != QModbusDevice::NoError)
            onReachabilityCheckFailed();

        m_checkRechableReply->deleteLater();
        m_checkRechableReply = nullptr;
    });

    connect(m_checkRechableReply, &QModbusReply::errorOccurred, this, [this] (QModbusDevice::Error error){
        qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "Modbus reply error occurred while verifying reachability by reading \"Firmware version\" register" << error << m_checkRechableReply->errorString();
    });
}

void SolaxEvcStandaloneModbusTcpConnection::verifyInitFinished()
{
    if (m_pendingInitReplies.isEmpty()) {
        finishInitialization(true);
    }
}

void SolaxEvcStandaloneModbusTcpConnection::finishInitialization(bool success)
{
    if (success) {
        qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "Initialization finished of SolaxEvcStandaloneModbusTcpConnection" << hostAddress().toString() << "finished successfully";
    } else {
        qCWarning(dcSolaxEvcStandaloneModbusTcpConnection()) << "Initialization finished of SolaxEvcStandaloneModbusTcpConnection" << hostAddress().toString() << "failed.";
    }

    // Cleanup init
    delete m_initObject;
    m_initObject = nullptr;
    m_pendingInitReplies.clear();

    emit initializationFinished(success);
}

void SolaxEvcStandaloneModbusTcpConnection::verifyUpdateFinished()
{
    if (m_pendingUpdateReplies.isEmpty()) {
        emit updateFinished();
    }
}

void SolaxEvcStandaloneModbusTcpConnection::onReachabilityCheckFailed()
{
    m_checkReachableRetriesCount++;

    if (m_checkReachableRetriesCount <= m_checkReachableRetries) {
        qCDebug(dcSolaxEvcStandaloneModbusTcpConnection()) << "Reachability test failed. Retry in on second" << m_checkReachableRetriesCount << "/" << m_checkReachableRetries;
        QTimer::singleShot(1000, this, &SolaxEvcStandaloneModbusTcpConnection::testReachability);
        return;
    }

    // The test reachability method failed, not retrying any more
    emit checkReachabilityFailed();
}

void SolaxEvcStandaloneModbusTcpConnection::evaluateReachableState()
{
    bool reachable = m_communicationWorking && connected();
    if (m_reachable == reachable)
        return;

    m_reachable = reachable;
    emit reachableChanged(m_reachable);
    m_checkReachableRetriesCount = 0;
}

QDebug operator<<(QDebug debug, SolaxEvcStandaloneModbusTcpConnection *solaxEvcStandaloneModbusTcpConnection)
{
    debug.nospace().noquote() << "SolaxEvcStandaloneModbusTcpConnection(" << solaxEvcStandaloneModbusTcpConnection->hostAddress().toString() << ":" << solaxEvcStandaloneModbusTcpConnection->port() << ")" << "\n";
    debug.nospace().noquote() << "    - Device mode: " << solaxEvcStandaloneModbusTcpConnection->deviceMode() << "\n";
    debug.nospace().noquote() << "    - Version: " << solaxEvcStandaloneModbusTcpConnection->serialNumber() << "\n";
    debug.nospace().noquote() << "    - Firmware version: " << solaxEvcStandaloneModbusTcpConnection->firmwareVersion() << "\n";
    debug.nospace().noquote() << "    - Control command: " << solaxEvcStandaloneModbusTcpConnection->controlCommand() << "\n";
    debug.nospace().noquote() << "    - Maximum current fast mode: " << solaxEvcStandaloneModbusTcpConnection->maxCurrent() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Current phase A: " << solaxEvcStandaloneModbusTcpConnection->currentPhaseA() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Current phase B: " << solaxEvcStandaloneModbusTcpConnection->currentPhaseB() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Current phase C: " << solaxEvcStandaloneModbusTcpConnection->currentPhaseC() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Current PE: " << solaxEvcStandaloneModbusTcpConnection->currentPe() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Power phase A: " << solaxEvcStandaloneModbusTcpConnection->powerPhaseA() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Power phase B: " << solaxEvcStandaloneModbusTcpConnection->powerPhaseB() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Power phase C: " << solaxEvcStandaloneModbusTcpConnection->powerPhaseC() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Total charging power: " << solaxEvcStandaloneModbusTcpConnection->totalPower() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Frequency phase A: " << solaxEvcStandaloneModbusTcpConnection->frequencyPhaseA() << " [Hz]" << "\n";
    debug.nospace().noquote() << "    - Frequency phase B: " << solaxEvcStandaloneModbusTcpConnection->frequencyPhaseB() << " [Hz]" << "\n";
    debug.nospace().noquote() << "    - Frequency phase C: " << solaxEvcStandaloneModbusTcpConnection->frequencyPhaseC() << " [Hz]" << "\n";
    debug.nospace().noquote() << "    - Single charge energy: " << solaxEvcStandaloneModbusTcpConnection->sessionEnergy() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Accumulated charging energy: " << solaxEvcStandaloneModbusTcpConnection->totalEnergy() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - State: " << solaxEvcStandaloneModbusTcpConnection->state() << "\n";
    debug.nospace().noquote() << "    - Fault code: " << solaxEvcStandaloneModbusTcpConnection->faultCode() << "\n";
    debug.nospace().noquote() << "    - Wallbox model case type: " << solaxEvcStandaloneModbusTcpConnection->typeCase() << "\n";
    debug.nospace().noquote() << "    - Wallbox is 7kW, 11kW or 22kW: " << solaxEvcStandaloneModbusTcpConnection->typePower() << "\n";
    return debug.quote().space();
}

