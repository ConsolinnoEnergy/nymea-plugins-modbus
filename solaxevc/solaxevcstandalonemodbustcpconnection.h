/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Copyright 2013 - 2025, nymea GmbH
* Contact: contact@nymea.io
*
* This fileDescriptor is part of nymea.
* This project including source code and documentation is protected by
* copyright law, and remains the property of nymea GmbH. All rights, including
* reproduction, publication, editing and translation, are reserved. The use of
* this project is subject to the terms of a license agreement to be concluded
* with nymea GmbH in accordance with the terms of use of nymea GmbH, available
* under https://nymea.io/license
*
* GNU Lesser General Public License Usage
* Alternatively, this project may be redistributed and/or modified under the
* terms of the GNU Lesser General Public License as published by the Free
* Software Foundation; version 3. This project is distributed in the hope that
* it will be useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this project. If not, see <https://www.gnu.org/licenses/>.
*
* For any further details and any questions please contact us under
* contact@nymea.io or see our FAQ/Licensing Information on
* https://nymea.io/license/faq
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WARNING
*
* This file has been autogenerated. Any changes in this file may be overwritten.
* If you want to change something, update the register json or the tool.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#ifndef SOLAXEVCSTANDALONEMODBUSTCPCONNECTION_H
#define SOLAXEVCSTANDALONEMODBUSTCPCONNECTION_H

#include <QObject>

#include <modbusdatautils.h>
#include <modbustcpmaster.h>

class SolaxEvcStandaloneModbusTcpConnection : public ModbusTCPMaster
{
    Q_OBJECT
public:
    enum Registers {
        RegisterCurrentPhaseA = 4,
        RegisterCurrentPhaseB = 5,
        RegisterCurrentPhaseC = 6,
        RegisterCurrentPe = 7,
        RegisterPowerPhaseA = 8,
        RegisterPowerPhaseB = 9,
        RegisterPowerPhaseC = 10,
        RegisterTotalPower = 11,
        RegisterFrequencyPhaseA = 12,
        RegisterFrequencyPhaseB = 13,
        RegisterFrequencyPhaseC = 14,
        RegisterSessionEnergy = 15,
        RegisterTotalEnergy = 16,
        RegisterState = 29,
        RegisterFaultCode = 30,
        RegisterTypeCase = 32,
        RegisterTypePower = 33,
        RegisterFirmwareVersion = 37,
        RegisterSerialNumber = 1536,
        RegisterDeviceMode = 1549,
        RegisterControlCommand = 1575,
        RegisterMaxCurrent = 1615
    };
    Q_ENUM(Registers)

    enum ControlCommand {
        ControlCommandUndefined = 0,
        ControlCommandAvailable = 1,
        ControlCommandUnavailable = 2,
        ControlCommandStopCharging = 3,
        ControlCommandStartCharging = 4,
        ControlCommandReserve = 5,
        ControlCommandCancelReservation = 6
    };
    Q_ENUM(ControlCommand)

    enum State {
        StateAvailable = 0,
        StatePreparing = 1,
        StateCharging = 2,
        StateFinishing = 3,
        StateFaulted = 4,
        StateUnavailable = 5,
        StateReserved = 6,
        StateSuspendedEV = 7,
        StateSuspendedEVSE = 8,
        StateUpdate = 9,
        StateCardActivation = 10
    };
    Q_ENUM(State)

    explicit SolaxEvcStandaloneModbusTcpConnection(const QHostAddress &hostAddress, uint port, quint16 slaveId, QObject *parent = nullptr);
    ~SolaxEvcStandaloneModbusTcpConnection() = default;

    bool reachable() const;

    ModbusDataUtils::ByteOrder endianness() const;
    void setEndianness(ModbusDataUtils::ByteOrder endianness);

    uint checkReachableRetries() const;
    void setCheckReachableRetries(uint checkReachableRetries);

    /* Device mode - Address: 1549, Size: 1 */
    quint16 deviceMode() const;
    QModbusReply *setDeviceMode(quint16 deviceMode);

    /* Version - Address: 1536, Size: 14 */
    QString serialNumber() const;

    /* Firmware version - Address: 37, Size: 1 */
    quint16 firmwareVersion() const;

    /* Control command - Address: 1575, Size: 2 */
    ControlCommand controlCommand() const;
    QModbusReply *setControlCommand(ControlCommand controlCommand);

    /* Maximum current fast mode [A] - Address: 1615, Size: 2 */
    float maxCurrent() const;
    QModbusReply *setMaxCurrent(float maxCurrent);

    /* Current phase A [A] - Address: 4, Size: 1 */
    float currentPhaseA() const;

    /* Current phase B [A] - Address: 5, Size: 1 */
    float currentPhaseB() const;

    /* Current phase C [A] - Address: 6, Size: 1 */
    float currentPhaseC() const;

    /* Current PE [A] - Address: 7, Size: 1 */
    float currentPe() const;

    /* Power phase A [W] - Address: 8, Size: 1 */
    quint16 powerPhaseA() const;

    /* Power phase B [W] - Address: 9, Size: 1 */
    quint16 powerPhaseB() const;

    /* Power phase C [W] - Address: 10, Size: 1 */
    quint16 powerPhaseC() const;

    /* Total charging power [W] - Address: 11, Size: 1 */
    quint16 totalPower() const;

    /* Frequency phase A [Hz] - Address: 12, Size: 1 */
    float frequencyPhaseA() const;

    /* Frequency phase B [Hz] - Address: 13, Size: 1 */
    float frequencyPhaseB() const;

    /* Frequency phase C [Hz] - Address: 14, Size: 1 */
    float frequencyPhaseC() const;

    /* Single charge energy [kWh] - Address: 15, Size: 1 */
    float sessionEnergy() const;

    /* Accumulated charging energy [kWh] - Address: 16, Size: 2 */
    float totalEnergy() const;

    /* State - Address: 29, Size: 1 */
    State state() const;

    /* Fault code - Address: 30, Size: 2 */
    quint32 faultCode() const;

    /* Wallbox model case type - Address: 32, Size: 1 */
    quint16 typeCase() const;

    /* Wallbox is 7kW, 11kW or 22kW - Address: 33, Size: 1 */
    quint16 typePower() const;

    /* Read block from start addess 4 with size of 14 registers containing following 13 properties:
      - Current phase A [A] - Address: 4, Size: 1
      - Current phase B [A] - Address: 5, Size: 1
      - Current phase C [A] - Address: 6, Size: 1
      - Current PE [A] - Address: 7, Size: 1
      - Power phase A [W] - Address: 8, Size: 1
      - Power phase B [W] - Address: 9, Size: 1
      - Power phase C [W] - Address: 10, Size: 1
      - Total charging power [W] - Address: 11, Size: 1
      - Frequency phase A [Hz] - Address: 12, Size: 1
      - Frequency phase B [Hz] - Address: 13, Size: 1
      - Frequency phase C [Hz] - Address: 14, Size: 1
      - Single charge energy [kWh] - Address: 15, Size: 1
      - Accumulated charging energy [kWh] - Address: 16, Size: 2
    */
    void updateMeterValuesBlock();

    /* Read block from start addess 29 with size of 5 registers containing following 4 properties:
      - State - Address: 29, Size: 1
      - Fault code - Address: 30, Size: 2
      - Wallbox model case type - Address: 32, Size: 1
      - Wallbox is 7kW, 11kW or 22kW - Address: 33, Size: 1
    */
    void updateWallboxStatusBlock();

    void updateDeviceMode();
    void updateControlCommand();
    void updateMaxCurrent();

    void updateCurrentPhaseA();
    void updateCurrentPhaseB();
    void updateCurrentPhaseC();
    void updateCurrentPe();
    void updatePowerPhaseA();
    void updatePowerPhaseB();
    void updatePowerPhaseC();
    void updateTotalPower();
    void updateFrequencyPhaseA();
    void updateFrequencyPhaseB();
    void updateFrequencyPhaseC();
    void updateSessionEnergy();
    void updateTotalEnergy();
    void updateState();
    void updateFaultCode();
    void updateTypeCase();
    void updateTypePower();

    QModbusReply *readDeviceMode();
    QModbusReply *readSerialNumber();
    QModbusReply *readFirmwareVersion();
    QModbusReply *readControlCommand();
    QModbusReply *readMaxCurrent();
    QModbusReply *readCurrentPhaseA();
    QModbusReply *readCurrentPhaseB();
    QModbusReply *readCurrentPhaseC();
    QModbusReply *readCurrentPe();
    QModbusReply *readPowerPhaseA();
    QModbusReply *readPowerPhaseB();
    QModbusReply *readPowerPhaseC();
    QModbusReply *readTotalPower();
    QModbusReply *readFrequencyPhaseA();
    QModbusReply *readFrequencyPhaseB();
    QModbusReply *readFrequencyPhaseC();
    QModbusReply *readSessionEnergy();
    QModbusReply *readTotalEnergy();
    QModbusReply *readState();
    QModbusReply *readFaultCode();
    QModbusReply *readTypeCase();
    QModbusReply *readTypePower();

    /* Read block from start addess 4 with size of 14 registers containing following 13 properties:
     - Current phase A [A] - Address: 4, Size: 1
     - Current phase B [A] - Address: 5, Size: 1
     - Current phase C [A] - Address: 6, Size: 1
     - Current PE [A] - Address: 7, Size: 1
     - Power phase A [W] - Address: 8, Size: 1
     - Power phase B [W] - Address: 9, Size: 1
     - Power phase C [W] - Address: 10, Size: 1
     - Total charging power [W] - Address: 11, Size: 1
     - Frequency phase A [Hz] - Address: 12, Size: 1
     - Frequency phase B [Hz] - Address: 13, Size: 1
     - Frequency phase C [Hz] - Address: 14, Size: 1
     - Single charge energy [kWh] - Address: 15, Size: 1
     - Accumulated charging energy [kWh] - Address: 16, Size: 2
    */
    QModbusReply *readBlockMeterValues();

    /* Read block from start addess 29 with size of 5 registers containing following 4 properties:
     - State - Address: 29, Size: 1
     - Fault code - Address: 30, Size: 2
     - Wallbox model case type - Address: 32, Size: 1
     - Wallbox is 7kW, 11kW or 22kW - Address: 33, Size: 1
    */
    QModbusReply *readBlockWallboxStatus();


    virtual bool initialize();
    virtual void initialize1();
    virtual bool update();
    virtual void update1();
    virtual void update2();
    virtual void update3();
    virtual void update4();

signals:
    void reachableChanged(bool reachable);
    void checkReachabilityFailed();
    void checkReachableRetriesChanged(uint checkReachableRetries);

    void initializationFinished(bool success);
    void updateFinished();

    void endiannessChanged(ModbusDataUtils::ByteOrder endianness);

    void deviceModeChanged(quint16 deviceMode);
    void deviceModeReadFinished(quint16 deviceMode);
    void serialNumberChanged(const QString &serialNumber);
    void serialNumberReadFinished(const QString &serialNumber);
    void firmwareVersionChanged(quint16 firmwareVersion);
    void firmwareVersionReadFinished(quint16 firmwareVersion);
    void controlCommandChanged(ControlCommand controlCommand);
    void controlCommandReadFinished(ControlCommand controlCommand);
    void maxCurrentChanged(float maxCurrent);
    void maxCurrentReadFinished(float maxCurrent);

    void currentPhaseAChanged(float currentPhaseA);
    void currentPhaseAReadFinished(float currentPhaseA);
    void currentPhaseBChanged(float currentPhaseB);
    void currentPhaseBReadFinished(float currentPhaseB);
    void currentPhaseCChanged(float currentPhaseC);
    void currentPhaseCReadFinished(float currentPhaseC);
    void currentPeChanged(float currentPe);
    void currentPeReadFinished(float currentPe);
    void powerPhaseAChanged(quint16 powerPhaseA);
    void powerPhaseAReadFinished(quint16 powerPhaseA);
    void powerPhaseBChanged(quint16 powerPhaseB);
    void powerPhaseBReadFinished(quint16 powerPhaseB);
    void powerPhaseCChanged(quint16 powerPhaseC);
    void powerPhaseCReadFinished(quint16 powerPhaseC);
    void totalPowerChanged(quint16 totalPower);
    void totalPowerReadFinished(quint16 totalPower);
    void frequencyPhaseAChanged(float frequencyPhaseA);
    void frequencyPhaseAReadFinished(float frequencyPhaseA);
    void frequencyPhaseBChanged(float frequencyPhaseB);
    void frequencyPhaseBReadFinished(float frequencyPhaseB);
    void frequencyPhaseCChanged(float frequencyPhaseC);
    void frequencyPhaseCReadFinished(float frequencyPhaseC);
    void sessionEnergyChanged(float sessionEnergy);
    void sessionEnergyReadFinished(float sessionEnergy);
    void totalEnergyChanged(float totalEnergy);
    void totalEnergyReadFinished(float totalEnergy);
    void stateChanged(State state);
    void stateReadFinished(State state);
    void faultCodeChanged(quint32 faultCode);
    void faultCodeReadFinished(quint32 faultCode);
    void typeCaseChanged(quint16 typeCase);
    void typeCaseReadFinished(quint16 typeCase);
    void typePowerChanged(quint16 typePower);
    void typePowerReadFinished(quint16 typePower);

protected:
    quint16 m_deviceMode = 0;
    QString m_serialNumber = 0;
    quint16 m_firmwareVersion = 0;
    ControlCommand m_controlCommand = ControlCommandUndefined;
    float m_maxCurrent = 0;
    float m_currentPhaseA = 0;
    float m_currentPhaseB = 0;
    float m_currentPhaseC = 0;
    float m_currentPe = 0;
    quint16 m_powerPhaseA = 0;
    quint16 m_powerPhaseB = 0;
    quint16 m_powerPhaseC = 0;
    quint16 m_totalPower = 0;
    float m_frequencyPhaseA = 0;
    float m_frequencyPhaseB = 0;
    float m_frequencyPhaseC = 0;
    float m_sessionEnergy = 0;
    float m_totalEnergy = 0;
    State m_state = StateAvailable;
    quint32 m_faultCode = 0;
    quint16 m_typeCase = 0;
    quint16 m_typePower = 0;

    void processDeviceModeRegisterValues(const QVector<quint16> values);
    void processSerialNumberRegisterValues(const QVector<quint16> values);
    void processFirmwareVersionRegisterValues(const QVector<quint16> values);
    void processControlCommandRegisterValues(const QVector<quint16> values);
    void processMaxCurrentRegisterValues(const QVector<quint16> values);

    void processCurrentPhaseARegisterValues(const QVector<quint16> values);
    void processCurrentPhaseBRegisterValues(const QVector<quint16> values);
    void processCurrentPhaseCRegisterValues(const QVector<quint16> values);
    void processCurrentPeRegisterValues(const QVector<quint16> values);
    void processPowerPhaseARegisterValues(const QVector<quint16> values);
    void processPowerPhaseBRegisterValues(const QVector<quint16> values);
    void processPowerPhaseCRegisterValues(const QVector<quint16> values);
    void processTotalPowerRegisterValues(const QVector<quint16> values);
    void processFrequencyPhaseARegisterValues(const QVector<quint16> values);
    void processFrequencyPhaseBRegisterValues(const QVector<quint16> values);
    void processFrequencyPhaseCRegisterValues(const QVector<quint16> values);
    void processSessionEnergyRegisterValues(const QVector<quint16> values);
    void processTotalEnergyRegisterValues(const QVector<quint16> values);

    void processStateRegisterValues(const QVector<quint16> values);
    void processFaultCodeRegisterValues(const QVector<quint16> values);
    void processTypeCaseRegisterValues(const QVector<quint16> values);
    void processTypePowerRegisterValues(const QVector<quint16> values);

    void handleModbusError(QModbusDevice::Error error);
    void testReachability();

private:
    ModbusDataUtils::ByteOrder m_endianness = ModbusDataUtils::ByteOrderLittleEndian;
    quint16 m_slaveId = 1;

    bool m_reachable = false;
    QModbusReply *m_checkRechableReply = nullptr;
    uint m_checkReachableRetries = 0;
    uint m_checkReachableRetriesCount = 0;
    bool m_communicationWorking = false;
    quint8 m_communicationFailedMax = 10;
    quint8 m_communicationFailedCounter = 0;


    QVector<QModbusReply *> m_pendingInitReplies;
    QVector<QModbusReply *> m_pendingUpdateReplies;

    QObject *m_initObject = nullptr;
    void verifyInitFinished();
    void finishInitialization(bool success);

    void verifyUpdateFinished();

    void onReachabilityCheckFailed();
    void evaluateReachableState();

};

QDebug operator<<(QDebug debug, SolaxEvcStandaloneModbusTcpConnection *solaxEvcStandaloneModbusTcpConnection);

#endif // SOLAXEVCSTANDALONEMODBUSTCPCONNECTION_H
