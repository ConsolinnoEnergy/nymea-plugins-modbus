/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Copyright 2013 - 2024, nymea GmbH
* Contact: contact@nymea.io
*
* This fileDescriptor is part of nymea.
* This project including source code and documentation is protected by
* copyright law, and remains the property of nymea GmbH. All rights, including
* reproduction, publication, editing and translation, are reserved. The use of
* this project is subject to the terms of a license agreement to be concluded
* with nymea GmbH in accordance with the terms of use of nymea GmbH, available
* under https://nymea.io/license
*
* GNU Lesser General Public License Usage
* Alternatively, this project may be redistributed and/or modified under the
* terms of the GNU Lesser General Public License as published by the Free
* Software Foundation; version 3. This project is distributed in the hope that
* it will be useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this project. If not, see <https://www.gnu.org/licenses/>.
*
* For any further details and any questions please contact us under
* contact@nymea.io or see our FAQ/Licensing Information on
* https://nymea.io/license/faq
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WARNING
*
* This file has been autogenerated. Any changes in this file may be overwritten.
* If you want to change something, update the register json or the tool.
*
* !! IMPORTANT !!
* This is a modified version of the autogenerated file.
* As this has been manually copied and modified, changes to the solaxev-register.json
* file will not result in this file being automatically updated.
*
* As the solax wallbox needs time to process modbus requests, the initialize()
* and update() function are split up into several functions, that are called one after another.
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


#include "solaxevcmodbustcpconnection.h"
#include <loggingcategories.h>
#include <math.h>
#include <QTimer>

NYMEA_LOGGING_CATEGORY(dcSolaxEvcModbusTcpConnection, "SolaxEvcModbusTcpConnection")

SolaxEvcModbusTcpConnection::SolaxEvcModbusTcpConnection(const QHostAddress &hostAddress, uint port, quint16 slaveId, QObject *parent) :
    ModbusTCPMaster(hostAddress, port, parent),
    m_slaveId(slaveId)
{
    connect(this, &ModbusTCPMaster::connectionStateChanged, this, [this](bool status){
        if (status) {
           qCDebug(dcSolaxEvcModbusTcpConnection()) << "Modbus TCP connection" << m_hostAddress.toString() << "connected. Start testing if the connection is reachable...";
            // Cleanup before starting to initialize
            m_pendingInitReplies.clear();
            m_pendingUpdateReplies.clear();
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
            testReachability();
        } else {
            qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus TCP connection diconnected from" << m_hostAddress.toString() << ". The connection is not reachable any more.";
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
        }

        evaluateReachableState();
    });
}

bool SolaxEvcModbusTcpConnection::reachable() const
{
    return m_reachable;
}

uint SolaxEvcModbusTcpConnection::checkReachableRetries() const
{
    return m_checkReachableRetries;
}

void SolaxEvcModbusTcpConnection::setCheckReachableRetries(uint checkReachableRetries)
{
    if (m_checkReachableRetries == checkReachableRetries)
        return;

    m_checkReachableRetries = checkReachableRetries;
    emit checkReachableRetriesChanged(m_checkReachableRetries);
}

ModbusDataUtils::ByteOrder SolaxEvcModbusTcpConnection::endianness() const
{
    return m_endianness;
}

void SolaxEvcModbusTcpConnection::setEndianness(ModbusDataUtils::ByteOrder endianness)
{
    if (m_endianness == endianness)
        return;

    m_endianness = endianness;
    emit endiannessChanged(m_endianness);
}

QString SolaxEvcModbusTcpConnection::serialNumber() const
{
    return m_serialNumber;
}

quint16 SolaxEvcModbusTcpConnection::deviceType() const
{
    return m_deviceType;
}

float SolaxEvcModbusTcpConnection::totalEnergy() const
{
    return m_totalEnergy;
}

float SolaxEvcModbusTcpConnection::DataHubChargeCurrent() const
{
    return m_DataHubChargeCurrent;
}

QModbusReply *SolaxEvcModbusTcpConnection::setDataHubChargeCurrent(float DataHubChargeCurrent)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(static_cast<quint16>(DataHubChargeCurrent  * 1.0 / pow(10, -2)));
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Write \"Data hub charge current\" register:" << 4132 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4132, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 SolaxEvcModbusTcpConnection::firmwareVersion() const
{
    return m_firmwareVersion;
}

SolaxEvcModbusTcpConnection::ControlCommand SolaxEvcModbusTcpConnection::controlCommand() const
{
    return m_controlCommand;
}

QModbusReply *SolaxEvcModbusTcpConnection::setControlCommand(ControlCommand controlCommand)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(static_cast<quint16>(controlCommand));
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Write \"Control command\" register:" << 4135 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4135, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

float SolaxEvcModbusTcpConnection::MaxCurrent() const
{
    return m_MaxCurrent;
}

QModbusReply *SolaxEvcModbusTcpConnection::setMaxCurrent(float MaxCurrent)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(static_cast<quint16>(MaxCurrent  * 1.0 / pow(10, -2)));
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Write \"Maximum AC line current\" register:" << 4136 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4136, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint32 SolaxEvcModbusTcpConnection::chargingTime() const
{
    return m_chargingTime;
}

SolaxEvcModbusTcpConnection::ChargePhase SolaxEvcModbusTcpConnection::chargePhase() const
{
    return m_chargePhase;
}

float SolaxEvcModbusTcpConnection::MinCurrent() const
{
    return m_MinCurrent;
}

QModbusReply *SolaxEvcModbusTcpConnection::setMinCurrent(float MinCurrent)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(static_cast<quint16>(MinCurrent  * 1.0 / pow(10, -2)));
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Write \"Minimum AC line current\" register:" << 4159 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4159, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 SolaxEvcModbusTcpConnection::slaveAddress() const
{
    return m_slaveAddress;
}

float SolaxEvcModbusTcpConnection::voltagePhaseA() const
{
    return m_voltagePhaseA;
}

float SolaxEvcModbusTcpConnection::voltagePhaseB() const
{
    return m_voltagePhaseB;
}

float SolaxEvcModbusTcpConnection::voltagePhaseC() const
{
    return m_voltagePhaseC;
}

float SolaxEvcModbusTcpConnection::voltagePe() const
{
    return m_voltagePe;
}

float SolaxEvcModbusTcpConnection::currentPhaseA() const
{
    return m_currentPhaseA;
}

float SolaxEvcModbusTcpConnection::currentPhaseB() const
{
    return m_currentPhaseB;
}

float SolaxEvcModbusTcpConnection::currentPhaseC() const
{
    return m_currentPhaseC;
}

float SolaxEvcModbusTcpConnection::currentPe() const
{
    return m_currentPe;
}

quint16 SolaxEvcModbusTcpConnection::powerPhaseA() const
{
    return m_powerPhaseA;
}

quint16 SolaxEvcModbusTcpConnection::powerPhaseB() const
{
    return m_powerPhaseB;
}

quint16 SolaxEvcModbusTcpConnection::powerPhaseC() const
{
    return m_powerPhaseC;
}

quint16 SolaxEvcModbusTcpConnection::totalPower() const
{
    return m_totalPower;
}

float SolaxEvcModbusTcpConnection::frequencyPhaseA() const
{
    return m_frequencyPhaseA;
}

float SolaxEvcModbusTcpConnection::frequencyPhaseB() const
{
    return m_frequencyPhaseB;
}

float SolaxEvcModbusTcpConnection::frequencyPhaseC() const
{
    return m_frequencyPhaseC;
}

float SolaxEvcModbusTcpConnection::sessionEnergy() const
{
    return m_sessionEnergy;
}

qint16 SolaxEvcModbusTcpConnection::tempPcb() const
{
    return m_tempPcb;
}

SolaxEvcModbusTcpConnection::State SolaxEvcModbusTcpConnection::state() const
{
    return m_state;
}

quint32 SolaxEvcModbusTcpConnection::faultCode() const
{
    return m_faultCode;
}

quint16 SolaxEvcModbusTcpConnection::typeCase() const
{
    return m_typeCase;
}

quint16 SolaxEvcModbusTcpConnection::typePower() const
{
    return m_typePower;
}

quint16 SolaxEvcModbusTcpConnection::typePhase() const
{
    return m_typePhase;
}

quint16 SolaxEvcModbusTcpConnection::typeCharger() const
{
    return m_typeCharger;
}

quint16 SolaxEvcModbusTcpConnection::typeScreen() const
{
    return m_typeScreen;
}

quint16 SolaxEvcModbusTcpConnection::deviceMode() const
{
    return m_deviceMode;
}

QModbusReply *SolaxEvcModbusTcpConnection::setDeviceMode(quint16 deviceMode)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(deviceMode);
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Write \"Device mode\" register:" << 4109 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4109, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 SolaxEvcModbusTcpConnection::ecoGear() const
{
    return m_ecoGear;
}

QModbusReply *SolaxEvcModbusTcpConnection::setEcoGear(quint16 ecoGear)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(ecoGear);
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Write \"ECO gear\" register:" << 4110 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4110, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 SolaxEvcModbusTcpConnection::greenGear() const
{
    return m_greenGear;
}

QModbusReply *SolaxEvcModbusTcpConnection::setGreenGear(quint16 greenGear)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(greenGear);
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Write \"Green gear\" register:" << 4111 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4111, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 SolaxEvcModbusTcpConnection::startChargeMode() const
{
    return m_startChargeMode;
}

QModbusReply *SolaxEvcModbusTcpConnection::setStartChargeMode(quint16 startChargeMode)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(startChargeMode);
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Write \"Start charge mode\" register:" << 4112 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4112, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 SolaxEvcModbusTcpConnection::overVoltSet() const
{
    return m_overVoltSet;
}

QModbusReply *SolaxEvcModbusTcpConnection::setOverVoltSet(quint16 overVoltSet)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(overVoltSet);
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Write \"Over voltage setting\" register:" << 4113 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4113, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 SolaxEvcModbusTcpConnection::underVoltSet() const
{
    return m_underVoltSet;
}

QModbusReply *SolaxEvcModbusTcpConnection::setUnderVoltSet(quint16 underVoltSet)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(underVoltSet);
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Write \"Under voltage setting\" register:" << 4114 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4114, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 SolaxEvcModbusTcpConnection::boostMode() const
{
    return m_boostMode;
}

QModbusReply *SolaxEvcModbusTcpConnection::setBoostMode(quint16 boostMode)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(boostMode);
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Write \"Boost mode\" register:" << 4115 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4115, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 SolaxEvcModbusTcpConnection::mainBreakerLimit() const
{
    return m_mainBreakerLimit;
}

QModbusReply *SolaxEvcModbusTcpConnection::setMainBreakerLimit(quint16 mainBreakerLimit)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(mainBreakerLimit);
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Write \"Main breaker limit\" register:" << 4116 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4116, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 SolaxEvcModbusTcpConnection::electronicLock() const
{
    return m_electronicLock;
}

QModbusReply *SolaxEvcModbusTcpConnection::setElectronicLock(quint16 electronicLock)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(electronicLock);
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Write \"Electronic Lock\" register:" << 4117 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4117, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 SolaxEvcModbusTcpConnection::CardActivateSwitch() const
{
    return m_CardActivateSwitch;
}

QModbusReply *SolaxEvcModbusTcpConnection::setCardActivateSwitch(quint16 CardActivateSwitch)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(CardActivateSwitch);
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Write \"Card activate switch\" register:" << 4118 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4118, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

bool SolaxEvcModbusTcpConnection::initialize()
{
    if (!m_reachable) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Tried to initialize but the device is not to be reachable.";
        return false;
    }
    if (m_initObject) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Tried to initialize but the init process is already running.";
        return false;
    }

    // Parent object for the init process
    m_initObject = new QObject(this);

    QModbusReply *reply = nullptr;

    // Read Version
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read init \"Version\" register:" << 4096 << "size:" << 14;
    reply = readSerialNumber();
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading \"Version\" registers from" << hostAddress().toString() << errorString();
        finishInitialization(false);
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, m_initObject, [this, reply](){
        handleModbusError(reply->error());
        m_pendingInitReplies.removeAll(reply);
        if (reply->error() != QModbusDevice::NoError) {
            finishInitialization(false);
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from init \"Version\" register" << 4096 << "size:" << 14 << unit.values();
        processSerialNumberRegisterValues(unit.values());
        initialize1();
    });

    connect(reply, &QModbusReply::errorOccurred, m_initObject, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while reading \"Version\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    return true;
}

void SolaxEvcModbusTcpConnection::initialize1()
{
    QModbusReply *reply = nullptr;

    // Read Device type
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read init \"Device type\" register:" << 4108 << "size:" << 1;
    reply = readDeviceType();
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading \"Device type\" registers from" << hostAddress().toString() << errorString();
        finishInitialization(false);
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, m_initObject, [this, reply](){
        handleModbusError(reply->error());
        m_pendingInitReplies.removeAll(reply);
        if (reply->error() != QModbusDevice::NoError) {
            finishInitialization(false);
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from init \"Device type\" register" << 4108 << "size:" << 1 << unit.values();
        processDeviceTypeRegisterValues(unit.values());
        initialize2();
    });

    connect(reply, &QModbusReply::errorOccurred, m_initObject, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while reading \"Device type\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxEvcModbusTcpConnection::initialize2()
{
    QModbusReply *reply = nullptr;

    // Read Firmware version
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read init \"Firmware version\" register:" << 4133 << "size:" << 1;
    reply = readFirmwareVersion();
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading \"Firmware version\" registers from" << hostAddress().toString() << errorString();
        finishInitialization(false);
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, m_initObject, [this, reply](){
        handleModbusError(reply->error());
        m_pendingInitReplies.removeAll(reply);
        if (reply->error() != QModbusDevice::NoError) {
            finishInitialization(false);
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from init \"Firmware version\" register" << 4133 << "size:" << 1 << unit.values();
        processFirmwareVersionRegisterValues(unit.values());
        verifyInitFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, m_initObject, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while reading \"Firmware version\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

bool SolaxEvcModbusTcpConnection::update()
{
    if (!connected())
        return false;

    if (!m_pendingUpdateReplies.isEmpty()) {
        qCDebug(dcSolaxEvcModbusTcpConnection()) << "Tried to update but there are still some update replies pending. Waiting for them to be finished...";
        return true;
    }

    QModbusReply *reply = nullptr;

    // Read Accumulated charging energy
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read \"Accumulated charging energy\" register:" << 4121 << "size:" << 2;
    reply = readTotalEnergy();
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading \"Accumulated charging energy\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from \"Accumulated charging energy\" register" << 4121 << "size:" << 2 << unit.values();
        processTotalEnergyRegisterValues(unit.values());
        update1();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while reading \"Accumulated charging energy\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    return true;
}

void SolaxEvcModbusTcpConnection::update1()
{
    QModbusReply *reply = nullptr;

    // Read Control command
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read \"Control command\" register:" << 4135 << "size:" << 1;
    reply = readControlCommand();
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading \"Control command\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from \"Control command\" register" << 4135 << "size:" << 1 << unit.values();
        processControlCommandRegisterValues(unit.values());
        update2();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while reading \"Control command\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxEvcModbusTcpConnection::update2()
{
    QModbusReply *reply = nullptr;

    // Read Maximum AC line current
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read \"Maximum AC line current\" register:" << 4136 << "size:" << 1;
    reply = readMaxCurrent();
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading \"Maximum AC line current\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from \"Maximum AC line current\" register" << 4136 << "size:" << 1 << unit.values();
        processMaxCurrentRegisterValues(unit.values());
        update3();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while reading \"Maximum AC line current\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxEvcModbusTcpConnection::update3()
{
    QModbusReply *reply = nullptr;

    // Read Duration of current charging session
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read \"Duration of current charging session\" register:" << 4139 << "size:" << 2;
    reply = readChargingTime();
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading \"Duration of current charging session\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from \"Duration of current charging session\" register" << 4139 << "size:" << 2 << unit.values();
        processChargingTimeRegisterValues(unit.values());
        update4();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while reading \"Duration of current charging session\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxEvcModbusTcpConnection::update4()
{
    QModbusReply *reply = nullptr;

    // Read Minimum AC line current
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read \"Minimum AC line current\" register:" << 4159 << "size:" << 1;
    reply = readMinCurrent();
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading \"Minimum AC line current\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from \"Minimum AC line current\" register" << 4159 << "size:" << 1 << unit.values();
        processMinCurrentRegisterValues(unit.values());
        update5();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while reading \"Minimum AC line current\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxEvcModbusTcpConnection::update5()
{
    QModbusReply *reply = nullptr;

    // Read Own 485 address
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read \"Own 485 address\" register:" << 4160 << "size:" << 1;
    reply = readSlaveAddress();
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading \"Own 485 address\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from \"Own 485 address\" register" << 4160 << "size:" << 1 << unit.values();
        processSlaveAddressRegisterValues(unit.values());
        update6();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while reading \"Own 485 address\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxEvcModbusTcpConnection::update6()
{
    QModbusReply *reply = nullptr;

    // Read meterValues
    reply = readBlockMeterValues();
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read block \"meterValues\" registers from:" << 4096 << "size:" << 16;
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading block \"meterValues\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from reading block \"meterValues\" register" << 4096 << "size:" << 16 << blockValues;
        processVoltagePhaseARegisterValues(blockValues.mid(0, 1));
        processVoltagePhaseBRegisterValues(blockValues.mid(1, 1));
        processVoltagePhaseCRegisterValues(blockValues.mid(2, 1));
        processVoltagePeRegisterValues(blockValues.mid(3, 1));
        processCurrentPhaseARegisterValues(blockValues.mid(4, 1));
        processCurrentPhaseBRegisterValues(blockValues.mid(5, 1));
        processCurrentPhaseCRegisterValues(blockValues.mid(6, 1));
        processCurrentPeRegisterValues(blockValues.mid(7, 1));
        processPowerPhaseARegisterValues(blockValues.mid(8, 1));
        processPowerPhaseBRegisterValues(blockValues.mid(9, 1));
        processPowerPhaseCRegisterValues(blockValues.mid(10, 1));
        processTotalPowerRegisterValues(blockValues.mid(11, 1));
        processFrequencyPhaseARegisterValues(blockValues.mid(12, 1));
        processFrequencyPhaseBRegisterValues(blockValues.mid(13, 1));
        processFrequencyPhaseCRegisterValues(blockValues.mid(14, 1));
        processSessionEnergyRegisterValues(blockValues.mid(15, 1));
        update7();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while updating block \"meterValues\" registers" << error << reply->errorString();
    });
}

void SolaxEvcModbusTcpConnection::update7()
{
    QModbusReply *reply = nullptr;

    // Read wallboxStatus
    reply = readBlockWallboxStatus();
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read block \"wallboxStatus\" registers from:" << 4124 << "size:" << 9;
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading block \"wallboxStatus\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from reading block \"wallboxStatus\" register" << 4124 << "size:" << 9 << blockValues;
        processTempPcbRegisterValues(blockValues.mid(0, 1));
        processStateRegisterValues(blockValues.mid(1, 1));
        processFaultCodeRegisterValues(blockValues.mid(2, 2));
        processTypeCaseRegisterValues(blockValues.mid(4, 1));
        processTypePowerRegisterValues(blockValues.mid(5, 1));
        processTypePhaseRegisterValues(blockValues.mid(6, 1));
        processTypeChargerRegisterValues(blockValues.mid(7, 1));
        processTypeScreenRegisterValues(blockValues.mid(8, 1));
        update8();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while updating block \"wallboxStatus\" registers" << error << reply->errorString();
    });
}

void SolaxEvcModbusTcpConnection::update8()
{
    QModbusReply *reply = nullptr;

    // Read deviceSettings
    reply = readBlockDeviceSettings();
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read block \"deviceSettings\" registers from:" << 4109 << "size:" << 10;
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading block \"deviceSettings\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from reading block \"deviceSettings\" register" << 4109 << "size:" << 10 << blockValues;
        processDeviceModeRegisterValues(blockValues.mid(0, 1));
        processEcoGearRegisterValues(blockValues.mid(1, 1));
        processGreenGearRegisterValues(blockValues.mid(2, 1));
        processStartChargeModeRegisterValues(blockValues.mid(3, 1));
        processOverVoltSetRegisterValues(blockValues.mid(4, 1));
        processUnderVoltSetRegisterValues(blockValues.mid(5, 1));
        processBoostModeRegisterValues(blockValues.mid(6, 1));
        processMainBreakerLimitRegisterValues(blockValues.mid(7, 1));
        processElectronicLockRegisterValues(blockValues.mid(8, 1));
        processCardActivateSwitchRegisterValues(blockValues.mid(9, 1));
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while updating block \"deviceSettings\" registers" << error << reply->errorString();
    });
}

void SolaxEvcModbusTcpConnection::updateTotalEnergy()
{
    // Update registers from Accumulated charging energy
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read \"Accumulated charging energy\" register:" << 4121 << "size:" << 2;
    QModbusReply *reply = readTotalEnergy();
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading \"Accumulated charging energy\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from \"Accumulated charging energy\" register" << 4121 << "size:" << 2 << unit.values();
            processTotalEnergyRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while updating \"Accumulated charging energy\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxEvcModbusTcpConnection::updateControlCommand()
{
    // Update registers from Control command
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read \"Control command\" register:" << 4135 << "size:" << 1;
    QModbusReply *reply = readControlCommand();
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading \"Control command\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from \"Control command\" register" << 4135 << "size:" << 1 << unit.values();
            processControlCommandRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while updating \"Control command\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxEvcModbusTcpConnection::updateMaxCurrent()
{
    // Update registers from Maximum AC line current
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read \"Maximum AC line current\" register:" << 4136 << "size:" << 1;
    QModbusReply *reply = readMaxCurrent();
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading \"Maximum AC line current\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from \"Maximum AC line current\" register" << 4136 << "size:" << 1 << unit.values();
            processMaxCurrentRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while updating \"Maximum AC line current\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxEvcModbusTcpConnection::updateChargingTime()
{
    // Update registers from Duration of current charging session
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read \"Duration of current charging session\" register:" << 4139 << "size:" << 2;
    QModbusReply *reply = readChargingTime();
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading \"Duration of current charging session\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from \"Duration of current charging session\" register" << 4139 << "size:" << 2 << unit.values();
            processChargingTimeRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while updating \"Duration of current charging session\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxEvcModbusTcpConnection::updateMinCurrent()
{
    // Update registers from Minimum AC line current
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read \"Minimum AC line current\" register:" << 4159 << "size:" << 1;
    QModbusReply *reply = readMinCurrent();
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading \"Minimum AC line current\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from \"Minimum AC line current\" register" << 4159 << "size:" << 1 << unit.values();
            processMinCurrentRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while updating \"Minimum AC line current\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxEvcModbusTcpConnection::updateSlaveAddress()
{
    // Update registers from Own 485 address
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read \"Own 485 address\" register:" << 4160 << "size:" << 1;
    QModbusReply *reply = readSlaveAddress();
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading \"Own 485 address\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from \"Own 485 address\" register" << 4160 << "size:" << 1 << unit.values();
            processSlaveAddressRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while updating \"Own 485 address\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxEvcModbusTcpConnection::updateMeterValuesBlock()
{
    // Update register block "meterValues"
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read block \"meterValues\" registers from:" << 4096 << "size:" << 16;
    QModbusReply *reply = readBlockMeterValues();
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading block \"meterValues\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from reading block \"meterValues\" register" << 4096 << "size:" << 16 << blockValues;
            processVoltagePhaseARegisterValues(blockValues.mid(0, 1));
            processVoltagePhaseBRegisterValues(blockValues.mid(1, 1));
            processVoltagePhaseCRegisterValues(blockValues.mid(2, 1));
            processVoltagePeRegisterValues(blockValues.mid(3, 1));
            processCurrentPhaseARegisterValues(blockValues.mid(4, 1));
            processCurrentPhaseBRegisterValues(blockValues.mid(5, 1));
            processCurrentPhaseCRegisterValues(blockValues.mid(6, 1));
            processCurrentPeRegisterValues(blockValues.mid(7, 1));
            processPowerPhaseARegisterValues(blockValues.mid(8, 1));
            processPowerPhaseBRegisterValues(blockValues.mid(9, 1));
            processPowerPhaseCRegisterValues(blockValues.mid(10, 1));
            processTotalPowerRegisterValues(blockValues.mid(11, 1));
            processFrequencyPhaseARegisterValues(blockValues.mid(12, 1));
            processFrequencyPhaseBRegisterValues(blockValues.mid(13, 1));
            processFrequencyPhaseCRegisterValues(blockValues.mid(14, 1));
            processSessionEnergyRegisterValues(blockValues.mid(15, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while updating block \"meterValues\" registers" << error << reply->errorString();
    });
}

void SolaxEvcModbusTcpConnection::updateWallboxStatusBlock()
{
    // Update register block "wallboxStatus"
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read block \"wallboxStatus\" registers from:" << 4124 << "size:" << 9;
    QModbusReply *reply = readBlockWallboxStatus();
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading block \"wallboxStatus\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from reading block \"wallboxStatus\" register" << 4124 << "size:" << 9 << blockValues;
            processTempPcbRegisterValues(blockValues.mid(0, 1));
            processStateRegisterValues(blockValues.mid(1, 1));
            processFaultCodeRegisterValues(blockValues.mid(2, 2));
            processTypeCaseRegisterValues(blockValues.mid(4, 1));
            processTypePowerRegisterValues(blockValues.mid(5, 1));
            processTypePhaseRegisterValues(blockValues.mid(6, 1));
            processTypeChargerRegisterValues(blockValues.mid(7, 1));
            processTypeScreenRegisterValues(blockValues.mid(8, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while updating block \"wallboxStatus\" registers" << error << reply->errorString();
    });
}

void SolaxEvcModbusTcpConnection::updateDeviceSettingsBlock()
{
    // Update register block "deviceSettings"
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Read block \"deviceSettings\" registers from:" << 4109 << "size:" << 10;
    QModbusReply *reply = readBlockDeviceSettings();
    if (!reply) {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Error occurred while reading block \"deviceSettings\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxEvcModbusTcpConnection()) << "<-- Response from reading block \"deviceSettings\" register" << 4109 << "size:" << 10 << blockValues;
            processDeviceModeRegisterValues(blockValues.mid(0, 1));
            processEcoGearRegisterValues(blockValues.mid(1, 1));
            processGreenGearRegisterValues(blockValues.mid(2, 1));
            processStartChargeModeRegisterValues(blockValues.mid(3, 1));
            processOverVoltSetRegisterValues(blockValues.mid(4, 1));
            processUnderVoltSetRegisterValues(blockValues.mid(5, 1));
            processBoostModeRegisterValues(blockValues.mid(6, 1));
            processMainBreakerLimitRegisterValues(blockValues.mid(7, 1));
            processElectronicLockRegisterValues(blockValues.mid(8, 1));
            processCardActivateSwitchRegisterValues(blockValues.mid(9, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while updating block \"deviceSettings\" registers" << error << reply->errorString();
    });
}

QModbusReply *SolaxEvcModbusTcpConnection::readSerialNumber()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4096, 14);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readDeviceType()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4108, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readTotalEnergy()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4121, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readDataHubChargeCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4132, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readFirmwareVersion()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4133, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readControlCommand()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4135, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readMaxCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4136, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readChargingTime()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4139, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readChargePhase()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4155, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readMinCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4159, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readSlaveAddress()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4160, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readVoltagePhaseA()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4096, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readVoltagePhaseB()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4097, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readVoltagePhaseC()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4098, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readVoltagePe()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4099, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readCurrentPhaseA()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4100, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readCurrentPhaseB()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4101, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readCurrentPhaseC()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4102, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readCurrentPe()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4103, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readPowerPhaseA()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4104, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readPowerPhaseB()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4105, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readPowerPhaseC()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4106, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readTotalPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4107, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readFrequencyPhaseA()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4108, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readFrequencyPhaseB()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4109, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readFrequencyPhaseC()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4110, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readSessionEnergy()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4111, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readTempPcb()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4124, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4125, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readFaultCode()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4126, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readTypeCase()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4128, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readTypePower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4129, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readTypePhase()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4130, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readTypeCharger()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4131, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readTypeScreen()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4132, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readDeviceMode()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4109, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readEcoGear()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4110, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readGreenGear()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4111, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readStartChargeMode()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4112, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readOverVoltSet()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4113, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readUnderVoltSet()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4114, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readBoostMode()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4115, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readMainBreakerLimit()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4116, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readElectronicLock()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4117, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readCardActivateSwitch()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4118, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readBlockMeterValues()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4096, 16);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readBlockWallboxStatus()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4124, 9);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxEvcModbusTcpConnection::readBlockDeviceSettings()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4109, 10);
    return sendReadRequest(request, m_slaveId);
}

void SolaxEvcModbusTcpConnection::processSerialNumberRegisterValues(const QVector<quint16> values)
{
    QString receivedSerialNumber = ModbusDataUtils::convertToString(values);
    emit serialNumberReadFinished(receivedSerialNumber);

    if (m_serialNumber != receivedSerialNumber) {
        m_serialNumber = receivedSerialNumber;
        emit serialNumberChanged(m_serialNumber);
    }
}

void SolaxEvcModbusTcpConnection::processDeviceTypeRegisterValues(const QVector<quint16> values)
{
    quint16 receivedDeviceType = ModbusDataUtils::convertToUInt16(values);
    emit deviceTypeReadFinished(receivedDeviceType);

    if (m_deviceType != receivedDeviceType) {
        m_deviceType = receivedDeviceType;
        emit deviceTypeChanged(m_deviceType);
    }
}

void SolaxEvcModbusTcpConnection::processTotalEnergyRegisterValues(const QVector<quint16> values)
{
    float receivedTotalEnergy = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -1);
    emit totalEnergyReadFinished(receivedTotalEnergy);

    if (m_totalEnergy != receivedTotalEnergy) {
        m_totalEnergy = receivedTotalEnergy;
        emit totalEnergyChanged(m_totalEnergy);
    }
}

void SolaxEvcModbusTcpConnection::processDataHubChargeCurrentRegisterValues(const QVector<quint16> values)
{
    float receivedDataHubChargeCurrent = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit DataHubChargeCurrentReadFinished(receivedDataHubChargeCurrent);

    if (m_DataHubChargeCurrent != receivedDataHubChargeCurrent) {
        m_DataHubChargeCurrent = receivedDataHubChargeCurrent;
        emit DataHubChargeCurrentChanged(m_DataHubChargeCurrent);
    }
}

void SolaxEvcModbusTcpConnection::processFirmwareVersionRegisterValues(const QVector<quint16> values)
{
    quint16 receivedFirmwareVersion = ModbusDataUtils::convertToUInt16(values);
    emit firmwareVersionReadFinished(receivedFirmwareVersion);

    if (m_firmwareVersion != receivedFirmwareVersion) {
        m_firmwareVersion = receivedFirmwareVersion;
        emit firmwareVersionChanged(m_firmwareVersion);
    }
}

void SolaxEvcModbusTcpConnection::processControlCommandRegisterValues(const QVector<quint16> values)
{
    ControlCommand receivedControlCommand = static_cast<ControlCommand>(ModbusDataUtils::convertToUInt16(values));
    emit controlCommandReadFinished(receivedControlCommand);

    if (m_controlCommand != receivedControlCommand) {
        m_controlCommand = receivedControlCommand;
        emit controlCommandChanged(m_controlCommand);
    }
}

void SolaxEvcModbusTcpConnection::processMaxCurrentRegisterValues(const QVector<quint16> values)
{
    float receivedMaxCurrent = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit MaxCurrentReadFinished(receivedMaxCurrent);

    if (m_MaxCurrent != receivedMaxCurrent) {
        m_MaxCurrent = receivedMaxCurrent;
        emit MaxCurrentChanged(m_MaxCurrent);
    }
}

void SolaxEvcModbusTcpConnection::processChargingTimeRegisterValues(const QVector<quint16> values)
{
    quint32 receivedChargingTime = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit chargingTimeReadFinished(receivedChargingTime);

    if (m_chargingTime != receivedChargingTime) {
        m_chargingTime = receivedChargingTime;
        emit chargingTimeChanged(m_chargingTime);
    }
}

void SolaxEvcModbusTcpConnection::processChargePhaseRegisterValues(const QVector<quint16> values)
{
    ChargePhase receivedChargePhase = static_cast<ChargePhase>(ModbusDataUtils::convertToUInt16(values));
    emit chargePhaseReadFinished(receivedChargePhase);

    if (m_chargePhase != receivedChargePhase) {
        m_chargePhase = receivedChargePhase;
        emit chargePhaseChanged(m_chargePhase);
    }
}

void SolaxEvcModbusTcpConnection::processMinCurrentRegisterValues(const QVector<quint16> values)
{
    float receivedMinCurrent = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit MinCurrentReadFinished(receivedMinCurrent);

    if (m_MinCurrent != receivedMinCurrent) {
        m_MinCurrent = receivedMinCurrent;
        emit MinCurrentChanged(m_MinCurrent);
    }
}

void SolaxEvcModbusTcpConnection::processSlaveAddressRegisterValues(const QVector<quint16> values)
{
    quint16 receivedSlaveAddress = ModbusDataUtils::convertToUInt16(values);
    emit slaveAddressReadFinished(receivedSlaveAddress);

    if (m_slaveAddress != receivedSlaveAddress) {
        m_slaveAddress = receivedSlaveAddress;
        emit slaveAddressChanged(m_slaveAddress);
    }
}

void SolaxEvcModbusTcpConnection::processVoltagePhaseARegisterValues(const QVector<quint16> values)
{
    float receivedVoltagePhaseA = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit voltagePhaseAReadFinished(receivedVoltagePhaseA);

    if (m_voltagePhaseA != receivedVoltagePhaseA) {
        m_voltagePhaseA = receivedVoltagePhaseA;
        emit voltagePhaseAChanged(m_voltagePhaseA);
    }
}

void SolaxEvcModbusTcpConnection::processVoltagePhaseBRegisterValues(const QVector<quint16> values)
{
    float receivedVoltagePhaseB = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit voltagePhaseBReadFinished(receivedVoltagePhaseB);

    if (m_voltagePhaseB != receivedVoltagePhaseB) {
        m_voltagePhaseB = receivedVoltagePhaseB;
        emit voltagePhaseBChanged(m_voltagePhaseB);
    }
}

void SolaxEvcModbusTcpConnection::processVoltagePhaseCRegisterValues(const QVector<quint16> values)
{
    float receivedVoltagePhaseC = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit voltagePhaseCReadFinished(receivedVoltagePhaseC);

    if (m_voltagePhaseC != receivedVoltagePhaseC) {
        m_voltagePhaseC = receivedVoltagePhaseC;
        emit voltagePhaseCChanged(m_voltagePhaseC);
    }
}

void SolaxEvcModbusTcpConnection::processVoltagePeRegisterValues(const QVector<quint16> values)
{
    float receivedVoltagePe = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit voltagePeReadFinished(receivedVoltagePe);

    if (m_voltagePe != receivedVoltagePe) {
        m_voltagePe = receivedVoltagePe;
        emit voltagePeChanged(m_voltagePe);
    }
}

void SolaxEvcModbusTcpConnection::processCurrentPhaseARegisterValues(const QVector<quint16> values)
{
    float receivedCurrentPhaseA = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit currentPhaseAReadFinished(receivedCurrentPhaseA);

    if (m_currentPhaseA != receivedCurrentPhaseA) {
        m_currentPhaseA = receivedCurrentPhaseA;
        emit currentPhaseAChanged(m_currentPhaseA);
    }
}

void SolaxEvcModbusTcpConnection::processCurrentPhaseBRegisterValues(const QVector<quint16> values)
{
    float receivedCurrentPhaseB = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit currentPhaseBReadFinished(receivedCurrentPhaseB);

    if (m_currentPhaseB != receivedCurrentPhaseB) {
        m_currentPhaseB = receivedCurrentPhaseB;
        emit currentPhaseBChanged(m_currentPhaseB);
    }
}

void SolaxEvcModbusTcpConnection::processCurrentPhaseCRegisterValues(const QVector<quint16> values)
{
    float receivedCurrentPhaseC = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit currentPhaseCReadFinished(receivedCurrentPhaseC);

    if (m_currentPhaseC != receivedCurrentPhaseC) {
        m_currentPhaseC = receivedCurrentPhaseC;
        emit currentPhaseCChanged(m_currentPhaseC);
    }
}

void SolaxEvcModbusTcpConnection::processCurrentPeRegisterValues(const QVector<quint16> values)
{
    float receivedCurrentPe = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -3);
    emit currentPeReadFinished(receivedCurrentPe);

    if (m_currentPe != receivedCurrentPe) {
        m_currentPe = receivedCurrentPe;
        emit currentPeChanged(m_currentPe);
    }
}

void SolaxEvcModbusTcpConnection::processPowerPhaseARegisterValues(const QVector<quint16> values)
{
    quint16 receivedPowerPhaseA = ModbusDataUtils::convertToUInt16(values);
    emit powerPhaseAReadFinished(receivedPowerPhaseA);

    if (m_powerPhaseA != receivedPowerPhaseA) {
        m_powerPhaseA = receivedPowerPhaseA;
        emit powerPhaseAChanged(m_powerPhaseA);
    }
}

void SolaxEvcModbusTcpConnection::processPowerPhaseBRegisterValues(const QVector<quint16> values)
{
    quint16 receivedPowerPhaseB = ModbusDataUtils::convertToUInt16(values);
    emit powerPhaseBReadFinished(receivedPowerPhaseB);

    if (m_powerPhaseB != receivedPowerPhaseB) {
        m_powerPhaseB = receivedPowerPhaseB;
        emit powerPhaseBChanged(m_powerPhaseB);
    }
}

void SolaxEvcModbusTcpConnection::processPowerPhaseCRegisterValues(const QVector<quint16> values)
{
    quint16 receivedPowerPhaseC = ModbusDataUtils::convertToUInt16(values);
    emit powerPhaseCReadFinished(receivedPowerPhaseC);

    if (m_powerPhaseC != receivedPowerPhaseC) {
        m_powerPhaseC = receivedPowerPhaseC;
        emit powerPhaseCChanged(m_powerPhaseC);
    }
}

void SolaxEvcModbusTcpConnection::processTotalPowerRegisterValues(const QVector<quint16> values)
{
    quint16 receivedTotalPower = ModbusDataUtils::convertToUInt16(values);
    emit totalPowerReadFinished(receivedTotalPower);

    if (m_totalPower != receivedTotalPower) {
        m_totalPower = receivedTotalPower;
        emit totalPowerChanged(m_totalPower);
    }
}

void SolaxEvcModbusTcpConnection::processFrequencyPhaseARegisterValues(const QVector<quint16> values)
{
    float receivedFrequencyPhaseA = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit frequencyPhaseAReadFinished(receivedFrequencyPhaseA);

    if (m_frequencyPhaseA != receivedFrequencyPhaseA) {
        m_frequencyPhaseA = receivedFrequencyPhaseA;
        emit frequencyPhaseAChanged(m_frequencyPhaseA);
    }
}

void SolaxEvcModbusTcpConnection::processFrequencyPhaseBRegisterValues(const QVector<quint16> values)
{
    float receivedFrequencyPhaseB = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit frequencyPhaseBReadFinished(receivedFrequencyPhaseB);

    if (m_frequencyPhaseB != receivedFrequencyPhaseB) {
        m_frequencyPhaseB = receivedFrequencyPhaseB;
        emit frequencyPhaseBChanged(m_frequencyPhaseB);
    }
}

void SolaxEvcModbusTcpConnection::processFrequencyPhaseCRegisterValues(const QVector<quint16> values)
{
    float receivedFrequencyPhaseC = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit frequencyPhaseCReadFinished(receivedFrequencyPhaseC);

    if (m_frequencyPhaseC != receivedFrequencyPhaseC) {
        m_frequencyPhaseC = receivedFrequencyPhaseC;
        emit frequencyPhaseCChanged(m_frequencyPhaseC);
    }
}

void SolaxEvcModbusTcpConnection::processSessionEnergyRegisterValues(const QVector<quint16> values)
{
    float receivedSessionEnergy = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit sessionEnergyReadFinished(receivedSessionEnergy);

    if (m_sessionEnergy != receivedSessionEnergy) {
        m_sessionEnergy = receivedSessionEnergy;
        emit sessionEnergyChanged(m_sessionEnergy);
    }
}

void SolaxEvcModbusTcpConnection::processTempPcbRegisterValues(const QVector<quint16> values)
{
    qint16 receivedTempPcb = ModbusDataUtils::convertToInt16(values);
    emit tempPcbReadFinished(receivedTempPcb);

    if (m_tempPcb != receivedTempPcb) {
        m_tempPcb = receivedTempPcb;
        emit tempPcbChanged(m_tempPcb);
    }
}

void SolaxEvcModbusTcpConnection::processStateRegisterValues(const QVector<quint16> values)
{
    State receivedState = static_cast<State>(ModbusDataUtils::convertToUInt16(values));
    emit stateReadFinished(receivedState);

    if (m_state != receivedState) {
        m_state = receivedState;
        emit stateChanged(m_state);
    }
}

void SolaxEvcModbusTcpConnection::processFaultCodeRegisterValues(const QVector<quint16> values)
{
    quint32 receivedFaultCode = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit faultCodeReadFinished(receivedFaultCode);

    if (m_faultCode != receivedFaultCode) {
        m_faultCode = receivedFaultCode;
        emit faultCodeChanged(m_faultCode);
    }
}

void SolaxEvcModbusTcpConnection::processTypeCaseRegisterValues(const QVector<quint16> values)
{
    quint16 receivedTypeCase = ModbusDataUtils::convertToUInt16(values);
    emit typeCaseReadFinished(receivedTypeCase);

    if (m_typeCase != receivedTypeCase) {
        m_typeCase = receivedTypeCase;
        emit typeCaseChanged(m_typeCase);
    }
}

void SolaxEvcModbusTcpConnection::processTypePowerRegisterValues(const QVector<quint16> values)
{
    quint16 receivedTypePower = ModbusDataUtils::convertToUInt16(values);
    emit typePowerReadFinished(receivedTypePower);

    if (m_typePower != receivedTypePower) {
        m_typePower = receivedTypePower;
        emit typePowerChanged(m_typePower);
    }
}

void SolaxEvcModbusTcpConnection::processTypePhaseRegisterValues(const QVector<quint16> values)
{
    quint16 receivedTypePhase = ModbusDataUtils::convertToUInt16(values);
    emit typePhaseReadFinished(receivedTypePhase);

    if (m_typePhase != receivedTypePhase) {
        m_typePhase = receivedTypePhase;
        emit typePhaseChanged(m_typePhase);
    }
}

void SolaxEvcModbusTcpConnection::processTypeChargerRegisterValues(const QVector<quint16> values)
{
    quint16 receivedTypeCharger = ModbusDataUtils::convertToUInt16(values);
    emit typeChargerReadFinished(receivedTypeCharger);

    if (m_typeCharger != receivedTypeCharger) {
        m_typeCharger = receivedTypeCharger;
        emit typeChargerChanged(m_typeCharger);
    }
}

void SolaxEvcModbusTcpConnection::processTypeScreenRegisterValues(const QVector<quint16> values)
{
    quint16 receivedTypeScreen = ModbusDataUtils::convertToUInt16(values);
    emit typeScreenReadFinished(receivedTypeScreen);

    if (m_typeScreen != receivedTypeScreen) {
        m_typeScreen = receivedTypeScreen;
        emit typeScreenChanged(m_typeScreen);
    }
}

void SolaxEvcModbusTcpConnection::processDeviceModeRegisterValues(const QVector<quint16> values)
{
    quint16 receivedDeviceMode = ModbusDataUtils::convertToUInt16(values);
    emit deviceModeReadFinished(receivedDeviceMode);

    if (m_deviceMode != receivedDeviceMode) {
        m_deviceMode = receivedDeviceMode;
        emit deviceModeChanged(m_deviceMode);
    }
}

void SolaxEvcModbusTcpConnection::processEcoGearRegisterValues(const QVector<quint16> values)
{
    quint16 receivedEcoGear = ModbusDataUtils::convertToUInt16(values);
    emit ecoGearReadFinished(receivedEcoGear);

    if (m_ecoGear != receivedEcoGear) {
        m_ecoGear = receivedEcoGear;
        emit ecoGearChanged(m_ecoGear);
    }
}

void SolaxEvcModbusTcpConnection::processGreenGearRegisterValues(const QVector<quint16> values)
{
    quint16 receivedGreenGear = ModbusDataUtils::convertToUInt16(values);
    emit greenGearReadFinished(receivedGreenGear);

    if (m_greenGear != receivedGreenGear) {
        m_greenGear = receivedGreenGear;
        emit greenGearChanged(m_greenGear);
    }
}

void SolaxEvcModbusTcpConnection::processStartChargeModeRegisterValues(const QVector<quint16> values)
{
    quint16 receivedStartChargeMode = ModbusDataUtils::convertToUInt16(values);
    emit startChargeModeReadFinished(receivedStartChargeMode);

    if (m_startChargeMode != receivedStartChargeMode) {
        m_startChargeMode = receivedStartChargeMode;
        emit startChargeModeChanged(m_startChargeMode);
    }
}

void SolaxEvcModbusTcpConnection::processOverVoltSetRegisterValues(const QVector<quint16> values)
{
    quint16 receivedOverVoltSet = ModbusDataUtils::convertToUInt16(values);
    emit overVoltSetReadFinished(receivedOverVoltSet);

    if (m_overVoltSet != receivedOverVoltSet) {
        m_overVoltSet = receivedOverVoltSet;
        emit overVoltSetChanged(m_overVoltSet);
    }
}

void SolaxEvcModbusTcpConnection::processUnderVoltSetRegisterValues(const QVector<quint16> values)
{
    quint16 receivedUnderVoltSet = ModbusDataUtils::convertToUInt16(values);
    emit underVoltSetReadFinished(receivedUnderVoltSet);

    if (m_underVoltSet != receivedUnderVoltSet) {
        m_underVoltSet = receivedUnderVoltSet;
        emit underVoltSetChanged(m_underVoltSet);
    }
}

void SolaxEvcModbusTcpConnection::processBoostModeRegisterValues(const QVector<quint16> values)
{
    quint16 receivedBoostMode = ModbusDataUtils::convertToUInt16(values);
    emit boostModeReadFinished(receivedBoostMode);

    if (m_boostMode != receivedBoostMode) {
        m_boostMode = receivedBoostMode;
        emit boostModeChanged(m_boostMode);
    }
}

void SolaxEvcModbusTcpConnection::processMainBreakerLimitRegisterValues(const QVector<quint16> values)
{
    quint16 receivedMainBreakerLimit = ModbusDataUtils::convertToUInt16(values);
    emit mainBreakerLimitReadFinished(receivedMainBreakerLimit);

    if (m_mainBreakerLimit != receivedMainBreakerLimit) {
        m_mainBreakerLimit = receivedMainBreakerLimit;
        emit mainBreakerLimitChanged(m_mainBreakerLimit);
    }
}

void SolaxEvcModbusTcpConnection::processElectronicLockRegisterValues(const QVector<quint16> values)
{
    quint16 receivedElectronicLock = ModbusDataUtils::convertToUInt16(values);
    emit electronicLockReadFinished(receivedElectronicLock);

    if (m_electronicLock != receivedElectronicLock) {
        m_electronicLock = receivedElectronicLock;
        emit electronicLockChanged(m_electronicLock);
    }
}

void SolaxEvcModbusTcpConnection::processCardActivateSwitchRegisterValues(const QVector<quint16> values)
{
    quint16 receivedCardActivateSwitch = ModbusDataUtils::convertToUInt16(values);
    emit CardActivateSwitchReadFinished(receivedCardActivateSwitch);

    if (m_CardActivateSwitch != receivedCardActivateSwitch) {
        m_CardActivateSwitch = receivedCardActivateSwitch;
        emit CardActivateSwitchChanged(m_CardActivateSwitch);
    }
}

void SolaxEvcModbusTcpConnection::handleModbusError(QModbusDevice::Error error)
{
    if (error == QModbusDevice::NoError) {
        // Reset the communication counter and we know we can reach the device
        m_communicationFailedCounter = 0;
        if (!m_communicationWorking)
            qCDebug(dcSolaxEvcModbusTcpConnection()) << "Received a reply without any errors. The communication with the device seems to work now.";

        m_communicationWorking = true;
        evaluateReachableState();
    } else {
        m_communicationFailedCounter++;
        if (m_communicationWorking && m_communicationFailedCounter >= m_communicationFailedMax) {
            m_communicationWorking = false;
            qCWarning(dcSolaxEvcModbusTcpConnection()) << "Received" << m_communicationFailedCounter << "errors while communicating with the RTU master. Mark as not reachable until the communication works again.";
            evaluateReachableState();
        }
    }
}

void SolaxEvcModbusTcpConnection::testReachability()
{
    if (m_checkRechableReply)
        return;

    // Try to read the check reachability register firmwareVersion in order to verify if the communication is working or not.
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "--> Test reachability by reading \"Firmware version\" register:" << 4133 << "size:" << 1;
    m_checkRechableReply = readFirmwareVersion();
    if (!m_checkRechableReply) {
        qCDebug(dcSolaxEvcModbusTcpConnection()) << "Error occurred verifying reachability by reading \"Firmware version\" register";
        onReachabilityCheckFailed();
        return;
    }

    if (m_checkRechableReply->isFinished()) {
        m_checkRechableReply->deleteLater(); // Broadcast reply returns immediatly
        m_checkRechableReply = nullptr;
        onReachabilityCheckFailed();
        return;
    }

    connect(m_checkRechableReply, &QModbusReply::finished, this, [this](){
        handleModbusError(m_checkRechableReply->error());
        if (m_checkRechableReply->error() != QModbusDevice::NoError)
            onReachabilityCheckFailed();

        m_checkRechableReply->deleteLater();
        m_checkRechableReply = nullptr;
    });

    connect(m_checkRechableReply, &QModbusReply::errorOccurred, this, [this] (QModbusDevice::Error error){
        qCDebug(dcSolaxEvcModbusTcpConnection()) << "Modbus reply error occurred while verifying reachability by reading \"Firmware version\" register" << error << m_checkRechableReply->errorString();
    });
}

void SolaxEvcModbusTcpConnection::verifyInitFinished()
{
    if (m_pendingInitReplies.isEmpty()) {
        finishInitialization(true);
    }
}

void SolaxEvcModbusTcpConnection::finishInitialization(bool success)
{
    if (success) {
        qCDebug(dcSolaxEvcModbusTcpConnection()) << "Initialization finished of SolaxEvcModbusTcpConnection" << hostAddress().toString() << "finished successfully";
    } else {
        qCWarning(dcSolaxEvcModbusTcpConnection()) << "Initialization finished of SolaxEvcModbusTcpConnection" << hostAddress().toString() << "failed.";
    }

    // Cleanup init
    delete m_initObject;
    m_initObject = nullptr;
    m_pendingInitReplies.clear();

    emit initializationFinished(success);
}

void SolaxEvcModbusTcpConnection::verifyUpdateFinished()
{
    if (m_pendingUpdateReplies.isEmpty()) {
        emit updateFinished();
    }
}

void SolaxEvcModbusTcpConnection::onReachabilityCheckFailed()
{
    m_checkReachableRetriesCount++;

    if (m_checkReachableRetriesCount <= m_checkReachableRetries) {
        qCDebug(dcSolaxEvcModbusTcpConnection()) << "Reachability test failed. Retry in on second" << m_checkReachableRetriesCount << "/" << m_checkReachableRetries;
        QTimer::singleShot(1000, this, &SolaxEvcModbusTcpConnection::testReachability);
        return;
    }

    // The test reachability method failed, not retrying any more
    emit checkReachabilityFailed();
}

void SolaxEvcModbusTcpConnection::evaluateReachableState()
{
    qCDebug(dcSolaxEvcModbusTcpConnection()) << "## Evaluate reachable state";
    bool reachable = m_communicationWorking && connected();
    if (m_reachable == reachable)
        return;

    qCDebug(dcSolaxEvcModbusTcpConnection()) << "## Reachable State" << reachable;
    m_reachable = reachable;
    emit reachableChanged(m_reachable);
    m_checkReachableRetriesCount = 0;
}

QDebug operator<<(QDebug debug, SolaxEvcModbusTcpConnection *solaxEvcModbusTcpConnection)
{
    debug.nospace().noquote() << "SolaxEvcModbusTcpConnection(" << solaxEvcModbusTcpConnection->hostAddress().toString() << ":" << solaxEvcModbusTcpConnection->port() << ")" << "\n";
    debug.nospace().noquote() << "    - Version: " << solaxEvcModbusTcpConnection->serialNumber() << "\n";
    debug.nospace().noquote() << "    - Device type: " << solaxEvcModbusTcpConnection->deviceType() << "\n";
    debug.nospace().noquote() << "    - Accumulated charging energy: " << solaxEvcModbusTcpConnection->totalEnergy() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Data hub charge current: " << solaxEvcModbusTcpConnection->DataHubChargeCurrent() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Firmware version: " << solaxEvcModbusTcpConnection->firmwareVersion() << "\n";
    debug.nospace().noquote() << "    - Control command: " << solaxEvcModbusTcpConnection->controlCommand() << "\n";
    debug.nospace().noquote() << "    - Maximum AC line current: " << solaxEvcModbusTcpConnection->MaxCurrent() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Duration of current charging session: " << solaxEvcModbusTcpConnection->chargingTime() << " [s]" << "\n";
    debug.nospace().noquote() << "    - Wallbox phase configuration: " << solaxEvcModbusTcpConnection->chargePhase() << "\n";
    debug.nospace().noquote() << "    - Minimum AC line current: " << solaxEvcModbusTcpConnection->MinCurrent() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Own 485 address: " << solaxEvcModbusTcpConnection->slaveAddress() << "\n";
    debug.nospace().noquote() << "    - Voltage phase A: " << solaxEvcModbusTcpConnection->voltagePhaseA() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Voltage phase B: " << solaxEvcModbusTcpConnection->voltagePhaseB() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Voltage phase C: " << solaxEvcModbusTcpConnection->voltagePhaseC() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Voltage PE: " << solaxEvcModbusTcpConnection->voltagePe() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Current phase A: " << solaxEvcModbusTcpConnection->currentPhaseA() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Current phase B: " << solaxEvcModbusTcpConnection->currentPhaseB() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Current phase C: " << solaxEvcModbusTcpConnection->currentPhaseC() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Current PE: " << solaxEvcModbusTcpConnection->currentPe() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Power phase A: " << solaxEvcModbusTcpConnection->powerPhaseA() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Power phase B: " << solaxEvcModbusTcpConnection->powerPhaseB() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Power phase C: " << solaxEvcModbusTcpConnection->powerPhaseC() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Total charging power: " << solaxEvcModbusTcpConnection->totalPower() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Frequency phase A: " << solaxEvcModbusTcpConnection->frequencyPhaseA() << " [Hz]" << "\n";
    debug.nospace().noquote() << "    - Frequency phase B: " << solaxEvcModbusTcpConnection->frequencyPhaseB() << " [Hz]" << "\n";
    debug.nospace().noquote() << "    - Frequency phase C: " << solaxEvcModbusTcpConnection->frequencyPhaseC() << " [Hz]" << "\n";
    debug.nospace().noquote() << "    - Single charge energy: " << solaxEvcModbusTcpConnection->sessionEnergy() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - PCB temperature: " << solaxEvcModbusTcpConnection->tempPcb() << " [C]" << "\n";
    debug.nospace().noquote() << "    - State: " << solaxEvcModbusTcpConnection->state() << "\n";
    debug.nospace().noquote() << "    - Fault code: " << solaxEvcModbusTcpConnection->faultCode() << "\n";
    debug.nospace().noquote() << "    - Wallbox model case type: " << solaxEvcModbusTcpConnection->typeCase() << "\n";
    debug.nospace().noquote() << "    - Wallbox is 7kW, 11kW or 22kW: " << solaxEvcModbusTcpConnection->typePower() << "\n";
    debug.nospace().noquote() << "    - Wallbox is single or three phase: " << solaxEvcModbusTcpConnection->typePhase() << "\n";
    debug.nospace().noquote() << "    - Wallbox is type home or OCPP: " << solaxEvcModbusTcpConnection->typeCharger() << "\n";
    debug.nospace().noquote() << "    - Wallbox model has screen or not: " << solaxEvcModbusTcpConnection->typeScreen() << "\n";
    debug.nospace().noquote() << "    - Device mode: " << solaxEvcModbusTcpConnection->deviceMode() << "\n";
    debug.nospace().noquote() << "    - ECO gear: " << solaxEvcModbusTcpConnection->ecoGear() << "\n";
    debug.nospace().noquote() << "    - Green gear: " << solaxEvcModbusTcpConnection->greenGear() << "\n";
    debug.nospace().noquote() << "    - Start charge mode: " << solaxEvcModbusTcpConnection->startChargeMode() << "\n";
    debug.nospace().noquote() << "    - Over voltage setting: " << solaxEvcModbusTcpConnection->overVoltSet() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Under voltage setting: " << solaxEvcModbusTcpConnection->underVoltSet() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Boost mode: " << solaxEvcModbusTcpConnection->boostMode() << "\n";
    debug.nospace().noquote() << "    - Main breaker limit: " << solaxEvcModbusTcpConnection->mainBreakerLimit() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Electronic Lock: " << solaxEvcModbusTcpConnection->electronicLock() << "\n";
    debug.nospace().noquote() << "    - Card activate switch: " << solaxEvcModbusTcpConnection->CardActivateSwitch() << "\n";
    return debug.quote().space();
}

