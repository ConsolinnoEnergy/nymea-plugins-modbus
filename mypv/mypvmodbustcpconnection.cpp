/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Copyright 2013 - 2024, nymea GmbH
* Contact: contact@nymea.io
*
* This fileDescriptor is part of nymea.
* This project including source code and documentation is protected by
* copyright law, and remains the property of nymea GmbH. All rights, including
* reproduction, publication, editing and translation, are reserved. The use of
* this project is subject to the terms of a license agreement to be concluded
* with nymea GmbH in accordance with the terms of use of nymea GmbH, available
* under https://nymea.io/license
*
* GNU Lesser General Public License Usage
* Alternatively, this project may be redistributed and/or modified under the
* terms of the GNU Lesser General Public License as published by the Free
* Software Foundation; version 3. This project is distributed in the hope that
* it will be useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this project. If not, see <https://www.gnu.org/licenses/>.
*
* For any further details and any questions please contact us under
* contact@nymea.io or see our FAQ/Licensing Information on
* https://nymea.io/license/faq
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WARNING
*
* This file has been autogenerated. Any changes in this file may be overwritten.
* If you want to change something, update the register json or the tool.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


#include "mypvmodbustcpconnection.h"
#include <loggingcategories.h>
#include <math.h>
#include <QTimer>

NYMEA_LOGGING_CATEGORY(dcMyPvModbusTcpConnection, "MyPvModbusTcpConnection")

MyPvModbusTcpConnection::MyPvModbusTcpConnection(const QHostAddress &hostAddress, uint port, quint16 slaveId, QObject *parent) :
    ModbusTCPMaster(hostAddress, port, parent),
    m_slaveId(slaveId)
{
    connect(this, &ModbusTCPMaster::connectionStateChanged, this, [this](bool status){
        if (status) {
           qCDebug(dcMyPvModbusTcpConnection()) << "Modbus TCP connection" << m_hostAddress.toString() << "connected. Start testing if the connection is reachable...";
            // Cleanup before starting to initialize
            m_pendingInitReplies.clear();
            m_pendingUpdateReplies.clear();
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
            testReachability();
        } else {
            qCWarning(dcMyPvModbusTcpConnection()) << "Modbus TCP connection diconnected from" << m_hostAddress.toString() << ". The connection is not reachable any more.";
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
        }

        evaluateReachableState();
    });
}

bool MyPvModbusTcpConnection::reachable() const
{
    return m_reachable;
}

uint MyPvModbusTcpConnection::checkReachableRetries() const
{
    return m_checkReachableRetries;
}

void MyPvModbusTcpConnection::setCheckReachableRetries(uint checkReachableRetries)
{
    if (m_checkReachableRetries == checkReachableRetries)
        return;

    m_checkReachableRetries = checkReachableRetries;
    emit checkReachableRetriesChanged(m_checkReachableRetries);
}

ModbusDataUtils::ByteOrder MyPvModbusTcpConnection::endianness() const
{
    return m_endianness;
}

void MyPvModbusTcpConnection::setEndianness(ModbusDataUtils::ByteOrder endianness)
{
    if (m_endianness == endianness)
        return;

    m_endianness = endianness;
    emit endiannessChanged(m_endianness);
}

quint16 MyPvModbusTcpConnection::currentPower() const
{
    return m_currentPower;
}

QModbusReply *MyPvModbusTcpConnection::setCurrentPower(quint16 currentPower)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(currentPower);
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Write \"Current power\" register:" << 1000 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1000, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

float MyPvModbusTcpConnection::externalTemperature() const
{
    return m_externalTemperature;
}

float MyPvModbusTcpConnection::waterTemperature() const
{
    return m_waterTemperature;
}

float MyPvModbusTcpConnection::targetWaterTemperature() const
{
    return m_targetWaterTemperature;
}

MyPvModbusTcpConnection::ElwaStatus MyPvModbusTcpConnection::elwaStatus() const
{
    return m_elwaStatus;
}

quint16 MyPvModbusTcpConnection::manualStart() const
{
    return m_manualStart;
}

QModbusReply *MyPvModbusTcpConnection::setManualStart(quint16 manualStart)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(manualStart);
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Write \"Manual start\" register:" << 1012 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1012, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 MyPvModbusTcpConnection::deviceNumber() const
{
    return m_deviceNumber;
}

QModbusReply *MyPvModbusTcpConnection::setDeviceNumber(quint16 deviceNumber)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(deviceNumber);
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Write \"AC ELWA Number\" register:" << 1013 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1013, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 MyPvModbusTcpConnection::maxPower() const
{
    return m_maxPower;
}

QModbusReply *MyPvModbusTcpConnection::setMaxPower(quint16 maxPower)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(maxPower);
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Write \"Maximum power\" register:" << 1014 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1014, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

qint16 MyPvModbusTcpConnection::meterPower() const
{
    return m_meterPower;
}

QVector<quint16> MyPvModbusTcpConnection::dummy0() const
{
    return m_dummy0;
}

qint16 MyPvModbusTcpConnection::immHeaterPower() const
{
    return m_immHeaterPower;
}

qint16 MyPvModbusTcpConnection::auxRelayPower() const
{
    return m_auxRelayPower;
}

quint16 MyPvModbusTcpConnection::powerTimeout() const
{
    return m_powerTimeout;
}

QModbusReply *MyPvModbusTcpConnection::setPowerTimeout(quint16 powerTimeout)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(powerTimeout);
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Write \"Timeout of set power\" register:" << 1004 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1004, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 MyPvModbusTcpConnection::boostMode() const
{
    return m_boostMode;
}

QModbusReply *MyPvModbusTcpConnection::setBoostMode(quint16 boostMode)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(boostMode);
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Write \"Boost mode\" register:" << 1005 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1005, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

float MyPvModbusTcpConnection::backTemperature() const
{
    return m_backTemperature;
}

QModbusReply *MyPvModbusTcpConnection::setBackTemperature(float backTemperature)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(static_cast<quint16>(backTemperature  * 1.0 / pow(10, -1)));
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Write \"Backup target temperature\" register:" << 1006 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1006, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

bool MyPvModbusTcpConnection::initialize()
{
    if (!m_reachable) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Tried to initialize but the device is not to be reachable.";
        return false;
    }
    // No init registers defined. Nothing to be done and we are finished.
    emit initializationFinished(true);
    return true;
}

bool MyPvModbusTcpConnection::update()
{
    if (!connected())
        return false;

    if (!m_pendingUpdateReplies.isEmpty()) {
        qCDebug(dcMyPvModbusTcpConnection()) << "Tried to update but there are still some update replies pending. Waiting for them to be finished...";
        return true;
    }

    QModbusReply *reply = nullptr;

    // Read Current power
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Read \"Current power\" register:" << 1000 << "size:" << 1;
    reply = readCurrentPower();
    if (!reply) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Error occurred while reading \"Current power\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcMyPvModbusTcpConnection()) << "<-- Response from \"Current power\" register" << 1000 << "size:" << 1 << unit.values();
        processCurrentPowerRegisterValues(unit.values());
        update2();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while reading \"Current power\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    return true;
}

void MyPvModbusTcpConnection::update2()
{
    QModbusReply *reply = nullptr;

    // Read External temperature sensor
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Read \"External temperature sensor\" register:" << 1030 << "size:" << 1;
    reply = readExternalTemperature();
    if (!reply) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Error occurred while reading \"External temperature sensor\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcMyPvModbusTcpConnection()) << "<-- Response from \"External temperature sensor\" register" << 1030 << "size:" << 1 << unit.values();
        processExternalTemperatureRegisterValues(unit.values());
        update3();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while reading \"External temperature sensor\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void MyPvModbusTcpConnection::update3()
{
    QModbusReply *reply = nullptr;

    // Read realTimeValues
    reply = readBlockRealTimeValues();
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Read block \"realTimeValues\" registers from:" << 1001 << "size:" << 3;
    if (!reply) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Error occurred while reading block \"realTimeValues\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcMyPvModbusTcpConnection()) << "<-- Response from reading block \"realTimeValues\" register" << 1001 << "size:" << 3 << blockValues;
        processWaterTemperatureRegisterValues(blockValues.mid(0, 1));
        processTargetWaterTemperatureRegisterValues(blockValues.mid(1, 1));
        processElwaStatusRegisterValues(blockValues.mid(2, 1));
        update4();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while updating block \"realTimeValues\" registers" << error << reply->errorString();
    });
}

void MyPvModbusTcpConnection::update4()
{
    QModbusReply *reply = nullptr;

    // Read setPointValues
    reply = readBlockSetPointValues();
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Read block \"setPointValues\" registers from:" << 1012 << "size:" << 3;
    if (!reply) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Error occurred while reading block \"setPointValues\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcMyPvModbusTcpConnection()) << "<-- Response from reading block \"setPointValues\" register" << 1012 << "size:" << 3 << blockValues;
        processManualStartRegisterValues(blockValues.mid(0, 1));
        processDeviceNumberRegisterValues(blockValues.mid(1, 1));
        processMaxPowerRegisterValues(blockValues.mid(2, 1));
        update5();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while updating block \"setPointValues\" registers" << error << reply->errorString();
    });
}

void MyPvModbusTcpConnection::update5()
{
    QModbusReply *reply = nullptr;

    // Read powerValues
    reply = readBlockPowerValues();
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Read block \"powerValues\" registers from:" << 1069 << "size:" << 7;
    if (!reply) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Error occurred while reading block \"powerValues\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcMyPvModbusTcpConnection()) << "<-- Response from reading block \"powerValues\" register" << 1069 << "size:" << 7 << blockValues;
        processMeterPowerRegisterValues(blockValues.mid(0, 1));
        processDummy0RegisterValues(blockValues.mid(1, 4));
        processImmHeaterPowerRegisterValues(blockValues.mid(5, 1));
        processAuxRelayPowerRegisterValues(blockValues.mid(6, 1));
        update6();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while updating block \"powerValues\" registers" << error << reply->errorString();
    });
}

void MyPvModbusTcpConnection::update6()
{
    QModbusReply *reply = nullptr;

    // Read timeoutAndBoost
    reply = readBlockTimeoutAndBoost();
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Read block \"timeoutAndBoost\" registers from:" << 1004 << "size:" << 3;
    if (!reply) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Error occurred while reading block \"timeoutAndBoost\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcMyPvModbusTcpConnection()) << "<-- Response from reading block \"timeoutAndBoost\" register" << 1004 << "size:" << 3 << blockValues;
        processPowerTimeoutRegisterValues(blockValues.mid(0, 1));
        processBoostModeRegisterValues(blockValues.mid(1, 1));
        processBackTemperatureRegisterValues(blockValues.mid(2, 1));
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while updating block \"timeoutAndBoost\" registers" << error << reply->errorString();
    });
}

void MyPvModbusTcpConnection::updateCurrentPower()
{
    // Update registers from Current power
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Read \"Current power\" register:" << 1000 << "size:" << 1;
    QModbusReply *reply = readCurrentPower();
    if (!reply) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Error occurred while reading \"Current power\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcMyPvModbusTcpConnection()) << "<-- Response from \"Current power\" register" << 1000 << "size:" << 1 << unit.values();
            processCurrentPowerRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while updating \"Current power\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void MyPvModbusTcpConnection::updateExternalTemperature()
{
    // Update registers from External temperature sensor
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Read \"External temperature sensor\" register:" << 1030 << "size:" << 1;
    QModbusReply *reply = readExternalTemperature();
    if (!reply) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Error occurred while reading \"External temperature sensor\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcMyPvModbusTcpConnection()) << "<-- Response from \"External temperature sensor\" register" << 1030 << "size:" << 1 << unit.values();
            processExternalTemperatureRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while updating \"External temperature sensor\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void MyPvModbusTcpConnection::updateManualStart()
{
    // Update registers from Manual start
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Read \"Manual start\" register:" << 1012 << "size:" << 1;
    QModbusReply *reply = readManualStart();
    if (!reply) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Error occurred while reading \"Manual start\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcMyPvModbusTcpConnection()) << "<-- Response from \"Manual start\" register" << 1012 << "size:" << 1 << unit.values();
            processManualStartRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while updating \"Manual start\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void MyPvModbusTcpConnection::updateDeviceNumber()
{
    // Update registers from AC ELWA Number
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Read \"AC ELWA Number\" register:" << 1013 << "size:" << 1;
    QModbusReply *reply = readDeviceNumber();
    if (!reply) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Error occurred while reading \"AC ELWA Number\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcMyPvModbusTcpConnection()) << "<-- Response from \"AC ELWA Number\" register" << 1013 << "size:" << 1 << unit.values();
            processDeviceNumberRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while updating \"AC ELWA Number\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void MyPvModbusTcpConnection::updateMaxPower()
{
    // Update registers from Maximum power
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Read \"Maximum power\" register:" << 1014 << "size:" << 1;
    QModbusReply *reply = readMaxPower();
    if (!reply) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Error occurred while reading \"Maximum power\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcMyPvModbusTcpConnection()) << "<-- Response from \"Maximum power\" register" << 1014 << "size:" << 1 << unit.values();
            processMaxPowerRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while updating \"Maximum power\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void MyPvModbusTcpConnection::updateMeterPower()
{
    // Update registers from Power at meter
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Read \"Power at meter\" register:" << 1069 << "size:" << 1;
    QModbusReply *reply = readMeterPower();
    if (!reply) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Error occurred while reading \"Power at meter\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcMyPvModbusTcpConnection()) << "<-- Response from \"Power at meter\" register" << 1069 << "size:" << 1 << unit.values();
            processMeterPowerRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while updating \"Power at meter\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void MyPvModbusTcpConnection::updateDummy0()
{
    // Update registers from Dummy0
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Read \"Dummy0\" register:" << 1070 << "size:" << 4;
    QModbusReply *reply = readDummy0();
    if (!reply) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Error occurred while reading \"Dummy0\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcMyPvModbusTcpConnection()) << "<-- Response from \"Dummy0\" register" << 1070 << "size:" << 4 << unit.values();
            processDummy0RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while updating \"Dummy0\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void MyPvModbusTcpConnection::updateImmHeaterPower()
{
    // Update registers from Power at ELWA immersion heater
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Read \"Power at ELWA immersion heater\" register:" << 1074 << "size:" << 1;
    QModbusReply *reply = readImmHeaterPower();
    if (!reply) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Error occurred while reading \"Power at ELWA immersion heater\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcMyPvModbusTcpConnection()) << "<-- Response from \"Power at ELWA immersion heater\" register" << 1074 << "size:" << 1 << unit.values();
            processImmHeaterPowerRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while updating \"Power at ELWA immersion heater\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void MyPvModbusTcpConnection::updateAuxRelayPower()
{
    // Update registers from Power at AUX relay
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Read \"Power at AUX relay\" register:" << 1075 << "size:" << 1;
    QModbusReply *reply = readAuxRelayPower();
    if (!reply) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Error occurred while reading \"Power at AUX relay\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcMyPvModbusTcpConnection()) << "<-- Response from \"Power at AUX relay\" register" << 1075 << "size:" << 1 << unit.values();
            processAuxRelayPowerRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while updating \"Power at AUX relay\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void MyPvModbusTcpConnection::updateRealTimeValuesBlock()
{
    // Update register block "realTimeValues"
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Read block \"realTimeValues\" registers from:" << 1001 << "size:" << 3;
    QModbusReply *reply = readBlockRealTimeValues();
    if (!reply) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Error occurred while reading block \"realTimeValues\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcMyPvModbusTcpConnection()) << "<-- Response from reading block \"realTimeValues\" register" << 1001 << "size:" << 3 << blockValues;
            processWaterTemperatureRegisterValues(blockValues.mid(0, 1));
            processTargetWaterTemperatureRegisterValues(blockValues.mid(1, 1));
            processElwaStatusRegisterValues(blockValues.mid(2, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while updating block \"realTimeValues\" registers" << error << reply->errorString();
    });
}

void MyPvModbusTcpConnection::updateSetPointValuesBlock()
{
    // Update register block "setPointValues"
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Read block \"setPointValues\" registers from:" << 1012 << "size:" << 3;
    QModbusReply *reply = readBlockSetPointValues();
    if (!reply) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Error occurred while reading block \"setPointValues\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcMyPvModbusTcpConnection()) << "<-- Response from reading block \"setPointValues\" register" << 1012 << "size:" << 3 << blockValues;
            processManualStartRegisterValues(blockValues.mid(0, 1));
            processDeviceNumberRegisterValues(blockValues.mid(1, 1));
            processMaxPowerRegisterValues(blockValues.mid(2, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while updating block \"setPointValues\" registers" << error << reply->errorString();
    });
}

void MyPvModbusTcpConnection::updatePowerValuesBlock()
{
    // Update register block "powerValues"
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Read block \"powerValues\" registers from:" << 1069 << "size:" << 7;
    QModbusReply *reply = readBlockPowerValues();
    if (!reply) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Error occurred while reading block \"powerValues\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcMyPvModbusTcpConnection()) << "<-- Response from reading block \"powerValues\" register" << 1069 << "size:" << 7 << blockValues;
            processMeterPowerRegisterValues(blockValues.mid(0, 1));
            processDummy0RegisterValues(blockValues.mid(1, 4));
            processImmHeaterPowerRegisterValues(blockValues.mid(5, 1));
            processAuxRelayPowerRegisterValues(blockValues.mid(6, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while updating block \"powerValues\" registers" << error << reply->errorString();
    });
}

void MyPvModbusTcpConnection::updateTimeoutAndBoostBlock()
{
    // Update register block "timeoutAndBoost"
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Read block \"timeoutAndBoost\" registers from:" << 1004 << "size:" << 3;
    QModbusReply *reply = readBlockTimeoutAndBoost();
    if (!reply) {
        qCWarning(dcMyPvModbusTcpConnection()) << "Error occurred while reading block \"timeoutAndBoost\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcMyPvModbusTcpConnection()) << "<-- Response from reading block \"timeoutAndBoost\" register" << 1004 << "size:" << 3 << blockValues;
            processPowerTimeoutRegisterValues(blockValues.mid(0, 1));
            processBoostModeRegisterValues(blockValues.mid(1, 1));
            processBackTemperatureRegisterValues(blockValues.mid(2, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while updating block \"timeoutAndBoost\" registers" << error << reply->errorString();
    });
}

QModbusReply *MyPvModbusTcpConnection::readCurrentPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1000, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *MyPvModbusTcpConnection::readExternalTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1030, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *MyPvModbusTcpConnection::readWaterTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1001, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *MyPvModbusTcpConnection::readTargetWaterTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1002, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *MyPvModbusTcpConnection::readElwaStatus()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1003, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *MyPvModbusTcpConnection::readManualStart()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1012, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *MyPvModbusTcpConnection::readDeviceNumber()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1013, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *MyPvModbusTcpConnection::readMaxPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1014, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *MyPvModbusTcpConnection::readMeterPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1069, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *MyPvModbusTcpConnection::readDummy0()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1070, 4);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *MyPvModbusTcpConnection::readImmHeaterPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1074, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *MyPvModbusTcpConnection::readAuxRelayPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1075, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *MyPvModbusTcpConnection::readPowerTimeout()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1004, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *MyPvModbusTcpConnection::readBoostMode()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1005, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *MyPvModbusTcpConnection::readBackTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1006, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *MyPvModbusTcpConnection::readBlockRealTimeValues()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1001, 3);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *MyPvModbusTcpConnection::readBlockSetPointValues()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1012, 3);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *MyPvModbusTcpConnection::readBlockPowerValues()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1069, 7);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *MyPvModbusTcpConnection::readBlockTimeoutAndBoost()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1004, 3);
    return sendReadRequest(request, m_slaveId);
}

void MyPvModbusTcpConnection::processCurrentPowerRegisterValues(const QVector<quint16> values)
{
    quint16 receivedCurrentPower = ModbusDataUtils::convertToUInt16(values);
    emit currentPowerReadFinished(receivedCurrentPower);

    if (m_currentPower != receivedCurrentPower) {
        m_currentPower = receivedCurrentPower;
        emit currentPowerChanged(m_currentPower);
    }
}

void MyPvModbusTcpConnection::processExternalTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedExternalTemperature = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit externalTemperatureReadFinished(receivedExternalTemperature);

    if (m_externalTemperature != receivedExternalTemperature) {
        m_externalTemperature = receivedExternalTemperature;
        emit externalTemperatureChanged(m_externalTemperature);
    }
}

void MyPvModbusTcpConnection::processWaterTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedWaterTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit waterTemperatureReadFinished(receivedWaterTemperature);

    if (m_waterTemperature != receivedWaterTemperature) {
        m_waterTemperature = receivedWaterTemperature;
        emit waterTemperatureChanged(m_waterTemperature);
    }
}

void MyPvModbusTcpConnection::processTargetWaterTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedTargetWaterTemperature = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit targetWaterTemperatureReadFinished(receivedTargetWaterTemperature);

    if (m_targetWaterTemperature != receivedTargetWaterTemperature) {
        m_targetWaterTemperature = receivedTargetWaterTemperature;
        emit targetWaterTemperatureChanged(m_targetWaterTemperature);
    }
}

void MyPvModbusTcpConnection::processElwaStatusRegisterValues(const QVector<quint16> values)
{
    ElwaStatus receivedElwaStatus = static_cast<ElwaStatus>(ModbusDataUtils::convertToUInt16(values));
    emit elwaStatusReadFinished(receivedElwaStatus);

    if (m_elwaStatus != receivedElwaStatus) {
        m_elwaStatus = receivedElwaStatus;
        emit elwaStatusChanged(m_elwaStatus);
    }
}

void MyPvModbusTcpConnection::processManualStartRegisterValues(const QVector<quint16> values)
{
    quint16 receivedManualStart = ModbusDataUtils::convertToUInt16(values);
    emit manualStartReadFinished(receivedManualStart);

    if (m_manualStart != receivedManualStart) {
        m_manualStart = receivedManualStart;
        emit manualStartChanged(m_manualStart);
    }
}

void MyPvModbusTcpConnection::processDeviceNumberRegisterValues(const QVector<quint16> values)
{
    quint16 receivedDeviceNumber = ModbusDataUtils::convertToUInt16(values);
    emit deviceNumberReadFinished(receivedDeviceNumber);

    if (m_deviceNumber != receivedDeviceNumber) {
        m_deviceNumber = receivedDeviceNumber;
        emit deviceNumberChanged(m_deviceNumber);
    }
}

void MyPvModbusTcpConnection::processMaxPowerRegisterValues(const QVector<quint16> values)
{
    quint16 receivedMaxPower = ModbusDataUtils::convertToUInt16(values);
    emit maxPowerReadFinished(receivedMaxPower);

    if (m_maxPower != receivedMaxPower) {
        m_maxPower = receivedMaxPower;
        emit maxPowerChanged(m_maxPower);
    }
}

void MyPvModbusTcpConnection::processMeterPowerRegisterValues(const QVector<quint16> values)
{
    qint16 receivedMeterPower = ModbusDataUtils::convertToInt16(values);
    emit meterPowerReadFinished(receivedMeterPower);

    if (m_meterPower != receivedMeterPower) {
        m_meterPower = receivedMeterPower;
        emit meterPowerChanged(m_meterPower);
    }
}

void MyPvModbusTcpConnection::processDummy0RegisterValues(const QVector<quint16> values)
{
    QVector<quint16> receivedDummy0 = values;
    emit dummy0ReadFinished(receivedDummy0);

    if (m_dummy0 != receivedDummy0) {
        m_dummy0 = receivedDummy0;
        emit dummy0Changed(m_dummy0);
    }
}

void MyPvModbusTcpConnection::processImmHeaterPowerRegisterValues(const QVector<quint16> values)
{
    qint16 receivedImmHeaterPower = ModbusDataUtils::convertToInt16(values);
    emit immHeaterPowerReadFinished(receivedImmHeaterPower);

    if (m_immHeaterPower != receivedImmHeaterPower) {
        m_immHeaterPower = receivedImmHeaterPower;
        emit immHeaterPowerChanged(m_immHeaterPower);
    }
}

void MyPvModbusTcpConnection::processAuxRelayPowerRegisterValues(const QVector<quint16> values)
{
    qint16 receivedAuxRelayPower = ModbusDataUtils::convertToInt16(values);
    emit auxRelayPowerReadFinished(receivedAuxRelayPower);

    if (m_auxRelayPower != receivedAuxRelayPower) {
        m_auxRelayPower = receivedAuxRelayPower;
        emit auxRelayPowerChanged(m_auxRelayPower);
    }
}

void MyPvModbusTcpConnection::processPowerTimeoutRegisterValues(const QVector<quint16> values)
{
    quint16 receivedPowerTimeout = ModbusDataUtils::convertToUInt16(values);
    emit powerTimeoutReadFinished(receivedPowerTimeout);

    if (m_powerTimeout != receivedPowerTimeout) {
        m_powerTimeout = receivedPowerTimeout;
        emit powerTimeoutChanged(m_powerTimeout);
    }
}

void MyPvModbusTcpConnection::processBoostModeRegisterValues(const QVector<quint16> values)
{
    quint16 receivedBoostMode = ModbusDataUtils::convertToUInt16(values);
    emit boostModeReadFinished(receivedBoostMode);

    if (m_boostMode != receivedBoostMode) {
        m_boostMode = receivedBoostMode;
        emit boostModeChanged(m_boostMode);
    }
}

void MyPvModbusTcpConnection::processBackTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedBackTemperature = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit backTemperatureReadFinished(receivedBackTemperature);

    if (m_backTemperature != receivedBackTemperature) {
        m_backTemperature = receivedBackTemperature;
        emit backTemperatureChanged(m_backTemperature);
    }
}

void MyPvModbusTcpConnection::handleModbusError(QModbusDevice::Error error)
{
    if (error == QModbusDevice::NoError) {
        // Reset the communication counter and we know we can reach the device
        m_communicationFailedCounter = 0;
        if (!m_communicationWorking)
            qCDebug(dcMyPvModbusTcpConnection()) << "Received a reply without any errors. The communication with the device seems to work now.";

        m_communicationWorking = true;
        evaluateReachableState();
    } else {
        m_communicationFailedCounter++;
        if (m_communicationWorking && m_communicationFailedCounter >= m_communicationFailedMax) {
            m_communicationWorking = false;
            qCWarning(dcMyPvModbusTcpConnection()) << "Received" << m_communicationFailedCounter << "errors while communicating with the RTU master. Mark as not reachable until the communication works again.";
            evaluateReachableState();
        }
    }
}

void MyPvModbusTcpConnection::testReachability()
{
    if (m_checkRechableReply)
        return;

    // Try to read the check reachability register waterTemperature in order to verify if the communication is working or not.
    qCDebug(dcMyPvModbusTcpConnection()) << "--> Test reachability by reading \"Actual water temperature\" register:" << 1001 << "size:" << 1;
    m_checkRechableReply = readWaterTemperature();
    if (!m_checkRechableReply) {
        qCDebug(dcMyPvModbusTcpConnection()) << "Error occurred verifying reachability by reading \"Actual water temperature\" register";
        onReachabilityCheckFailed();
        return;
    }

    if (m_checkRechableReply->isFinished()) {
        m_checkRechableReply->deleteLater(); // Broadcast reply returns immediatly
        m_checkRechableReply = nullptr;
        onReachabilityCheckFailed();
        return;
    }

    connect(m_checkRechableReply, &QModbusReply::finished, this, [this](){
        handleModbusError(m_checkRechableReply->error());
        if (m_checkRechableReply->error() != QModbusDevice::NoError)
            onReachabilityCheckFailed();

        m_checkRechableReply->deleteLater();
        m_checkRechableReply = nullptr;
    });

    connect(m_checkRechableReply, &QModbusReply::errorOccurred, this, [this] (QModbusDevice::Error error){
        qCDebug(dcMyPvModbusTcpConnection()) << "Modbus reply error occurred while verifying reachability by reading \"Actual water temperature\" register" << error << m_checkRechableReply->errorString();
    });
}

void MyPvModbusTcpConnection::verifyInitFinished()
{
    if (m_pendingInitReplies.isEmpty()) {
        finishInitialization(true);
    }
}

void MyPvModbusTcpConnection::finishInitialization(bool success)
{
    if (success) {
        qCDebug(dcMyPvModbusTcpConnection()) << "Initialization finished of MyPvModbusTcpConnection" << hostAddress().toString() << "finished successfully";
    } else {
        qCWarning(dcMyPvModbusTcpConnection()) << "Initialization finished of MyPvModbusTcpConnection" << hostAddress().toString() << "failed.";
    }

    // Cleanup init
    delete m_initObject;
    m_initObject = nullptr;
    m_pendingInitReplies.clear();

    emit initializationFinished(success);
}

void MyPvModbusTcpConnection::verifyUpdateFinished()
{
    if (m_pendingUpdateReplies.isEmpty()) {
        emit updateFinished();
    }
}

void MyPvModbusTcpConnection::onReachabilityCheckFailed()
{
    m_checkReachableRetriesCount++;

    if (m_checkReachableRetriesCount <= m_checkReachableRetries) {
        qCDebug(dcMyPvModbusTcpConnection()) << "Reachability test failed. Retry in on second" << m_checkReachableRetriesCount << "/" << m_checkReachableRetries;
        QTimer::singleShot(1000, this, &MyPvModbusTcpConnection::testReachability);
        return;
    }

    // The test reachability method failed, not retrying any more
    emit checkReachabilityFailed();
}

void MyPvModbusTcpConnection::evaluateReachableState()
{
    bool reachable = m_communicationWorking && connected();
    if (m_reachable == reachable)
        return;

    m_reachable = reachable;
    emit reachableChanged(m_reachable);
    m_checkReachableRetriesCount = 0;
}

QDebug operator<<(QDebug debug, MyPvModbusTcpConnection *myPvModbusTcpConnection)
{
    debug.nospace().noquote() << "MyPvModbusTcpConnection(" << myPvModbusTcpConnection->hostAddress().toString() << ":" << myPvModbusTcpConnection->port() << ")" << "\n";
    debug.nospace().noquote() << "    - Current power: " << myPvModbusTcpConnection->currentPower() << " [W]" << "\n";
    debug.nospace().noquote() << "    - External temperature sensor: " << myPvModbusTcpConnection->externalTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - Actual water temperature: " << myPvModbusTcpConnection->waterTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - Target water temperature: " << myPvModbusTcpConnection->targetWaterTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - Status of ELWA: " << myPvModbusTcpConnection->elwaStatus() << "\n";
    debug.nospace().noquote() << "    - Manual start: " << myPvModbusTcpConnection->manualStart() << "\n";
    debug.nospace().noquote() << "    - AC ELWA Number: " << myPvModbusTcpConnection->deviceNumber() << "\n";
    debug.nospace().noquote() << "    - Maximum power: " << myPvModbusTcpConnection->maxPower() << "\n";
    debug.nospace().noquote() << "    - Power at meter: " << myPvModbusTcpConnection->meterPower() << "\n";
    debug.nospace().noquote() << "    - Dummy0: " << myPvModbusTcpConnection->dummy0() << "\n";
    debug.nospace().noquote() << "    - Power at ELWA immersion heater: " << myPvModbusTcpConnection->immHeaterPower() << "\n";
    debug.nospace().noquote() << "    - Power at AUX relay: " << myPvModbusTcpConnection->auxRelayPower() << "\n";
    debug.nospace().noquote() << "    - Timeout of set power: " << myPvModbusTcpConnection->powerTimeout() << "\n";
    debug.nospace().noquote() << "    - Boost mode: " << myPvModbusTcpConnection->boostMode() << "\n";
    debug.nospace().noquote() << "    - Backup target temperature: " << myPvModbusTcpConnection->backTemperature() << " [°C]" << "\n";
    return debug.quote().space();
}

