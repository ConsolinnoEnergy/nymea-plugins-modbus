/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Copyright 2013 - 2024, nymea GmbH
* Contact: contact@nymea.io
*
* This fileDescriptor is part of nymea.
* This project including source code and documentation is protected by
* copyright law, and remains the property of nymea GmbH. All rights, including
* reproduction, publication, editing and translation, are reserved. The use of
* this project is subject to the terms of a license agreement to be concluded
* with nymea GmbH in accordance with the terms of use of nymea GmbH, available
* under https://nymea.io/license
*
* GNU Lesser General Public License Usage
* Alternatively, this project may be redistributed and/or modified under the
* terms of the GNU Lesser General Public License as published by the Free
* Software Foundation; version 3. This project is distributed in the hope that
* it will be useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this project. If not, see <https://www.gnu.org/licenses/>.
*
* For any further details and any questions please contact us under
* contact@nymea.io or see our FAQ/Licensing Information on
* https://nymea.io/license/faq
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WARNING
*
* This file has been autogenerated. Any changes in this file may be overwritten.
* If you want to change something, update the register json or the tool.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#ifndef MYPVMODBUSTCPCONNECTION_H
#define MYPVMODBUSTCPCONNECTION_H

#include <QObject>

#include <modbusdatautils.h>
#include <modbustcpmaster.h>

class MyPvModbusTcpConnection : public ModbusTCPMaster
{
    Q_OBJECT
public:
    enum Registers {
        RegisterCurrentPower = 1000,
        RegisterWaterTemperature = 1001,
        RegisterTargetWaterTemperature = 1002,
        RegisterElwaStatus = 1003,
        RegisterPowerTimeout = 1004,
        RegisterBoostMode = 1005,
        RegisterManualStart = 1012,
        RegisterDeviceNumber = 1013,
        RegisterMaxPower = 1014,
        RegisterMeterPower = 1069,
        RegisterDummy0 = 1070,
        RegisterImmHeaterPower = 1074,
        RegisterAuxRelayPower = 1075
    };
    Q_ENUM(Registers)

    enum ElwaStatus {
        ElwaStatusHeating = 2,
        ElwaStatusStandby = 3,
        ElwaStatusBoosted = 4,
        ElwaStatusHeatFinished = 5,
        ElwaStatusSetup = 9,
        ElwaStatusLageionellaBoost = 20,
        ElwaStatusDeviceDisabled = 21,
        ElwaStatusDeviceBlocked = 22,
        ElwaStatusErrorOvertempFuseBlown = 201,
        ElwaStatusErrorOvertempMeasured = 202,
        ElwaStatusErrorOvertempElectronics = 203,
        ElwaStatusErrorHardwareFault = 204,
        ElwaStatusErrorTempSensor = 205
    };
    Q_ENUM(ElwaStatus)

    explicit MyPvModbusTcpConnection(const QHostAddress &hostAddress, uint port, quint16 slaveId, QObject *parent = nullptr);
    ~MyPvModbusTcpConnection() = default;

    bool reachable() const;

    ModbusDataUtils::ByteOrder endianness() const;
    void setEndianness(ModbusDataUtils::ByteOrder endianness);

    uint checkReachableRetries() const;
    void setCheckReachableRetries(uint checkReachableRetries);

    /* Current power [W] - Address: 1000, Size: 1 */
    quint16 currentPower() const;
    QModbusReply *setCurrentPower(quint16 currentPower);

    /* Actual water temperature [°C] - Address: 1001, Size: 1 */
    float waterTemperature() const;

    /* Target water temperature [°C] - Address: 1002, Size: 1 */
    float targetWaterTemperature() const;

    /* Status of ELWA - Address: 1003, Size: 1 */
    ElwaStatus elwaStatus() const;

    /* Manual start - Address: 1012, Size: 1 */
    quint16 manualStart() const;
    QModbusReply *setManualStart(quint16 manualStart);

    /* AC ELWA Number - Address: 1013, Size: 1 */
    quint16 deviceNumber() const;
    QModbusReply *setDeviceNumber(quint16 deviceNumber);

    /* Maximum power - Address: 1014, Size: 1 */
    quint16 maxPower() const;
    QModbusReply *setMaxPower(quint16 maxPower);

    /* Power at meter - Address: 1069, Size: 1 */
    qint16 meterPower() const;

    /* Dummy0 - Address: 1070, Size: 4 */
    QVector<quint16> dummy0() const;

    /* Power at ELWA immersion heater - Address: 1074, Size: 1 */
    qint16 immHeaterPower() const;

    /* Power at AUX relay - Address: 1075, Size: 1 */
    qint16 auxRelayPower() const;

    /* Timeout of set power - Address: 1004, Size: 1 */
    quint16 powerTimeout() const;
    QModbusReply *setPowerTimeout(quint16 powerTimeout);

    /* Boost mode - Address: 1005, Size: 1 */
    quint16 boostMode() const;
    QModbusReply *setBoostMode(quint16 boostMode);

    /* Read block from start addess 1001 with size of 3 registers containing following 3 properties:
      - Actual water temperature [°C] - Address: 1001, Size: 1
      - Target water temperature [°C] - Address: 1002, Size: 1
      - Status of ELWA - Address: 1003, Size: 1
    */
    void updateRealTimeValuesBlock();

    /* Read block from start addess 1012 with size of 3 registers containing following 3 properties:
      - Manual start - Address: 1012, Size: 1
      - AC ELWA Number - Address: 1013, Size: 1
      - Maximum power - Address: 1014, Size: 1
    */
    void updateSetPointValuesBlock();

    /* Read block from start addess 1069 with size of 7 registers containing following 4 properties:
      - Power at meter - Address: 1069, Size: 1
      - Dummy0 - Address: 1070, Size: 4
      - Power at ELWA immersion heater - Address: 1074, Size: 1
      - Power at AUX relay - Address: 1075, Size: 1
    */
    void updatePowerValuesBlock();

    /* Read block from start addess 1004 with size of 2 registers containing following 2 properties:
      - Timeout of set power - Address: 1004, Size: 1
      - Boost mode - Address: 1005, Size: 1
    */
    void updateTimeoutAndBoostBlock();

    void updateCurrentPower();

    void updateWaterTemperature();
    void updateTargetWaterTemperature();
    void updateElwaStatus();
    void updateManualStart();
    void updateDeviceNumber();
    void updateMaxPower();
    void updateMeterPower();
    void updateDummy0();
    void updateImmHeaterPower();
    void updateAuxRelayPower();
    void updatePowerTimeout();
    void updateBoostMode();

    QModbusReply *readCurrentPower();
    QModbusReply *readWaterTemperature();
    QModbusReply *readTargetWaterTemperature();
    QModbusReply *readElwaStatus();
    QModbusReply *readManualStart();
    QModbusReply *readDeviceNumber();
    QModbusReply *readMaxPower();
    QModbusReply *readMeterPower();
    QModbusReply *readDummy0();
    QModbusReply *readImmHeaterPower();
    QModbusReply *readAuxRelayPower();
    QModbusReply *readPowerTimeout();
    QModbusReply *readBoostMode();

    /* Read block from start addess 1001 with size of 3 registers containing following 3 properties:
     - Actual water temperature [°C] - Address: 1001, Size: 1
     - Target water temperature [°C] - Address: 1002, Size: 1
     - Status of ELWA - Address: 1003, Size: 1
    */
    QModbusReply *readBlockRealTimeValues();

    /* Read block from start addess 1012 with size of 3 registers containing following 3 properties:
     - Manual start - Address: 1012, Size: 1
     - AC ELWA Number - Address: 1013, Size: 1
     - Maximum power - Address: 1014, Size: 1
    */
    QModbusReply *readBlockSetPointValues();

    /* Read block from start addess 1069 with size of 7 registers containing following 4 properties:
     - Power at meter - Address: 1069, Size: 1
     - Dummy0 - Address: 1070, Size: 4
     - Power at ELWA immersion heater - Address: 1074, Size: 1
     - Power at AUX relay - Address: 1075, Size: 1
    */
    QModbusReply *readBlockPowerValues();

    /* Read block from start addess 1004 with size of 2 registers containing following 2 properties:
     - Timeout of set power - Address: 1004, Size: 1
     - Boost mode - Address: 1005, Size: 1
    */
    QModbusReply *readBlockTimeoutAndBoost();


    virtual bool initialize();
    virtual bool update();
    virtual void update2();
    virtual void update3();
    virtual void update4();
    virtual void update5();

signals:
    void reachableChanged(bool reachable);
    void checkReachabilityFailed();
    void checkReachableRetriesChanged(uint checkReachableRetries);

    void initializationFinished(bool success);
    void updateFinished();

    void endiannessChanged(ModbusDataUtils::ByteOrder endianness);

    void currentPowerChanged(quint16 currentPower);
    void currentPowerReadFinished(quint16 currentPower);

    void waterTemperatureChanged(float waterTemperature);
    void waterTemperatureReadFinished(float waterTemperature);
    void targetWaterTemperatureChanged(float targetWaterTemperature);
    void targetWaterTemperatureReadFinished(float targetWaterTemperature);
    void elwaStatusChanged(ElwaStatus elwaStatus);
    void elwaStatusReadFinished(ElwaStatus elwaStatus);
    void manualStartChanged(quint16 manualStart);
    void manualStartReadFinished(quint16 manualStart);
    void deviceNumberChanged(quint16 deviceNumber);
    void deviceNumberReadFinished(quint16 deviceNumber);
    void maxPowerChanged(quint16 maxPower);
    void maxPowerReadFinished(quint16 maxPower);
    void meterPowerChanged(qint16 meterPower);
    void meterPowerReadFinished(qint16 meterPower);
    void dummy0Changed(QVector<quint16> dummy0);
    void dummy0ReadFinished(QVector<quint16> dummy0);
    void immHeaterPowerChanged(qint16 immHeaterPower);
    void immHeaterPowerReadFinished(qint16 immHeaterPower);
    void auxRelayPowerChanged(qint16 auxRelayPower);
    void auxRelayPowerReadFinished(qint16 auxRelayPower);
    void powerTimeoutChanged(quint16 powerTimeout);
    void powerTimeoutReadFinished(quint16 powerTimeout);
    void boostModeChanged(quint16 boostMode);
    void boostModeReadFinished(quint16 boostMode);

protected:
    quint16 m_currentPower = 0;
    float m_waterTemperature = 0;
    float m_targetWaterTemperature = 0;
    ElwaStatus m_elwaStatus = ElwaStatusStandby;
    quint16 m_manualStart = 0;
    quint16 m_deviceNumber = 0;
    quint16 m_maxPower = 0;
    qint16 m_meterPower = 0;
    QVector<quint16> m_dummy0;
    qint16 m_immHeaterPower = 0;
    qint16 m_auxRelayPower = 0;
    quint16 m_powerTimeout = 0;
    quint16 m_boostMode = 0;

    void processCurrentPowerRegisterValues(const QVector<quint16> values);

    void processWaterTemperatureRegisterValues(const QVector<quint16> values);
    void processTargetWaterTemperatureRegisterValues(const QVector<quint16> values);
    void processElwaStatusRegisterValues(const QVector<quint16> values);

    void processManualStartRegisterValues(const QVector<quint16> values);
    void processDeviceNumberRegisterValues(const QVector<quint16> values);
    void processMaxPowerRegisterValues(const QVector<quint16> values);

    void processMeterPowerRegisterValues(const QVector<quint16> values);
    void processDummy0RegisterValues(const QVector<quint16> values);
    void processImmHeaterPowerRegisterValues(const QVector<quint16> values);
    void processAuxRelayPowerRegisterValues(const QVector<quint16> values);

    void processPowerTimeoutRegisterValues(const QVector<quint16> values);
    void processBoostModeRegisterValues(const QVector<quint16> values);

    void handleModbusError(QModbusDevice::Error error);
    void testReachability();

private:
    ModbusDataUtils::ByteOrder m_endianness = ModbusDataUtils::ByteOrderBigEndian;
    quint16 m_slaveId = 1;

    bool m_reachable = false;
    QModbusReply *m_checkRechableReply = nullptr;
    uint m_checkReachableRetries = 0;
    uint m_checkReachableRetriesCount = 0;
    bool m_communicationWorking = false;
    quint8 m_communicationFailedMax = 10;
    quint8 m_communicationFailedCounter = 0;

    QVector<QModbusReply *> m_pendingInitReplies;
    QVector<QModbusReply *> m_pendingUpdateReplies;

    QObject *m_initObject = nullptr;
    void verifyInitFinished();
    void finishInitialization(bool success);

    void verifyUpdateFinished();

    void onReachabilityCheckFailed();
    void evaluateReachableState();

};

QDebug operator<<(QDebug debug, MyPvModbusTcpConnection *myPvModbusTcpConnection);

#endif // MYPVMODBUSTCPCONNECTION_H
