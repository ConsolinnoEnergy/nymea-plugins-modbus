/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Copyright 2013 - 2024, nymea GmbH
* Contact: contact@nymea.io
*
* This fileDescriptor is part of nymea.
* This project including source code and documentation is protected by
* copyright law, and remains the property of nymea GmbH. All rights, including
* reproduction, publication, editing and translation, are reserved. The use of
* this project is subject to the terms of a license agreement to be concluded
* with nymea GmbH in accordance with the terms of use of nymea GmbH, available
* under https://nymea.io/license
*
* GNU Lesser General Public License Usage
* Alternatively, this project may be redistributed and/or modified under the
* terms of the GNU Lesser General Public License as published by the Free
* Software Foundation; version 3. This project is distributed in the hope that
* it will be useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this project. If not, see <https://www.gnu.org/licenses/>.
*
* For any further details and any questions please contact us under
* contact@nymea.io or see our FAQ/Licensing Information on
* https://nymea.io/license/faq
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WARNING
*
* This file has been autogenerated. Any changes in this file may be overwritten.
* If you want to change something, update the register json or the tool.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#ifndef DVMODBUSIRMODBUSRTUCONNECTION_H
#define DVMODBUSIRMODBUSRTUCONNECTION_H

#include <QObject>

#include <modbusdatautils.h>
#include <hardware/modbus/modbusrtumaster.h>

class DvModbusIRModbusRtuConnection : public QObject
{
    Q_OBJECT
public:
    enum Registers {
        RegisterSerialNumber = 0,
        RegisterDeviceStatus = 4,
        RegisterMeterId = 11,
        RegisterTotalConsumedEnergy = 13,
        RegisterConsumedEnergyExponent = 17,
        RegisterTotalProducedEnergy = 28,
        RegisterProducedEnergyExponent = 32
    };
    Q_ENUM(Registers)

    explicit DvModbusIRModbusRtuConnection(ModbusRtuMaster *modbusRtuMaster, quint16 slaveId, QObject *parent = nullptr);
    ~DvModbusIRModbusRtuConnection() = default;

    ModbusRtuMaster *modbusRtuMaster() const;
    quint16 slaveId() const;

    bool reachable() const;

    uint checkReachableRetries() const;
    void setCheckReachableRetries(uint checkReachableRetries);

    ModbusDataUtils::ByteOrder endianness() const;
    void setEndianness(ModbusDataUtils::ByteOrder endianness);

    /* Serialnumber of read-out head. - Address: 0, Size: 1 */
    quint16 serialNumber() const;

    /* Info about connected meters. - Address: 4, Size: 1 */
    quint16 deviceStatus() const;

    /* Devicenumber of connected meter. - Address: 11, Size: 2 */
    quint32 meterId() const;

    /* Total consumed energy without comma. - Address: 13, Size: 4 */
    quint64 totalConsumedEnergy() const;

    /* 10-exponent for consumed energy. - Address: 17, Size: 1 */
    qint16 consumedEnergyExponent() const;

    /* Total produced energy without comma. - Address: 28, Size: 4 */
    quint64 totalProducedEnergy() const;

    /* 10-exponent for produced energy. - Address: 32, Size: 1 */
    qint16 producedEnergyExponent() const;

    /* Read block from start addess 13 with size of 5 registers containing following 2 properties:
      - Total consumed energy without comma. - Address: 13, Size: 4
      - 10-exponent for consumed energy. - Address: 17, Size: 1
    */
    void updateConsumedEnergyBlock();

    /* Read block from start addess 28 with size of 5 registers containing following 2 properties:
      - Total produced energy without comma. - Address: 28, Size: 4
      - 10-exponent for produced energy. - Address: 32, Size: 1
    */
    void updateProducedEnergyBlock();


    void updateTotalConsumedEnergy();
    void updateConsumedEnergyExponent();
    void updateTotalProducedEnergy();
    void updateProducedEnergyExponent();

    ModbusRtuReply *readSerialNumber();
    ModbusRtuReply *readDeviceStatus();
    ModbusRtuReply *readMeterId();
    ModbusRtuReply *readTotalConsumedEnergy();
    ModbusRtuReply *readConsumedEnergyExponent();
    ModbusRtuReply *readTotalProducedEnergy();
    ModbusRtuReply *readProducedEnergyExponent();

    /* Read block from start addess 13 with size of 5 registers containing following 2 properties:
     - Total consumed energy without comma. - Address: 13, Size: 4
     - 10-exponent for consumed energy. - Address: 17, Size: 1
    */
    ModbusRtuReply *readBlockConsumedEnergy();

    /* Read block from start addess 28 with size of 5 registers containing following 2 properties:
     - Total produced energy without comma. - Address: 28, Size: 4
     - 10-exponent for produced energy. - Address: 32, Size: 1
    */
    ModbusRtuReply *readBlockProducedEnergy();

    virtual bool initialize();
    virtual bool update();

signals:
    void reachableChanged(bool reachable);
    void checkReachabilityFailed();
    void checkReachableRetriesChanged(uint checkReachableRetries);

    void initializationFinished(bool success);
    void updateFinished();

    void endiannessChanged(ModbusDataUtils::ByteOrder endianness);

    void serialNumberChanged(quint16 serialNumber);
    void serialNumberReadFinished(quint16 serialNumber);
    void deviceStatusChanged(quint16 deviceStatus);
    void deviceStatusReadFinished(quint16 deviceStatus);
    void meterIdChanged(quint32 meterId);
    void meterIdReadFinished(quint32 meterId);
    void totalConsumedEnergyChanged(quint64 totalConsumedEnergy);
    void totalConsumedEnergyReadFinished(quint64 totalConsumedEnergy);
    void consumedEnergyExponentChanged(qint16 consumedEnergyExponent);
    void consumedEnergyExponentReadFinished(qint16 consumedEnergyExponent);
    void totalProducedEnergyChanged(quint64 totalProducedEnergy);
    void totalProducedEnergyReadFinished(quint64 totalProducedEnergy);
    void producedEnergyExponentChanged(qint16 producedEnergyExponent);
    void producedEnergyExponentReadFinished(qint16 producedEnergyExponent);

protected:
    quint16 m_serialNumber = 0;
    quint16 m_deviceStatus = 0;
    quint32 m_meterId = 0;
    quint64 m_totalConsumedEnergy = 0;
    qint16 m_consumedEnergyExponent = 0;
    quint64 m_totalProducedEnergy = 0;
    qint16 m_producedEnergyExponent = 0;

    void processSerialNumberRegisterValues(const QVector<quint16> values);
    void processDeviceStatusRegisterValues(const QVector<quint16> values);
    void processMeterIdRegisterValues(const QVector<quint16> values);

    void processTotalConsumedEnergyRegisterValues(const QVector<quint16> values);
    void processConsumedEnergyExponentRegisterValues(const QVector<quint16> values);

    void processTotalProducedEnergyRegisterValues(const QVector<quint16> values);
    void processProducedEnergyExponentRegisterValues(const QVector<quint16> values);


    void handleModbusError(ModbusRtuReply::Error error);
    void testReachability();

private:
    ModbusRtuMaster *m_modbusRtuMaster = nullptr;
    ModbusDataUtils::ByteOrder m_endianness = ModbusDataUtils::ByteOrderBigEndian;
    quint16 m_slaveId = 1;

    bool m_reachable = false;
    ModbusRtuReply *m_checkRechableReply = nullptr;
    uint m_checkReachableRetries = 0;
    uint m_checkReachableRetriesCount = 0;
    bool m_communicationWorking = false;
    quint8 m_communicationFailedMax = 20;
    quint8 m_communicationFailedCounter = 0;

    QVector<ModbusRtuReply *> m_pendingInitReplies;
    QVector<ModbusRtuReply *> m_pendingUpdateReplies;

    QObject *m_initObject = nullptr;
    void verifyInitFinished();
    void finishInitialization(bool success);

    void verifyUpdateFinished();

    void onReachabilityCheckFailed();
    void evaluateReachableState();

};

QDebug operator<<(QDebug debug, DvModbusIRModbusRtuConnection *dvModbusIRModbusRtuConnection);

#endif // DVMODBUSIRMODBUSRTUCONNECTION_H
