/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Copyright 2013 - 2025, nymea GmbH
* Contact: contact@nymea.io
*
* This fileDescriptor is part of nymea.
* This project including source code and documentation is protected by
* copyright law, and remains the property of nymea GmbH. All rights, including
* reproduction, publication, editing and translation, are reserved. The use of
* this project is subject to the terms of a license agreement to be concluded
* with nymea GmbH in accordance with the terms of use of nymea GmbH, available
* under https://nymea.io/license
*
* GNU Lesser General Public License Usage
* Alternatively, this project may be redistributed and/or modified under the
* terms of the GNU Lesser General Public License as published by the Free
* Software Foundation; version 3. This project is distributed in the hope that
* it will be useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this project. If not, see <https://www.gnu.org/licenses/>.
*
* For any further details and any questions please contact us under
* contact@nymea.io or see our FAQ/Licensing Information on
* https://nymea.io/license/faq
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WARNING
*
* This file has been autogenerated. Any changes in this file may be overwritten.
* If you want to change something, update the register json or the tool.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


#include "solaxiesmodbustcpconnection.h"
#include <loggingcategories.h>
#include <math.h>
#include <QTimer>

NYMEA_LOGGING_CATEGORY(dcSolaxIesModbusTcpConnection, "SolaxIesModbusTcpConnection")

SolaxIesModbusTcpConnection::SolaxIesModbusTcpConnection(const QHostAddress &hostAddress, uint port, quint16 slaveId, QObject *parent) :
    ModbusTcpMaster(hostAddress, port, parent),
    m_slaveId(slaveId)
{
    connect(this, &ModbusTcpMaster::connectionStateChanged, this, [this](bool status){
        if (status) {
           qCDebug(dcSolaxIesModbusTcpConnection()) << "Modbus TCP connection" << m_hostAddress.toString() << "connected. Start testing if the connection is reachable...";
            // Cleanup before starting to initialize
            m_pendingInitReplies.clear();
            m_pendingUpdateReplies.clear();
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
            testReachability();
        } else {
            qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus TCP connection diconnected from" << m_hostAddress.toString() << ". The connection is not reachable any more.";
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
        }

        evaluateReachableState();
    });
}

bool SolaxIesModbusTcpConnection::reachable() const
{
    return m_reachable;
}

uint SolaxIesModbusTcpConnection::checkReachableRetries() const
{
    return m_checkReachableRetries;
}

void SolaxIesModbusTcpConnection::setCheckReachableRetries(uint checkReachableRetries)
{
    if (m_checkReachableRetries == checkReachableRetries)
        return;

    m_checkReachableRetries = checkReachableRetries;
    emit checkReachableRetriesChanged(m_checkReachableRetries);
}

ModbusDataUtils::ByteOrder SolaxIesModbusTcpConnection::endianness() const
{
    return m_endianness;
}

void SolaxIesModbusTcpConnection::setEndianness(ModbusDataUtils::ByteOrder endianness)
{
    if (m_endianness == endianness)
        return;

    m_endianness = endianness;
    emit endiannessChanged(m_endianness);
}

QModbusReply *SolaxIesModbusTcpConnection::setUnlockPassword(quint16 unlockPassword)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(unlockPassword);
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Write \"Unlock password (0x00)\" register:" << 0 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 0, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 SolaxIesModbusTcpConnection::batteryCapacity() const
{
    return m_batteryCapacity;
}

QModbusReply *SolaxIesModbusTcpConnection::setWriteChargeMaxCurrent(float writeChargeMaxCurrent)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(static_cast<quint16>(writeChargeMaxCurrent  * 1.0 / pow(10, -1)));
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Write \"Write BMS charge max current (0x24)\" register:" << 36 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 36, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 SolaxIesModbusTcpConnection::bmsWarningLsb() const
{
    return m_bmsWarningLsb;
}

quint16 SolaxIesModbusTcpConnection::bmsWarningMsb() const
{
    return m_bmsWarningMsb;
}

quint32 SolaxIesModbusTcpConnection::inverterFaultBits() const
{
    return m_inverterFaultBits;
}

quint16 SolaxIesModbusTcpConnection::meter1CommunicationState() const
{
    return m_meter1CommunicationState;
}

quint16 SolaxIesModbusTcpConnection::meter2CommunicationState() const
{
    return m_meter2CommunicationState;
}

float SolaxIesModbusTcpConnection::readExportLimit() const
{
    return m_readExportLimit;
}

QModbusReply *SolaxIesModbusTcpConnection::setWriteExportLimit(float writeExportLimit)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(static_cast<quint16>(writeExportLimit  * 1.0 / pow(10, 1)));
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Write \"Write grid export limit (0x42)\" register:" << 66 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 66, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 SolaxIesModbusTcpConnection::firmwareVersion() const
{
    return m_firmwareVersion;
}

quint16 SolaxIesModbusTcpConnection::inverterType() const
{
    return m_inverterType;
}

QModbusReply *SolaxIesModbusTcpConnection::setModeType(quint32 modeType)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt32(modeType, m_endianness);
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Write \"Control mode and target type (0x7C)\" register:" << 124 << "size:" << 2 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 124, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::setForceBatteryPower(qint32 forceBatteryPower)
{
    QVector<quint16> values = ModbusDataUtils::convertFromInt32(forceBatteryPower, m_endianness);
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Write \"Battery power (0x89)\" register:" << 137 << "size:" << 2 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 137, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 SolaxIesModbusTcpConnection::modbusPowerControl() const
{
    return m_modbusPowerControl;
}

QString SolaxIesModbusTcpConnection::factoryName() const
{
    return m_factoryName;
}

QString SolaxIesModbusTcpConnection::moduleName() const
{
    return m_moduleName;
}

float SolaxIesModbusTcpConnection::inverterVoltage() const
{
    return m_inverterVoltage;
}

float SolaxIesModbusTcpConnection::inverterCurrent() const
{
    return m_inverterCurrent;
}

qint16 SolaxIesModbusTcpConnection::inverterPower() const
{
    return m_inverterPower;
}

float SolaxIesModbusTcpConnection::pvVoltage1() const
{
    return m_pvVoltage1;
}

float SolaxIesModbusTcpConnection::pvVoltage2() const
{
    return m_pvVoltage2;
}

float SolaxIesModbusTcpConnection::pvCurrent1() const
{
    return m_pvCurrent1;
}

float SolaxIesModbusTcpConnection::pvCurrent2() const
{
    return m_pvCurrent2;
}

float SolaxIesModbusTcpConnection::inverterFrequency() const
{
    return m_inverterFrequency;
}

qint16 SolaxIesModbusTcpConnection::temperature() const
{
    return m_temperature;
}

SolaxIesModbusTcpConnection::RunMode SolaxIesModbusTcpConnection::runMode() const
{
    return m_runMode;
}

quint16 SolaxIesModbusTcpConnection::powerDc1() const
{
    return m_powerDc1;
}

quint16 SolaxIesModbusTcpConnection::powerDc2() const
{
    return m_powerDc2;
}

float SolaxIesModbusTcpConnection::batVoltageCharge1() const
{
    return m_batVoltageCharge1;
}

float SolaxIesModbusTcpConnection::batCurrentCharge1() const
{
    return m_batCurrentCharge1;
}

qint16 SolaxIesModbusTcpConnection::batPowerCharge1() const
{
    return m_batPowerCharge1;
}

quint16 SolaxIesModbusTcpConnection::bmsConnectState() const
{
    return m_bmsConnectState;
}

qint16 SolaxIesModbusTcpConnection::temperatureBat() const
{
    return m_temperatureBat;
}

qint32 SolaxIesModbusTcpConnection::feedinPower() const
{
    return m_feedinPower;
}

float SolaxIesModbusTcpConnection::feedinEnergyTotal() const
{
    return m_feedinEnergyTotal;
}

float SolaxIesModbusTcpConnection::consumEnergyTotal() const
{
    return m_consumEnergyTotal;
}

float SolaxIesModbusTcpConnection::gridVoltageR() const
{
    return m_gridVoltageR;
}

float SolaxIesModbusTcpConnection::gridCurrentR() const
{
    return m_gridCurrentR;
}

qint16 SolaxIesModbusTcpConnection::gridPowerR() const
{
    return m_gridPowerR;
}

float SolaxIesModbusTcpConnection::gridFrequencyR() const
{
    return m_gridFrequencyR;
}

float SolaxIesModbusTcpConnection::gridVoltageS() const
{
    return m_gridVoltageS;
}

float SolaxIesModbusTcpConnection::gridCurrentS() const
{
    return m_gridCurrentS;
}

qint16 SolaxIesModbusTcpConnection::gridPowerS() const
{
    return m_gridPowerS;
}

float SolaxIesModbusTcpConnection::gridFrequencyS() const
{
    return m_gridFrequencyS;
}

float SolaxIesModbusTcpConnection::gridVoltageT() const
{
    return m_gridVoltageT;
}

float SolaxIesModbusTcpConnection::gridCurrentT() const
{
    return m_gridCurrentT;
}

qint16 SolaxIesModbusTcpConnection::gridPowerT() const
{
    return m_gridPowerT;
}

float SolaxIesModbusTcpConnection::gridFrequencyT() const
{
    return m_gridFrequencyT;
}

float SolaxIesModbusTcpConnection::solarEnergyTotal() const
{
    return m_solarEnergyTotal;
}

float SolaxIesModbusTcpConnection::solarEnergyToday() const
{
    return m_solarEnergyToday;
}

float SolaxIesModbusTcpConnection::batMaxChargeVolt() const
{
    return m_batMaxChargeVolt;
}

float SolaxIesModbusTcpConnection::batMaxDischargeVolt() const
{
    return m_batMaxDischargeVolt;
}

float SolaxIesModbusTcpConnection::batMaxChargeCurrent() const
{
    return m_batMaxChargeCurrent;
}

float SolaxIesModbusTcpConnection::batMaxDischargeCurrent() const
{
    return m_batMaxDischargeCurrent;
}

qint32 SolaxIesModbusTcpConnection::currentPowerMeter2() const
{
    return m_currentPowerMeter2;
}

float SolaxIesModbusTcpConnection::feedinEnergyTotalMeter2() const
{
    return m_feedinEnergyTotalMeter2;
}

float SolaxIesModbusTcpConnection::consumEnergyTotalMeter2() const
{
    return m_consumEnergyTotalMeter2;
}

bool SolaxIesModbusTcpConnection::initialize()
{
    if (!m_reachable) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Tried to initialize but the device is not to be reachable.";
        return false;
    }
    if (m_initObject) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Tried to initialize but the init process is already running.";
        return false;
    }

    // Parent object for the init process
    m_initObject = new QObject(this);

    QModbusReply *reply = nullptr;

    // Read Firmware version (0x7D)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read init \"Firmware version (0x7D)\" register:" << 125 << "size:" << 1;
    reply = readFirmwareVersion();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Firmware version (0x7D)\" registers from" << hostAddress().toString() << errorString();
        finishInitialization(false);
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, m_initObject, [this, reply](){
        handleModbusError(reply->error());
        m_pendingInitReplies.removeAll(reply);
        if (reply->error() != QModbusDevice::NoError) {
            finishInitialization(false);
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from init \"Firmware version (0x7D)\" register" << 125 << "size:" << 1 << unit.values();
        processFirmwareVersionRegisterValues(unit.values());
        initialize2();
    });

    connect(reply, &QModbusReply::errorOccurred, m_initObject, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while reading \"Firmware version (0x7D)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    return true;
}

void SolaxIesModbusTcpConnection::initialize2()
{
    QModbusReply *reply = nullptr;

    // Read Inverter rated power (0xBA)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read init \"Inverter rated power (0xBA)\" register:" << 186 << "size:" << 1;
    reply = readInverterType();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Inverter rated power (0xBA)\" registers from" << hostAddress().toString() << errorString();
        finishInitialization(false);
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, m_initObject, [this, reply](){
        handleModbusError(reply->error());
        m_pendingInitReplies.removeAll(reply);
        if (reply->error() != QModbusDevice::NoError) {
            finishInitialization(false);
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from init \"Inverter rated power (0xBA)\" register" << 186 << "size:" << 1 << unit.values();
        processInverterTypeRegisterValues(unit.values());
        initialize3();
    });

    connect(reply, &QModbusReply::errorOccurred, m_initObject, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while reading \"Inverter rated power (0xBA)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::initialize3()
{
    QModbusReply *reply = nullptr;

    // Read identification
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read init block \"identification\" registers from:" << 7 << "size:" << 14;
    reply = readBlockIdentification();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading block \"identification\" registers";
        finishInitialization(false);
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, m_initObject, [this, reply](){
        m_pendingInitReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            finishInitialization(false);
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from reading init block \"identification\" register" << 7 << "size:" << 14 << blockValues;
        processFactoryNameRegisterValues(blockValues.mid(0, 7));
        processModuleNameRegisterValues(blockValues.mid(7, 7));
        initialize4();
    });

    connect(reply, &QModbusReply::errorOccurred, m_initObject, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating block \"identification\" registers" << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::initialize4()
{
    QModbusReply *reply = nullptr;

    // Read batMaxInfo
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read init block \"batMaxInfo\" registers from:" << 142 << "size:" << 4;
    reply = readBlockBatMaxInfo();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading block \"batMaxInfo\" registers";
        finishInitialization(false);
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, m_initObject, [this, reply](){
        m_pendingInitReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            finishInitialization(false);
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from reading init block \"batMaxInfo\" register" << 142 << "size:" << 4 << blockValues;
        processBatMaxChargeVoltRegisterValues(blockValues.mid(0, 1));
        processBatMaxDischargeVoltRegisterValues(blockValues.mid(1, 1));
        processBatMaxChargeCurrentRegisterValues(blockValues.mid(2, 1));
        processBatMaxDischargeCurrentRegisterValues(blockValues.mid(3, 1));
        verifyInitFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, m_initObject, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating block \"batMaxInfo\" registers" << error << reply->errorString();
    });
}

bool SolaxIesModbusTcpConnection::update()
{
    if (!connected())
        return false;

    if (!m_pendingUpdateReplies.isEmpty()) {
        qCDebug(dcSolaxIesModbusTcpConnection()) << "Tried to update but there are still some update replies pending. Waiting for them to be finished...";
        return true;
    }

    QModbusReply *reply = nullptr;

    // Read Battery state of charge (0x1C)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Battery state of charge (0x1C)\" register:" << 28 << "size:" << 1;
    reply = readBatteryCapacity();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Battery state of charge (0x1C)\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Battery state of charge (0x1C)\" register" << 28 << "size:" << 1 << unit.values();
        processBatteryCapacityRegisterValues(unit.values());
        update2();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while reading \"Battery state of charge (0x1C)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    return true;
}

void SolaxIesModbusTcpConnection::update2()
{
    QModbusReply *reply = nullptr;

    // Read BMS warning bits lsb (0x44)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"BMS warning bits lsb (0x44)\" register:" << 68 << "size:" << 1;
    reply = readBmsWarningLsb();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"BMS warning bits lsb (0x44)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"BMS warning bits lsb (0x44)\" register" << 68 << "size:" << 1 << unit.values();
        processBmsWarningLsbRegisterValues(unit.values());
        update3();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while reading \"BMS warning bits lsb (0x44)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::update3()
{
    QModbusReply *reply = nullptr;

    // Read BMS warning bits msb (0x45)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"BMS warning bits msb (0x45)\" register:" << 69 << "size:" << 1;
    reply = readBmsWarningMsb();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"BMS warning bits msb (0x45)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"BMS warning bits msb (0x45)\" register" << 69 << "size:" << 1 << unit.values();
        processBmsWarningMsbRegisterValues(unit.values());
        update4();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while reading \"BMS warning bits msb (0x45)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::update4()
{
    QModbusReply *reply = nullptr;

    // Read Inverter fault bits (0x40)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Inverter fault bits (0x40)\" register:" << 64 << "size:" << 2;
    reply = readInverterFaultBits();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Inverter fault bits (0x40)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Inverter fault bits (0x40)\" register" << 64 << "size:" << 2 << unit.values();
        processInverterFaultBitsRegisterValues(unit.values());
        update5();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while reading \"Inverter fault bits (0x40)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::update5()
{
    QModbusReply *reply = nullptr;

    // Read Meter 1 communication status (0xB8)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Meter 1 communication status (0xB8)\" register:" << 184 << "size:" << 1;
    reply = readMeter1CommunicationState();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Meter 1 communication status (0xB8)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Meter 1 communication status (0xB8)\" register" << 184 << "size:" << 1 << unit.values();
        processMeter1CommunicationStateRegisterValues(unit.values());
        update6();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while reading \"Meter 1 communication status (0xB8)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::update6()
{
    QModbusReply *reply = nullptr;

    // Read Read grid export limit (0xB6)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Read grid export limit (0xB6)\" register:" << 182 << "size:" << 1;
    reply = readReadExportLimit();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Read grid export limit (0xB6)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Read grid export limit (0xB6)\" register" << 182 << "size:" << 1 << unit.values();
        processReadExportLimitRegisterValues(unit.values());
        update7();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while reading \"Read grid export limit (0xB6)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::update7()
{
    QModbusReply *reply = nullptr;

    // Read pvVoltageAndCurrent
    reply = readBlockPvVoltageAndCurrent();
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read block \"pvVoltageAndCurrent\" registers from:" << 0 << "size:" << 12;
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading block \"pvVoltageAndCurrent\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from reading block \"pvVoltageAndCurrent\" register" << 0 << "size:" << 12 << blockValues;
        processInverterVoltageRegisterValues(blockValues.mid(0, 1));
        processInverterCurrentRegisterValues(blockValues.mid(1, 1));
        processInverterPowerRegisterValues(blockValues.mid(2, 1));
        processPvVoltage1RegisterValues(blockValues.mid(3, 1));
        processPvVoltage2RegisterValues(blockValues.mid(4, 1));
        processPvCurrent1RegisterValues(blockValues.mid(5, 1));
        processPvCurrent2RegisterValues(blockValues.mid(6, 1));
        processInverterFrequencyRegisterValues(blockValues.mid(7, 1));
        processTemperatureRegisterValues(blockValues.mid(8, 1));
        processRunModeRegisterValues(blockValues.mid(9, 1));
        processPowerDc1RegisterValues(blockValues.mid(10, 1));
        processPowerDc2RegisterValues(blockValues.mid(11, 1));
        update8();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating block \"pvVoltageAndCurrent\" registers" << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::update8()
{
    QModbusReply *reply = nullptr;

    // Read batPowerAndState
    reply = readBlockBatPowerAndState();
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read block \"batPowerAndState\" registers from:" << 20 << "size:" << 5;
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading block \"batPowerAndState\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from reading block \"batPowerAndState\" register" << 20 << "size:" << 5 << blockValues;
        processBatVoltageCharge1RegisterValues(blockValues.mid(0, 1));
        processBatCurrentCharge1RegisterValues(blockValues.mid(1, 1));
        processBatPowerCharge1RegisterValues(blockValues.mid(2, 1));
        processBmsConnectStateRegisterValues(blockValues.mid(3, 1));
        processTemperatureBatRegisterValues(blockValues.mid(4, 1));
        update9();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating block \"batPowerAndState\" registers" << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::update9()
{
    QModbusReply *reply = nullptr;

    // Read meterData
    reply = readBlockMeterData();
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read block \"meterData\" registers from:" << 70 << "size:" << 6;
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading block \"meterData\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from reading block \"meterData\" register" << 70 << "size:" << 6 << blockValues;
        processFeedinPowerRegisterValues(blockValues.mid(0, 2));
        processFeedinEnergyTotalRegisterValues(blockValues.mid(2, 2));
        processConsumEnergyTotalRegisterValues(blockValues.mid(4, 2));
        update10();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating block \"meterData\" registers" << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::update10()
{
    QModbusReply *reply = nullptr;

    // Read phasesData
    reply = readBlockPhasesData();
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read block \"phasesData\" registers from:" << 106 << "size:" << 12;
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading block \"phasesData\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from reading block \"phasesData\" register" << 106 << "size:" << 12 << blockValues;
        processGridVoltageRRegisterValues(blockValues.mid(0, 1));
        processGridCurrentRRegisterValues(blockValues.mid(1, 1));
        processGridPowerRRegisterValues(blockValues.mid(2, 1));
        processGridFrequencyRRegisterValues(blockValues.mid(3, 1));
        processGridVoltageSRegisterValues(blockValues.mid(4, 1));
        processGridCurrentSRegisterValues(blockValues.mid(5, 1));
        processGridPowerSRegisterValues(blockValues.mid(6, 1));
        processGridFrequencySRegisterValues(blockValues.mid(7, 1));
        processGridVoltageTRegisterValues(blockValues.mid(8, 1));
        processGridCurrentTRegisterValues(blockValues.mid(9, 1));
        processGridPowerTRegisterValues(blockValues.mid(10, 1));
        processGridFrequencyTRegisterValues(blockValues.mid(11, 1));
        update11();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating block \"phasesData\" registers" << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::update11()
{
    QModbusReply *reply = nullptr;

    // Read solarEnergy
    reply = readBlockSolarEnergy();
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read block \"solarEnergy\" registers from:" << 148 << "size:" << 3;
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading block \"solarEnergy\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from reading block \"solarEnergy\" register" << 148 << "size:" << 3 << blockValues;
        processSolarEnergyTotalRegisterValues(blockValues.mid(0, 2));
        processSolarEnergyTodayRegisterValues(blockValues.mid(2, 1));
        update12();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating block \"solarEnergy\" registers" << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::update12()
{
    QModbusReply *reply = nullptr;

    // Read Modbus power control read-only (0x89)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Modbus power control read-only (0x89)\" register:" << 256 << "size:" << 1;
    reply = readModbusPowerControl();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Modbus power control read-only (0x89)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Modbus power control read-only (0x89)\" register" << 256 << "size:" << 1 << unit.values();
        processModbusPowerControlRegisterValues(unit.values());
        update13();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while reading \"Modbus power control read-only (0x89)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::update13()
{
    QModbusReply *reply = nullptr;

    // Read secondaryMeterData
    reply = readBlockSecondaryMeterData();
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read block \"secondaryMeterData\" registers from:" << 168 << "size:" << 6;
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading block \"secondaryMeterData\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from reading block \"secondaryMeterData\" register" << 168 << "size:" << 6 << blockValues;
        processCurrentPowerMeter2RegisterValues(blockValues.mid(0, 2));
        processFeedinEnergyTotalMeter2RegisterValues(blockValues.mid(2, 2));
        processConsumEnergyTotalMeter2RegisterValues(blockValues.mid(4, 2));
        update14();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating block \"secondaryMeterData\" registers" << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::update14()
{
    QModbusReply *reply = nullptr;

    // Read Meter 1 communication status (0xB8)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Meter 1 communication status (0xB8)\" register:" << 185 << "size:" << 1;
    reply = readMeter2CommunicationState();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Meter 1 communication status (0xB8)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Meter 1 communication status (0xB8)\" register" << 184 << "size:" << 1 << unit.values();
        processMeter2CommunicationStateRegisterValues(unit.values());
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while reading \"Meter 1 communication status (0xB8)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateBatteryCapacity()
{
    // Update registers from Battery state of charge (0x1C)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Battery state of charge (0x1C)\" register:" << 28 << "size:" << 1;
    QModbusReply *reply = readBatteryCapacity();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Battery state of charge (0x1C)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Battery state of charge (0x1C)\" register" << 28 << "size:" << 1 << unit.values();
            processBatteryCapacityRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Battery state of charge (0x1C)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateBmsWarningLsb()
{
    // Update registers from BMS warning bits lsb (0x44)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"BMS warning bits lsb (0x44)\" register:" << 68 << "size:" << 1;
    QModbusReply *reply = readBmsWarningLsb();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"BMS warning bits lsb (0x44)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"BMS warning bits lsb (0x44)\" register" << 68 << "size:" << 1 << unit.values();
            processBmsWarningLsbRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"BMS warning bits lsb (0x44)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateBmsWarningMsb()
{
    // Update registers from BMS warning bits msb (0x45)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"BMS warning bits msb (0x45)\" register:" << 69 << "size:" << 1;
    QModbusReply *reply = readBmsWarningMsb();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"BMS warning bits msb (0x45)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"BMS warning bits msb (0x45)\" register" << 69 << "size:" << 1 << unit.values();
            processBmsWarningMsbRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"BMS warning bits msb (0x45)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateInverterFaultBits()
{
    // Update registers from Inverter fault bits (0x40)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Inverter fault bits (0x40)\" register:" << 64 << "size:" << 2;
    QModbusReply *reply = readInverterFaultBits();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Inverter fault bits (0x40)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Inverter fault bits (0x40)\" register" << 64 << "size:" << 2 << unit.values();
            processInverterFaultBitsRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Inverter fault bits (0x40)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateMeter1CommunicationState()
{
    // Update registers from Meter 1 communication status (0xB8)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Meter 1 communication status (0xB8)\" register:" << 184 << "size:" << 1;
    QModbusReply *reply = readMeter1CommunicationState();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Meter 1 communication status (0xB8)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Meter 1 communication status (0xB8)\" register" << 184 << "size:" << 1 << unit.values();
            processMeter1CommunicationStateRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Meter 1 communication status (0xB8)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateMeter2CommunicationState()
{
    // Update registers from Meter 1 communication status (0xB8)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Meter 1 communication status (0xB8)\" register:" << 184 << "size:" << 1;
    QModbusReply *reply = readMeter2CommunicationState();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Meter 1 communication status (0xB8)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Meter 1 communication status (0xB8)\" register" << 184 << "size:" << 1 << unit.values();
            processMeter2CommunicationStateRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Meter 1 communication status (0xB8)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateReadExportLimit()
{
    // Update registers from Read grid export limit (0xB6)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Read grid export limit (0xB6)\" register:" << 182 << "size:" << 1;
    QModbusReply *reply = readReadExportLimit();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Read grid export limit (0xB6)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Read grid export limit (0xB6)\" register" << 182 << "size:" << 1 << unit.values();
            processReadExportLimitRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Read grid export limit (0xB6)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateModbusPowerControl()
{
    // Update registers from Modbus power control read-only (0x89)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Modbus power control read-only (0x89)\" register:" << 256 << "size:" << 1;
    QModbusReply *reply = readModbusPowerControl();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Modbus power control read-only (0x89)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Modbus power control read-only (0x89)\" register" << 256 << "size:" << 1 << unit.values();
            processModbusPowerControlRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Modbus power control read-only (0x89)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateBatPowerCharge1()
{
    // Update registers from Battery power charge1 (0x16)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Battery power charge1 (0x16)\" register:" << 22 << "size:" << 1;
    QModbusReply *reply = readBatPowerCharge1();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Battery power charge1 (0x16)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Battery power charge1 (0x16)\" register" << 22 << "size:" << 1 << unit.values();
            processBatPowerCharge1RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Battery power charge1 (0x16)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateBmsConnectState()
{
    // Update registers from BMS connected state (0x17)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"BMS connected state (0x17)\" register:" << 23 << "size:" << 1;
    QModbusReply *reply = readBmsConnectState();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"BMS connected state (0x17)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"BMS connected state (0x17)\" register" << 23 << "size:" << 1 << unit.values();
            processBmsConnectStateRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"BMS connected state (0x17)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateFeedinPower()
{
    // Update registers from Power to grid (0x46). Positive means exported power, negative means consumed power.
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Power to grid (0x46). Positive means exported power, negative means consumed power.\" register:" << 70 << "size:" << 2;
    QModbusReply *reply = readFeedinPower();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Power to grid (0x46). Positive means exported power, negative means consumed power.\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Power to grid (0x46). Positive means exported power, negative means consumed power.\" register" << 70 << "size:" << 2 << unit.values();
            processFeedinPowerRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Power to grid (0x46). Positive means exported power, negative means consumed power.\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateFeedinEnergyTotal()
{
    // Update registers from Exported energy, total (0x48)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Exported energy, total (0x48)\" register:" << 72 << "size:" << 2;
    QModbusReply *reply = readFeedinEnergyTotal();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Exported energy, total (0x48)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Exported energy, total (0x48)\" register" << 72 << "size:" << 2 << unit.values();
            processFeedinEnergyTotalRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Exported energy, total (0x48)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateConsumEnergyTotal()
{
    // Update registers from Consumed energy, total (0x4A)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Consumed energy, total (0x4A)\" register:" << 74 << "size:" << 2;
    QModbusReply *reply = readConsumEnergyTotal();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Consumed energy, total (0x4A)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Consumed energy, total (0x4A)\" register" << 74 << "size:" << 2 << unit.values();
            processConsumEnergyTotalRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Consumed energy, total (0x4A)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateGridVoltageR()
{
    // Update registers from Phase R voltage (0x6A)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Phase R voltage (0x6A)\" register:" << 106 << "size:" << 1;
    QModbusReply *reply = readGridVoltageR();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Phase R voltage (0x6A)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Phase R voltage (0x6A)\" register" << 106 << "size:" << 1 << unit.values();
            processGridVoltageRRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Phase R voltage (0x6A)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateGridCurrentR()
{
    // Update registers from Phase R current (0x6B)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Phase R current (0x6B)\" register:" << 107 << "size:" << 1;
    QModbusReply *reply = readGridCurrentR();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Phase R current (0x6B)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Phase R current (0x6B)\" register" << 107 << "size:" << 1 << unit.values();
            processGridCurrentRRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Phase R current (0x6B)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateGridPowerR()
{
    // Update registers from Phase R power (0x6C)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Phase R power (0x6C)\" register:" << 108 << "size:" << 1;
    QModbusReply *reply = readGridPowerR();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Phase R power (0x6C)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Phase R power (0x6C)\" register" << 108 << "size:" << 1 << unit.values();
            processGridPowerRRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Phase R power (0x6C)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateGridVoltageS()
{
    // Update registers from Phase S voltage (0x6E)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Phase S voltage (0x6E)\" register:" << 110 << "size:" << 1;
    QModbusReply *reply = readGridVoltageS();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Phase S voltage (0x6E)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Phase S voltage (0x6E)\" register" << 110 << "size:" << 1 << unit.values();
            processGridVoltageSRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Phase S voltage (0x6E)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateGridCurrentS()
{
    // Update registers from Phase S current (0x6F)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Phase S current (0x6F)\" register:" << 111 << "size:" << 1;
    QModbusReply *reply = readGridCurrentS();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Phase S current (0x6F)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Phase S current (0x6F)\" register" << 111 << "size:" << 1 << unit.values();
            processGridCurrentSRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Phase S current (0x6F)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateGridPowerS()
{
    // Update registers from Phase S power (0x70)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Phase S power (0x70)\" register:" << 112 << "size:" << 1;
    QModbusReply *reply = readGridPowerS();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Phase S power (0x70)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Phase S power (0x70)\" register" << 112 << "size:" << 1 << unit.values();
            processGridPowerSRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Phase S power (0x70)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateGridVoltageT()
{
    // Update registers from Phase T voltage (0x72)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Phase T voltage (0x72)\" register:" << 114 << "size:" << 1;
    QModbusReply *reply = readGridVoltageT();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Phase T voltage (0x72)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Phase T voltage (0x72)\" register" << 114 << "size:" << 1 << unit.values();
            processGridVoltageTRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Phase T voltage (0x72)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateGridCurrentT()
{
    // Update registers from Phase T current (0x73)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Phase T current (0x73)\" register:" << 115 << "size:" << 1;
    QModbusReply *reply = readGridCurrentT();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Phase T current (0x73)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Phase T current (0x73)\" register" << 115 << "size:" << 1 << unit.values();
            processGridCurrentTRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Phase T current (0x73)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateGridPowerT()
{
    // Update registers from Phase T power (0x74)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Phase T power (0x74)\" register:" << 116 << "size:" << 1;
    QModbusReply *reply = readGridPowerT();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Phase T power (0x74)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Phase T power (0x74)\" register" << 116 << "size:" << 1 << unit.values();
            processGridPowerTRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Phase T power (0x74)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateSolarEnergyTotal()
{
    // Update registers from Solar energy produced total (0x94)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Solar energy produced total (0x94)\" register:" << 148 << "size:" << 2;
    QModbusReply *reply = readSolarEnergyTotal();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Solar energy produced total (0x94)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Solar energy produced total (0x94)\" register" << 148 << "size:" << 2 << unit.values();
            processSolarEnergyTotalRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Solar energy produced total (0x94)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateSolarEnergyToday()
{
    // Update registers from Solar energy produced today (0x96)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Solar energy produced today (0x96)\" register:" << 150 << "size:" << 1;
    QModbusReply *reply = readSolarEnergyToday();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Solar energy produced today (0x96)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Solar energy produced today (0x96)\" register" << 150 << "size:" << 1 << unit.values();
            processSolarEnergyTodayRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Solar energy produced today (0x96)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateFeedinEnergyTotalMeter2()
{
    // Update registers from Exported energy, meter 2, total (0xAA)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Exported energy, meter 2, total (0xAA)\" register:" << 170 << "size:" << 2;
    QModbusReply *reply = readFeedinEnergyTotalMeter2();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Exported energy, meter 2, total (0xAA)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Exported energy, meter 2, total (0xAA)\" register" << 170 << "size:" << 2 << unit.values();
            processFeedinEnergyTotalMeter2RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Exported energy, meter 2, total (0xAA)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateConsumEnergyTotalMeter2()
{
    // Update registers from Consumed energy, meter 2, total (0xAC)
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read \"Consumed energy, meter 2, total (0xAC)\" register:" << 172 << "size:" << 2;
    QModbusReply *reply = readConsumEnergyTotalMeter2();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading \"Consumed energy, meter 2, total (0xAC)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from \"Consumed energy, meter 2, total (0xAC)\" register" << 172 << "size:" << 2 << unit.values();
            processConsumEnergyTotalMeter2RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating \"Consumed energy, meter 2, total (0xAC)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateIdentificationBlock()
{
    // Update register block "identification"
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read block \"identification\" registers from:" << 7 << "size:" << 14;
    QModbusReply *reply = readBlockIdentification();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading block \"identification\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from reading block \"identification\" register" << 7 << "size:" << 14 << blockValues;
            processFactoryNameRegisterValues(blockValues.mid(0, 7));
            processModuleNameRegisterValues(blockValues.mid(7, 7));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating block \"identification\" registers" << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updatePvVoltageAndCurrentBlock()
{
    // Update register block "pvVoltageAndCurrent"
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read block \"pvVoltageAndCurrent\" registers from:" << 0 << "size:" << 12;
    QModbusReply *reply = readBlockPvVoltageAndCurrent();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading block \"pvVoltageAndCurrent\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from reading block \"pvVoltageAndCurrent\" register" << 0 << "size:" << 12 << blockValues;
            processInverterVoltageRegisterValues(blockValues.mid(0, 1));
            processInverterCurrentRegisterValues(blockValues.mid(1, 1));
            processInverterPowerRegisterValues(blockValues.mid(2, 1));
            processPvVoltage1RegisterValues(blockValues.mid(3, 1));
            processPvVoltage2RegisterValues(blockValues.mid(4, 1));
            processPvCurrent1RegisterValues(blockValues.mid(5, 1));
            processPvCurrent2RegisterValues(blockValues.mid(6, 1));
            processInverterFrequencyRegisterValues(blockValues.mid(7, 1));
            processTemperatureRegisterValues(blockValues.mid(8, 1));
            processRunModeRegisterValues(blockValues.mid(9, 1));
            processPowerDc1RegisterValues(blockValues.mid(10, 1));
            processPowerDc2RegisterValues(blockValues.mid(11, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating block \"pvVoltageAndCurrent\" registers" << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateBatPowerAndStateBlock()
{
    // Update register block "batPowerAndState"
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read block \"batPowerAndState\" registers from:" << 20 << "size:" << 5;
    QModbusReply *reply = readBlockBatPowerAndState();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading block \"batPowerAndState\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from reading block \"batPowerAndState\" register" << 20 << "size:" << 5 << blockValues;
            processBatVoltageCharge1RegisterValues(blockValues.mid(0, 1));
            processBatCurrentCharge1RegisterValues(blockValues.mid(1, 1));
            processBatPowerCharge1RegisterValues(blockValues.mid(2, 1));
            processBmsConnectStateRegisterValues(blockValues.mid(3, 1));
            processTemperatureBatRegisterValues(blockValues.mid(4, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating block \"batPowerAndState\" registers" << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateMeterDataBlock()
{
    // Update register block "meterData"
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read block \"meterData\" registers from:" << 70 << "size:" << 6;
    QModbusReply *reply = readBlockMeterData();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading block \"meterData\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from reading block \"meterData\" register" << 70 << "size:" << 6 << blockValues;
            processFeedinPowerRegisterValues(blockValues.mid(0, 2));
            processFeedinEnergyTotalRegisterValues(blockValues.mid(2, 2));
            processConsumEnergyTotalRegisterValues(blockValues.mid(4, 2));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating block \"meterData\" registers" << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updatePhasesDataBlock()
{
    // Update register block "phasesData"
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read block \"phasesData\" registers from:" << 106 << "size:" << 12;
    QModbusReply *reply = readBlockPhasesData();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading block \"phasesData\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from reading block \"phasesData\" register" << 106 << "size:" << 12 << blockValues;
            processGridVoltageRRegisterValues(blockValues.mid(0, 1));
            processGridCurrentRRegisterValues(blockValues.mid(1, 1));
            processGridPowerRRegisterValues(blockValues.mid(2, 1));
            processGridFrequencyRRegisterValues(blockValues.mid(3, 1));
            processGridVoltageSRegisterValues(blockValues.mid(4, 1));
            processGridCurrentSRegisterValues(blockValues.mid(5, 1));
            processGridPowerSRegisterValues(blockValues.mid(6, 1));
            processGridFrequencySRegisterValues(blockValues.mid(7, 1));
            processGridVoltageTRegisterValues(blockValues.mid(8, 1));
            processGridCurrentTRegisterValues(blockValues.mid(9, 1));
            processGridPowerTRegisterValues(blockValues.mid(10, 1));
            processGridFrequencyTRegisterValues(blockValues.mid(11, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating block \"phasesData\" registers" << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateSolarEnergyBlock()
{
    // Update register block "solarEnergy"
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read block \"solarEnergy\" registers from:" << 148 << "size:" << 3;
    QModbusReply *reply = readBlockSolarEnergy();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading block \"solarEnergy\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from reading block \"solarEnergy\" register" << 148 << "size:" << 3 << blockValues;
            processSolarEnergyTotalRegisterValues(blockValues.mid(0, 2));
            processSolarEnergyTodayRegisterValues(blockValues.mid(2, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating block \"solarEnergy\" registers" << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateBatMaxInfoBlock()
{
    // Update register block "batMaxInfo"
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read block \"batMaxInfo\" registers from:" << 142 << "size:" << 4;
    QModbusReply *reply = readBlockBatMaxInfo();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading block \"batMaxInfo\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from reading block \"batMaxInfo\" register" << 142 << "size:" << 4 << blockValues;
            processBatMaxChargeVoltRegisterValues(blockValues.mid(0, 1));
            processBatMaxDischargeVoltRegisterValues(blockValues.mid(1, 1));
            processBatMaxChargeCurrentRegisterValues(blockValues.mid(2, 1));
            processBatMaxDischargeCurrentRegisterValues(blockValues.mid(3, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating block \"batMaxInfo\" registers" << error << reply->errorString();
    });
}

void SolaxIesModbusTcpConnection::updateSecondaryMeterDataBlock()
{
    // Update register block "secondaryMeterData"
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Read block \"secondaryMeterData\" registers from:" << 168 << "size:" << 6;
    QModbusReply *reply = readBlockSecondaryMeterData();
    if (!reply) {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Error occurred while reading block \"secondaryMeterData\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxIesModbusTcpConnection()) << "<-- Response from reading block \"secondaryMeterData\" register" << 168 << "size:" << 6 << blockValues;
            processCurrentPowerMeter2RegisterValues(blockValues.mid(0, 2));
            processFeedinEnergyTotalMeter2RegisterValues(blockValues.mid(2, 2));
            processConsumEnergyTotalMeter2RegisterValues(blockValues.mid(4, 2));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while updating block \"secondaryMeterData\" registers" << error << reply->errorString();
    });
}

QModbusReply *SolaxIesModbusTcpConnection::readBatteryCapacity()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 28, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readBmsWarningLsb()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 68, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readBmsWarningMsb()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 69, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readInverterFaultBits()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 64, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readMeter1CommunicationState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 184, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readMeter2CommunicationState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 185, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readReadExportLimit()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 182, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readFirmwareVersion()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 125, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readInverterType()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 186, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readModbusPowerControl()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 256, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readFactoryName()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 7, 7);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readModuleName()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 14, 7);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readInverterVoltage()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 0, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readInverterCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 1, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readInverterPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 2, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readPvVoltage1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 3, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readPvVoltage2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readPvCurrent1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 5, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readPvCurrent2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 6, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readInverterFrequency()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 7, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 8, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readRunMode()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 9, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readPowerDc1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 10, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readPowerDc2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 11, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readBatVoltageCharge1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 20, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readBatCurrentCharge1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 21, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readBatPowerCharge1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 22, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readBmsConnectState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 23, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readTemperatureBat()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 24, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readFeedinPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 70, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readFeedinEnergyTotal()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 72, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readConsumEnergyTotal()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 74, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readGridVoltageR()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 106, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readGridCurrentR()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 107, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readGridPowerR()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 108, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readGridFrequencyR()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 109, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readGridVoltageS()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 110, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readGridCurrentS()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 111, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readGridPowerS()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 112, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readGridFrequencyS()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 113, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readGridVoltageT()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 114, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readGridCurrentT()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 115, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readGridPowerT()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 116, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readGridFrequencyT()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 117, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readSolarEnergyTotal()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 148, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readSolarEnergyToday()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 150, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readBatMaxChargeVolt()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 142, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readBatMaxDischargeVolt()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 143, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readBatMaxChargeCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 144, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readBatMaxDischargeCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 145, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readCurrentPowerMeter2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 168, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readFeedinEnergyTotalMeter2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 170, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readConsumEnergyTotalMeter2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 172, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readBlockIdentification()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 7, 14);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readBlockPvVoltageAndCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 0, 12);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readBlockBatPowerAndState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 20, 5);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readBlockMeterData()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 70, 6);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readBlockPhasesData()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 106, 12);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readBlockSolarEnergy()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 148, 3);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readBlockBatMaxInfo()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 142, 4);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxIesModbusTcpConnection::readBlockSecondaryMeterData()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 168, 6);
    return sendReadRequest(request, m_slaveId);
}

void SolaxIesModbusTcpConnection::processBatteryCapacityRegisterValues(const QVector<quint16> values)
{
    quint16 receivedBatteryCapacity = ModbusDataUtils::convertToUInt16(values);
    emit batteryCapacityReadFinished(receivedBatteryCapacity);

    if (m_batteryCapacity != receivedBatteryCapacity) {
        m_batteryCapacity = receivedBatteryCapacity;
        emit batteryCapacityChanged(m_batteryCapacity);
    }
}

void SolaxIesModbusTcpConnection::processBmsWarningLsbRegisterValues(const QVector<quint16> values)
{
    quint16 receivedBmsWarningLsb = ModbusDataUtils::convertToUInt16(values);
    emit bmsWarningLsbReadFinished(receivedBmsWarningLsb);

    if (m_bmsWarningLsb != receivedBmsWarningLsb) {
        m_bmsWarningLsb = receivedBmsWarningLsb;
        emit bmsWarningLsbChanged(m_bmsWarningLsb);
    }
}

void SolaxIesModbusTcpConnection::processBmsWarningMsbRegisterValues(const QVector<quint16> values)
{
    quint16 receivedBmsWarningMsb = ModbusDataUtils::convertToUInt16(values);
    emit bmsWarningMsbReadFinished(receivedBmsWarningMsb);

    if (m_bmsWarningMsb != receivedBmsWarningMsb) {
        m_bmsWarningMsb = receivedBmsWarningMsb;
        emit bmsWarningMsbChanged(m_bmsWarningMsb);
    }
}

void SolaxIesModbusTcpConnection::processInverterFaultBitsRegisterValues(const QVector<quint16> values)
{
    quint32 receivedInverterFaultBits = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit inverterFaultBitsReadFinished(receivedInverterFaultBits);

    if (m_inverterFaultBits != receivedInverterFaultBits) {
        m_inverterFaultBits = receivedInverterFaultBits;
        emit inverterFaultBitsChanged(m_inverterFaultBits);
    }
}

void SolaxIesModbusTcpConnection::processMeter1CommunicationStateRegisterValues(const QVector<quint16> values)
{
    quint16 receivedMeter1CommunicationState = ModbusDataUtils::convertToUInt16(values);
    emit meter1CommunicationStateReadFinished(receivedMeter1CommunicationState);

    if (m_meter1CommunicationState != receivedMeter1CommunicationState) {
        m_meter1CommunicationState = receivedMeter1CommunicationState;
        emit meter1CommunicationStateChanged(m_meter1CommunicationState);
    }
}

void SolaxIesModbusTcpConnection::processMeter2CommunicationStateRegisterValues(const QVector<quint16> values)
{
    quint16 receivedMeter2CommunicationState = ModbusDataUtils::convertToUInt16(values);
    emit meter2CommunicationStateReadFinished(receivedMeter2CommunicationState);

    if (m_meter2CommunicationState != receivedMeter2CommunicationState) {
        m_meter2CommunicationState = receivedMeter2CommunicationState;
        emit meter2CommunicationStateChanged(m_meter2CommunicationState);
    }
}

void SolaxIesModbusTcpConnection::processReadExportLimitRegisterValues(const QVector<quint16> values)
{
    float receivedReadExportLimit = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, 1);
    emit readExportLimitReadFinished(receivedReadExportLimit);

    if (m_readExportLimit != receivedReadExportLimit) {
        m_readExportLimit = receivedReadExportLimit;
        emit readExportLimitChanged(m_readExportLimit);
    }
}

void SolaxIesModbusTcpConnection::processFirmwareVersionRegisterValues(const QVector<quint16> values)
{
    quint16 receivedFirmwareVersion = ModbusDataUtils::convertToUInt16(values);
    emit firmwareVersionReadFinished(receivedFirmwareVersion);

    if (m_firmwareVersion != receivedFirmwareVersion) {
        m_firmwareVersion = receivedFirmwareVersion;
        emit firmwareVersionChanged(m_firmwareVersion);
    }
}

void SolaxIesModbusTcpConnection::processInverterTypeRegisterValues(const QVector<quint16> values)
{
    quint16 receivedInverterType = ModbusDataUtils::convertToUInt16(values);
    emit inverterTypeReadFinished(receivedInverterType);

    if (m_inverterType != receivedInverterType) {
        m_inverterType = receivedInverterType;
        emit inverterTypeChanged(m_inverterType);
    }
}

void SolaxIesModbusTcpConnection::processModbusPowerControlRegisterValues(const QVector<quint16> values)
{
    quint16 receivedModbusPowerControl = ModbusDataUtils::convertToUInt16(values);
    emit modbusPowerControlReadFinished(receivedModbusPowerControl);

    if (m_modbusPowerControl != receivedModbusPowerControl) {
        m_modbusPowerControl = receivedModbusPowerControl;
        emit modbusPowerControlChanged(m_modbusPowerControl);
    }
}

void SolaxIesModbusTcpConnection::processFactoryNameRegisterValues(const QVector<quint16> values)
{
    QString receivedFactoryName = ModbusDataUtils::convertToString(values);
    emit factoryNameReadFinished(receivedFactoryName);

    if (m_factoryName != receivedFactoryName) {
        m_factoryName = receivedFactoryName;
        emit factoryNameChanged(m_factoryName);
    }
}

void SolaxIesModbusTcpConnection::processModuleNameRegisterValues(const QVector<quint16> values)
{
    QString receivedModuleName = ModbusDataUtils::convertToString(values);
    emit moduleNameReadFinished(receivedModuleName);

    if (m_moduleName != receivedModuleName) {
        m_moduleName = receivedModuleName;
        emit moduleNameChanged(m_moduleName);
    }
}

void SolaxIesModbusTcpConnection::processInverterVoltageRegisterValues(const QVector<quint16> values)
{
    float receivedInverterVoltage = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit inverterVoltageReadFinished(receivedInverterVoltage);

    if (m_inverterVoltage != receivedInverterVoltage) {
        m_inverterVoltage = receivedInverterVoltage;
        emit inverterVoltageChanged(m_inverterVoltage);
    }
}

void SolaxIesModbusTcpConnection::processInverterCurrentRegisterValues(const QVector<quint16> values)
{
    float receivedInverterCurrent = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit inverterCurrentReadFinished(receivedInverterCurrent);

    if (m_inverterCurrent != receivedInverterCurrent) {
        m_inverterCurrent = receivedInverterCurrent;
        emit inverterCurrentChanged(m_inverterCurrent);
    }
}

void SolaxIesModbusTcpConnection::processInverterPowerRegisterValues(const QVector<quint16> values)
{
    qint16 receivedInverterPower = ModbusDataUtils::convertToInt16(values);
    emit inverterPowerReadFinished(receivedInverterPower);

    if (m_inverterPower != receivedInverterPower) {
        m_inverterPower = receivedInverterPower;
        emit inverterPowerChanged(m_inverterPower);
    }
}

void SolaxIesModbusTcpConnection::processPvVoltage1RegisterValues(const QVector<quint16> values)
{
    float receivedPvVoltage1 = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit pvVoltage1ReadFinished(receivedPvVoltage1);

    if (m_pvVoltage1 != receivedPvVoltage1) {
        m_pvVoltage1 = receivedPvVoltage1;
        emit pvVoltage1Changed(m_pvVoltage1);
    }
}

void SolaxIesModbusTcpConnection::processPvVoltage2RegisterValues(const QVector<quint16> values)
{
    float receivedPvVoltage2 = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit pvVoltage2ReadFinished(receivedPvVoltage2);

    if (m_pvVoltage2 != receivedPvVoltage2) {
        m_pvVoltage2 = receivedPvVoltage2;
        emit pvVoltage2Changed(m_pvVoltage2);
    }
}

void SolaxIesModbusTcpConnection::processPvCurrent1RegisterValues(const QVector<quint16> values)
{
    float receivedPvCurrent1 = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit pvCurrent1ReadFinished(receivedPvCurrent1);

    if (m_pvCurrent1 != receivedPvCurrent1) {
        m_pvCurrent1 = receivedPvCurrent1;
        emit pvCurrent1Changed(m_pvCurrent1);
    }
}

void SolaxIesModbusTcpConnection::processPvCurrent2RegisterValues(const QVector<quint16> values)
{
    float receivedPvCurrent2 = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit pvCurrent2ReadFinished(receivedPvCurrent2);

    if (m_pvCurrent2 != receivedPvCurrent2) {
        m_pvCurrent2 = receivedPvCurrent2;
        emit pvCurrent2Changed(m_pvCurrent2);
    }
}

void SolaxIesModbusTcpConnection::processInverterFrequencyRegisterValues(const QVector<quint16> values)
{
    float receivedInverterFrequency = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit inverterFrequencyReadFinished(receivedInverterFrequency);

    if (m_inverterFrequency != receivedInverterFrequency) {
        m_inverterFrequency = receivedInverterFrequency;
        emit inverterFrequencyChanged(m_inverterFrequency);
    }
}

void SolaxIesModbusTcpConnection::processTemperatureRegisterValues(const QVector<quint16> values)
{
    qint16 receivedTemperature = ModbusDataUtils::convertToInt16(values);
    emit temperatureReadFinished(receivedTemperature);

    if (m_temperature != receivedTemperature) {
        m_temperature = receivedTemperature;
        emit temperatureChanged(m_temperature);
    }
}

void SolaxIesModbusTcpConnection::processRunModeRegisterValues(const QVector<quint16> values)
{
    RunMode receivedRunMode = static_cast<RunMode>(ModbusDataUtils::convertToUInt16(values));
    emit runModeReadFinished(receivedRunMode);

    if (m_runMode != receivedRunMode) {
        m_runMode = receivedRunMode;
        emit runModeChanged(m_runMode);
    }
}

void SolaxIesModbusTcpConnection::processPowerDc1RegisterValues(const QVector<quint16> values)
{
    quint16 receivedPowerDc1 = ModbusDataUtils::convertToUInt16(values);
    emit powerDc1ReadFinished(receivedPowerDc1);

    if (m_powerDc1 != receivedPowerDc1) {
        m_powerDc1 = receivedPowerDc1;
        emit powerDc1Changed(m_powerDc1);
    }
}

void SolaxIesModbusTcpConnection::processPowerDc2RegisterValues(const QVector<quint16> values)
{
    quint16 receivedPowerDc2 = ModbusDataUtils::convertToUInt16(values);
    emit powerDc2ReadFinished(receivedPowerDc2);

    if (m_powerDc2 != receivedPowerDc2) {
        m_powerDc2 = receivedPowerDc2;
        emit powerDc2Changed(m_powerDc2);
    }
}

void SolaxIesModbusTcpConnection::processBatVoltageCharge1RegisterValues(const QVector<quint16> values)
{
    float receivedBatVoltageCharge1 = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit batVoltageCharge1ReadFinished(receivedBatVoltageCharge1);

    if (m_batVoltageCharge1 != receivedBatVoltageCharge1) {
        m_batVoltageCharge1 = receivedBatVoltageCharge1;
        emit batVoltageCharge1Changed(m_batVoltageCharge1);
    }
}

void SolaxIesModbusTcpConnection::processBatCurrentCharge1RegisterValues(const QVector<quint16> values)
{
    float receivedBatCurrentCharge1 = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit batCurrentCharge1ReadFinished(receivedBatCurrentCharge1);

    if (m_batCurrentCharge1 != receivedBatCurrentCharge1) {
        m_batCurrentCharge1 = receivedBatCurrentCharge1;
        emit batCurrentCharge1Changed(m_batCurrentCharge1);
    }
}

void SolaxIesModbusTcpConnection::processBatPowerCharge1RegisterValues(const QVector<quint16> values)
{
    qint16 receivedBatPowerCharge1 = ModbusDataUtils::convertToInt16(values);
    emit batPowerCharge1ReadFinished(receivedBatPowerCharge1);

    if (m_batPowerCharge1 != receivedBatPowerCharge1) {
        m_batPowerCharge1 = receivedBatPowerCharge1;
        emit batPowerCharge1Changed(m_batPowerCharge1);
    }
}

void SolaxIesModbusTcpConnection::processBmsConnectStateRegisterValues(const QVector<quint16> values)
{
    quint16 receivedBmsConnectState = ModbusDataUtils::convertToUInt16(values);
    emit bmsConnectStateReadFinished(receivedBmsConnectState);

    if (m_bmsConnectState != receivedBmsConnectState) {
        m_bmsConnectState = receivedBmsConnectState;
        emit bmsConnectStateChanged(m_bmsConnectState);
    }
}

void SolaxIesModbusTcpConnection::processTemperatureBatRegisterValues(const QVector<quint16> values)
{
    qint16 receivedTemperatureBat = ModbusDataUtils::convertToInt16(values);
    emit temperatureBatReadFinished(receivedTemperatureBat);

    if (m_temperatureBat != receivedTemperatureBat) {
        m_temperatureBat = receivedTemperatureBat;
        emit temperatureBatChanged(m_temperatureBat);
    }
}

void SolaxIesModbusTcpConnection::processFeedinPowerRegisterValues(const QVector<quint16> values)
{
    qint32 receivedFeedinPower = ModbusDataUtils::convertToInt32(values, m_endianness);
    emit feedinPowerReadFinished(receivedFeedinPower);

    if (m_feedinPower != receivedFeedinPower) {
        m_feedinPower = receivedFeedinPower;
        emit feedinPowerChanged(m_feedinPower);
    }
}

void SolaxIesModbusTcpConnection::processFeedinEnergyTotalRegisterValues(const QVector<quint16> values)
{
    float receivedFeedinEnergyTotal = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -2);
    emit feedinEnergyTotalReadFinished(receivedFeedinEnergyTotal);

    if (m_feedinEnergyTotal != receivedFeedinEnergyTotal) {
        m_feedinEnergyTotal = receivedFeedinEnergyTotal;
        emit feedinEnergyTotalChanged(m_feedinEnergyTotal);
    }
}

void SolaxIesModbusTcpConnection::processConsumEnergyTotalRegisterValues(const QVector<quint16> values)
{
    float receivedConsumEnergyTotal = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -2);
    emit consumEnergyTotalReadFinished(receivedConsumEnergyTotal);

    if (m_consumEnergyTotal != receivedConsumEnergyTotal) {
        m_consumEnergyTotal = receivedConsumEnergyTotal;
        emit consumEnergyTotalChanged(m_consumEnergyTotal);
    }
}

void SolaxIesModbusTcpConnection::processGridVoltageRRegisterValues(const QVector<quint16> values)
{
    float receivedGridVoltageR = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit gridVoltageRReadFinished(receivedGridVoltageR);

    if (m_gridVoltageR != receivedGridVoltageR) {
        m_gridVoltageR = receivedGridVoltageR;
        emit gridVoltageRChanged(m_gridVoltageR);
    }
}

void SolaxIesModbusTcpConnection::processGridCurrentRRegisterValues(const QVector<quint16> values)
{
    float receivedGridCurrentR = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit gridCurrentRReadFinished(receivedGridCurrentR);

    if (m_gridCurrentR != receivedGridCurrentR) {
        m_gridCurrentR = receivedGridCurrentR;
        emit gridCurrentRChanged(m_gridCurrentR);
    }
}

void SolaxIesModbusTcpConnection::processGridPowerRRegisterValues(const QVector<quint16> values)
{
    qint16 receivedGridPowerR = ModbusDataUtils::convertToInt16(values);
    emit gridPowerRReadFinished(receivedGridPowerR);

    if (m_gridPowerR != receivedGridPowerR) {
        m_gridPowerR = receivedGridPowerR;
        emit gridPowerRChanged(m_gridPowerR);
    }
}

void SolaxIesModbusTcpConnection::processGridFrequencyRRegisterValues(const QVector<quint16> values)
{
    float receivedGridFrequencyR = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit gridFrequencyRReadFinished(receivedGridFrequencyR);

    if (m_gridFrequencyR != receivedGridFrequencyR) {
        m_gridFrequencyR = receivedGridFrequencyR;
        emit gridFrequencyRChanged(m_gridFrequencyR);
    }
}

void SolaxIesModbusTcpConnection::processGridVoltageSRegisterValues(const QVector<quint16> values)
{
    float receivedGridVoltageS = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit gridVoltageSReadFinished(receivedGridVoltageS);

    if (m_gridVoltageS != receivedGridVoltageS) {
        m_gridVoltageS = receivedGridVoltageS;
        emit gridVoltageSChanged(m_gridVoltageS);
    }
}

void SolaxIesModbusTcpConnection::processGridCurrentSRegisterValues(const QVector<quint16> values)
{
    float receivedGridCurrentS = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit gridCurrentSReadFinished(receivedGridCurrentS);

    if (m_gridCurrentS != receivedGridCurrentS) {
        m_gridCurrentS = receivedGridCurrentS;
        emit gridCurrentSChanged(m_gridCurrentS);
    }
}

void SolaxIesModbusTcpConnection::processGridPowerSRegisterValues(const QVector<quint16> values)
{
    qint16 receivedGridPowerS = ModbusDataUtils::convertToInt16(values);
    emit gridPowerSReadFinished(receivedGridPowerS);

    if (m_gridPowerS != receivedGridPowerS) {
        m_gridPowerS = receivedGridPowerS;
        emit gridPowerSChanged(m_gridPowerS);
    }
}

void SolaxIesModbusTcpConnection::processGridFrequencySRegisterValues(const QVector<quint16> values)
{
    float receivedGridFrequencyS = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit gridFrequencySReadFinished(receivedGridFrequencyS);

    if (m_gridFrequencyS != receivedGridFrequencyS) {
        m_gridFrequencyS = receivedGridFrequencyS;
        emit gridFrequencySChanged(m_gridFrequencyS);
    }
}

void SolaxIesModbusTcpConnection::processGridVoltageTRegisterValues(const QVector<quint16> values)
{
    float receivedGridVoltageT = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit gridVoltageTReadFinished(receivedGridVoltageT);

    if (m_gridVoltageT != receivedGridVoltageT) {
        m_gridVoltageT = receivedGridVoltageT;
        emit gridVoltageTChanged(m_gridVoltageT);
    }
}

void SolaxIesModbusTcpConnection::processGridCurrentTRegisterValues(const QVector<quint16> values)
{
    float receivedGridCurrentT = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit gridCurrentTReadFinished(receivedGridCurrentT);

    if (m_gridCurrentT != receivedGridCurrentT) {
        m_gridCurrentT = receivedGridCurrentT;
        emit gridCurrentTChanged(m_gridCurrentT);
    }
}

void SolaxIesModbusTcpConnection::processGridPowerTRegisterValues(const QVector<quint16> values)
{
    qint16 receivedGridPowerT = ModbusDataUtils::convertToInt16(values);
    emit gridPowerTReadFinished(receivedGridPowerT);

    if (m_gridPowerT != receivedGridPowerT) {
        m_gridPowerT = receivedGridPowerT;
        emit gridPowerTChanged(m_gridPowerT);
    }
}

void SolaxIesModbusTcpConnection::processGridFrequencyTRegisterValues(const QVector<quint16> values)
{
    float receivedGridFrequencyT = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit gridFrequencyTReadFinished(receivedGridFrequencyT);

    if (m_gridFrequencyT != receivedGridFrequencyT) {
        m_gridFrequencyT = receivedGridFrequencyT;
        emit gridFrequencyTChanged(m_gridFrequencyT);
    }
}

void SolaxIesModbusTcpConnection::processSolarEnergyTotalRegisterValues(const QVector<quint16> values)
{
    float receivedSolarEnergyTotal = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -1);
    emit solarEnergyTotalReadFinished(receivedSolarEnergyTotal);

    if (m_solarEnergyTotal != receivedSolarEnergyTotal) {
        m_solarEnergyTotal = receivedSolarEnergyTotal;
        emit solarEnergyTotalChanged(m_solarEnergyTotal);
    }
}

void SolaxIesModbusTcpConnection::processSolarEnergyTodayRegisterValues(const QVector<quint16> values)
{
    float receivedSolarEnergyToday = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit solarEnergyTodayReadFinished(receivedSolarEnergyToday);

    if (m_solarEnergyToday != receivedSolarEnergyToday) {
        m_solarEnergyToday = receivedSolarEnergyToday;
        emit solarEnergyTodayChanged(m_solarEnergyToday);
    }
}

void SolaxIesModbusTcpConnection::processBatMaxChargeVoltRegisterValues(const QVector<quint16> values)
{
    float receivedBatMaxChargeVolt = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit batMaxChargeVoltReadFinished(receivedBatMaxChargeVolt);

    if (m_batMaxChargeVolt != receivedBatMaxChargeVolt) {
        m_batMaxChargeVolt = receivedBatMaxChargeVolt;
        emit batMaxChargeVoltChanged(m_batMaxChargeVolt);
    }
}

void SolaxIesModbusTcpConnection::processBatMaxDischargeVoltRegisterValues(const QVector<quint16> values)
{
    float receivedBatMaxDischargeVolt = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit batMaxDischargeVoltReadFinished(receivedBatMaxDischargeVolt);

    if (m_batMaxDischargeVolt != receivedBatMaxDischargeVolt) {
        m_batMaxDischargeVolt = receivedBatMaxDischargeVolt;
        emit batMaxDischargeVoltChanged(m_batMaxDischargeVolt);
    }
}

void SolaxIesModbusTcpConnection::processBatMaxChargeCurrentRegisterValues(const QVector<quint16> values)
{
    float receivedBatMaxChargeCurrent = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit batMaxChargeCurrentReadFinished(receivedBatMaxChargeCurrent);

    if (m_batMaxChargeCurrent != receivedBatMaxChargeCurrent) {
        m_batMaxChargeCurrent = receivedBatMaxChargeCurrent;
        emit batMaxChargeCurrentChanged(m_batMaxChargeCurrent);
    }
}

void SolaxIesModbusTcpConnection::processBatMaxDischargeCurrentRegisterValues(const QVector<quint16> values)
{
    float receivedBatMaxDischargeCurrent = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit batMaxDischargeCurrentReadFinished(receivedBatMaxDischargeCurrent);

    if (m_batMaxDischargeCurrent != receivedBatMaxDischargeCurrent) {
        m_batMaxDischargeCurrent = receivedBatMaxDischargeCurrent;
        emit batMaxDischargeCurrentChanged(m_batMaxDischargeCurrent);
    }
}

void SolaxIesModbusTcpConnection::processCurrentPowerMeter2RegisterValues(const QVector<quint16> values)
{
    qint32 receivedCurrentPowerMeter2 = ModbusDataUtils::convertToInt32(values, m_endianness);
    emit currentPowerMeter2ReadFinished(receivedCurrentPowerMeter2);

    if (m_currentPowerMeter2 != receivedCurrentPowerMeter2) {
        m_currentPowerMeter2 = receivedCurrentPowerMeter2;
        emit currentPowerMeter2Changed(m_currentPowerMeter2);
    }
}

void SolaxIesModbusTcpConnection::processFeedinEnergyTotalMeter2RegisterValues(const QVector<quint16> values)
{
    float receivedFeedinEnergyTotalMeter2 = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -2);
    emit feedinEnergyTotalMeter2ReadFinished(receivedFeedinEnergyTotalMeter2);

    if (m_feedinEnergyTotalMeter2 != receivedFeedinEnergyTotalMeter2) {
        m_feedinEnergyTotalMeter2 = receivedFeedinEnergyTotalMeter2;
        emit feedinEnergyTotalMeter2Changed(m_feedinEnergyTotalMeter2);
    }
}

void SolaxIesModbusTcpConnection::processConsumEnergyTotalMeter2RegisterValues(const QVector<quint16> values)
{
    float receivedConsumEnergyTotalMeter2 = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -2);
    emit consumEnergyTotalMeter2ReadFinished(receivedConsumEnergyTotalMeter2);

    if (m_consumEnergyTotalMeter2 != receivedConsumEnergyTotalMeter2) {
        m_consumEnergyTotalMeter2 = receivedConsumEnergyTotalMeter2;
        emit consumEnergyTotalMeter2Changed(m_consumEnergyTotalMeter2);
    }
}

void SolaxIesModbusTcpConnection::handleModbusError(QModbusDevice::Error error)
{
    if (error == QModbusDevice::NoError) {
        // Reset the communication counter and we know we can reach the device
        m_communicationFailedCounter = 0;
        if (!m_communicationWorking)
            qCDebug(dcSolaxIesModbusTcpConnection()) << "Received a reply without any errors. The communication with the device seems to work now.";

        m_communicationWorking = true;
        evaluateReachableState();
    } else {
        m_communicationFailedCounter++;
        if (m_communicationWorking && m_communicationFailedCounter >= m_communicationFailedMax) {
            m_communicationWorking = false;
            qCWarning(dcSolaxIesModbusTcpConnection()) << "Received" << m_communicationFailedCounter << "errors while communicating with the RTU master. Mark as not reachable until the communication works again.";
            evaluateReachableState();
        }
    }
}

void SolaxIesModbusTcpConnection::testReachability()
{
    if (m_checkRechableReply)
        return;

    // Try to read the check reachability register inverterType in order to verify if the communication is working or not.
    qCDebug(dcSolaxIesModbusTcpConnection()) << "--> Test reachability by reading \"Inverter rated power (0xBA)\" register:" << 186 << "size:" << 1;
    m_checkRechableReply = readInverterType();
    if (!m_checkRechableReply) {
        qCDebug(dcSolaxIesModbusTcpConnection()) << "Error occurred verifying reachability by reading \"Inverter rated power (0xBA)\" register";
        onReachabilityCheckFailed();
        return;
    }

    if (m_checkRechableReply->isFinished()) {
        m_checkRechableReply->deleteLater(); // Broadcast reply returns immediatly
        m_checkRechableReply = nullptr;
        onReachabilityCheckFailed();
        return;
    }

    connect(m_checkRechableReply, &QModbusReply::finished, this, [this](){
        handleModbusError(m_checkRechableReply->error());
        if (m_checkRechableReply->error() != QModbusDevice::NoError)
            onReachabilityCheckFailed();

        m_checkRechableReply->deleteLater();
        m_checkRechableReply = nullptr;
    });

    connect(m_checkRechableReply, &QModbusReply::errorOccurred, this, [this] (QModbusDevice::Error error){
        qCDebug(dcSolaxIesModbusTcpConnection()) << "Modbus reply error occurred while verifying reachability by reading \"Inverter rated power (0xBA)\" register" << error << m_checkRechableReply->errorString();
    });
}

void SolaxIesModbusTcpConnection::verifyInitFinished()
{
    if (m_pendingInitReplies.isEmpty()) {
        finishInitialization(true);
    }
}

void SolaxIesModbusTcpConnection::finishInitialization(bool success)
{
    if (success) {
        qCDebug(dcSolaxIesModbusTcpConnection()) << "Initialization finished of SolaxIesModbusTcpConnection" << hostAddress().toString() << "finished successfully";
    } else {
        qCWarning(dcSolaxIesModbusTcpConnection()) << "Initialization finished of SolaxIesModbusTcpConnection" << hostAddress().toString() << "failed.";
    }

    // Cleanup init
    delete m_initObject;
    m_initObject = nullptr;
    m_pendingInitReplies.clear();

    emit initializationFinished(success);
}

void SolaxIesModbusTcpConnection::verifyUpdateFinished()
{
    if (m_pendingUpdateReplies.isEmpty()) {
        emit updateFinished();
    }
}

void SolaxIesModbusTcpConnection::onReachabilityCheckFailed()
{
    m_checkReachableRetriesCount++;

    if (m_checkReachableRetriesCount <= m_checkReachableRetries) {
        qCDebug(dcSolaxIesModbusTcpConnection()) << "Reachability test failed. Retry in on second" << m_checkReachableRetriesCount << "/" << m_checkReachableRetries;
        QTimer::singleShot(1000, this, &SolaxIesModbusTcpConnection::testReachability);
        return;
    }

    // The test reachability method failed, not retrying any more
    emit checkReachabilityFailed();
}

void SolaxIesModbusTcpConnection::evaluateReachableState()
{
    bool reachable = m_communicationWorking && connected();
    if (m_reachable == reachable)
        return;

    m_reachable = reachable;
    emit reachableChanged(m_reachable);
    m_checkReachableRetriesCount = 0;
}

QDebug operator<<(QDebug debug, SolaxIesModbusTcpConnection *solaxModbusTcpConnection)
{
    debug.nospace().noquote() << "SolaxIesModbusTcpConnection(" << solaxModbusTcpConnection->hostAddress().toString() << ":" << solaxModbusTcpConnection->port() << ")" << "\n";
    debug.nospace().noquote() << "    - Battery state of charge (0x1C): " << solaxModbusTcpConnection->batteryCapacity() << " [%]" << "\n";
    debug.nospace().noquote() << "    - BMS warning bits lsb (0x44): " << solaxModbusTcpConnection->bmsWarningLsb() << "\n";
    debug.nospace().noquote() << "    - BMS warning bits msb (0x45): " << solaxModbusTcpConnection->bmsWarningMsb() << "\n";
    debug.nospace().noquote() << "    - Inverter fault bits (0x40): " << solaxModbusTcpConnection->inverterFaultBits() << "\n";
    debug.nospace().noquote() << "    - Meter 1 communication status (0xB8): " << solaxModbusTcpConnection->meter1CommunicationState() << "\n";
    debug.nospace().noquote() << "    - Meter 2 communication status (0xB8): " << solaxModbusTcpConnection->meter2CommunicationState() << "\n";
    debug.nospace().noquote() << "    - Read grid export limit (0xB6): " << solaxModbusTcpConnection->readExportLimit() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Firmware version (0x7D): " << solaxModbusTcpConnection->firmwareVersion() << "\n";
    debug.nospace().noquote() << "    - Inverter rated power (0xBA): " << solaxModbusTcpConnection->inverterType() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Modbus power control read-only (0x89): " << solaxModbusTcpConnection->modbusPowerControl() << "\n";
    debug.nospace().noquote() << "    - Factory name (0x07): " << solaxModbusTcpConnection->factoryName() << "\n";
    debug.nospace().noquote() << "    - Module name (0x0E): " << solaxModbusTcpConnection->moduleName() << "\n";
    debug.nospace().noquote() << "    - Inverter voltage (0x00): " << solaxModbusTcpConnection->inverterVoltage() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Inverter current (0x01): " << solaxModbusTcpConnection->inverterCurrent() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Inverter power (0x02): " << solaxModbusTcpConnection->inverterPower() << " [W]" << "\n";
    debug.nospace().noquote() << "    - PV voltage 1 (0x03): " << solaxModbusTcpConnection->pvVoltage1() << " [V]" << "\n";
    debug.nospace().noquote() << "    - PV voltage 2 (0x04): " << solaxModbusTcpConnection->pvVoltage2() << " [V]" << "\n";
    debug.nospace().noquote() << "    - PV current 1 (0x05): " << solaxModbusTcpConnection->pvCurrent1() << " [A]" << "\n";
    debug.nospace().noquote() << "    - PV current 2 (0x06): " << solaxModbusTcpConnection->pvCurrent2() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Inverter frequenxy (0x07): " << solaxModbusTcpConnection->inverterFrequency() << " [Hz]" << "\n";
    debug.nospace().noquote() << "    - Radiator temperature (0x08): " << solaxModbusTcpConnection->temperature() << " [C]" << "\n";
    debug.nospace().noquote() << "    - Run mode (0x09): " << solaxModbusTcpConnection->runMode() << "\n";
    debug.nospace().noquote() << "    - Power DC 1 (0x0A): " << solaxModbusTcpConnection->powerDc1() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Power DC 2 (0x0B): " << solaxModbusTcpConnection->powerDc2() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Battery voltage charge 1 (0x14): " << solaxModbusTcpConnection->batVoltageCharge1() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Battery current charge 1 (0x15): " << solaxModbusTcpConnection->batCurrentCharge1() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Battery power charge1 (0x16): " << solaxModbusTcpConnection->batPowerCharge1() << " [W]" << "\n";
    debug.nospace().noquote() << "    - BMS connected state (0x17): " << solaxModbusTcpConnection->bmsConnectState() << "\n";
    debug.nospace().noquote() << "    - Battery temperature: " << solaxModbusTcpConnection->temperatureBat() << " [C]" << "\n";
    debug.nospace().noquote() << "    - Power to grid (0x46). Positive means exported power, negative means consumed power.: " << solaxModbusTcpConnection->feedinPower() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Exported energy, total (0x48): " << solaxModbusTcpConnection->feedinEnergyTotal() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Consumed energy, total (0x4A): " << solaxModbusTcpConnection->consumEnergyTotal() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Phase R voltage (0x6A): " << solaxModbusTcpConnection->gridVoltageR() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Phase R current (0x6B): " << solaxModbusTcpConnection->gridCurrentR() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Phase R power (0x6C): " << solaxModbusTcpConnection->gridPowerR() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Phase R frequency (0x6D): " << solaxModbusTcpConnection->gridFrequencyR() << " [Hz]" << "\n";
    debug.nospace().noquote() << "    - Phase S voltage (0x6E): " << solaxModbusTcpConnection->gridVoltageS() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Phase S current (0x6F): " << solaxModbusTcpConnection->gridCurrentS() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Phase S power (0x70): " << solaxModbusTcpConnection->gridPowerS() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Phase S frequency (0x71): " << solaxModbusTcpConnection->gridFrequencyS() << " [Hz]" << "\n";
    debug.nospace().noquote() << "    - Phase T voltage (0x72): " << solaxModbusTcpConnection->gridVoltageT() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Phase T current (0x73): " << solaxModbusTcpConnection->gridCurrentT() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Phase T power (0x74): " << solaxModbusTcpConnection->gridPowerT() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Phase T frequency (0x75): " << solaxModbusTcpConnection->gridFrequencyT() << " [Hz]" << "\n";
    debug.nospace().noquote() << "    - Solar energy produced total (0x94): " << solaxModbusTcpConnection->solarEnergyTotal() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Solar energy produced today (0x96): " << solaxModbusTcpConnection->solarEnergyToday() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Battery max charge voltage (0x8E): " << solaxModbusTcpConnection->batMaxChargeVolt() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Battery max discharge voltage (0x8F): " << solaxModbusTcpConnection->batMaxDischargeVolt() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Battery max charge current (0x90): " << solaxModbusTcpConnection->batMaxChargeCurrent() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Battery max discharge current (0x91): " << solaxModbusTcpConnection->batMaxDischargeCurrent() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Meter 2 feedin power (0xA8): " << solaxModbusTcpConnection->currentPowerMeter2() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Exported energy, meter 2, total (0xAA): " << solaxModbusTcpConnection->feedinEnergyTotalMeter2() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Consumed energy, meter 2, total (0xAC): " << solaxModbusTcpConnection->consumEnergyTotalMeter2() << " [kWh]" << "\n";
    return debug.quote().space();
}

