/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Copyright 2013 - 2024, nymea GmbH
* Contact: contact@nymea.io
*
* This fileDescriptor is part of nymea.
* This project including source code and documentation is protected by
* copyright law, and remains the property of nymea GmbH. All rights, including
* reproduction, publication, editing and translation, are reserved. The use of
* this project is subject to the terms of a license agreement to be concluded
* with nymea GmbH in accordance with the terms of use of nymea GmbH, available
* under https://nymea.io/license
*
* GNU Lesser General Public License Usage
* Alternatively, this project may be redistributed and/or modified under the
* terms of the GNU Lesser General Public License as published by the Free
* Software Foundation; version 3. This project is distributed in the hope that
* it will be useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this project. If not, see <https://www.gnu.org/licenses/>.
*
* For any further details and any questions please contact us under
* contact@nymea.io or see our FAQ/Licensing Information on
* https://nymea.io/license/faq
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WARNING
*
* This file has been autogenerated. Any changes in this file may be overwritten.
* If you want to change something, update the register json or the tool.
*
* Nicht ganz richtig. Diese Datei wurde autogeneriert, und dann abgewandelt. Ist jetzt
* also nicht mehr autogeneriert, und wird auch nicht überschrieben beim Kompilieren.
* Bei änderungen in solax-registers.json oder im Python Script das die Modbus Klassen
* erzeugt muss dann diese Datei nachbearbeitet werden.
*
* Die Änderungen sind beschränkt auf die Methoden update() und initialize().
* Der Solax Inverter hat das Problem, das bei Modbus TCP Nymea die Anfragen schneller
* raus schickt, als sie der Inverter bearbeiten kann. Dies führt zu Modbus Fehlern,
* es kommen dann gar keine Antworten mehr vom Wechselrichter.
* Die Lösung dafür ist, die nächste Modbus Anfrage erst dann los zu schicken, wenn
* die vorherige abgearbeitet wurde. Die Methoden update() und initialize() wurden
* aufgesplittet, so das jede Modbusanfrage in einer eigenen Methode sitzt.
* Die erste Modbusanfrage wird losgeschickt. Wenn deren Antwort da ist, triggert das
* die nächste Methode mit der nächsten Modbusanfrage.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


#include "solaxmodbustcpconnection.h"
#include <loggingcategories.h>
#include <math.h>
#include <QTimer>

NYMEA_LOGGING_CATEGORY(dcSolaxModbusTcpConnection, "SolaxModbusTcpConnection")

SolaxModbusTcpConnection::SolaxModbusTcpConnection(const QHostAddress &hostAddress, uint port, quint16 slaveId, QObject *parent) :
    ModbusTCPMaster(hostAddress, port, parent),
    m_slaveId(slaveId)
{
    connect(this, &ModbusTCPMaster::connectionStateChanged, this, [this](bool status){
        if (status) {
           qCDebug(dcSolaxModbusTcpConnection()) << "Modbus TCP connection" << m_hostAddress.toString() << "connected. Start testing if the connection is reachable...";
            // Cleanup before starting to initialize
            m_pendingInitReplies.clear();
            m_pendingUpdateReplies.clear();
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
            testReachability();
        } else {
            qCWarning(dcSolaxModbusTcpConnection()) << "Modbus TCP connection diconnected from" << m_hostAddress.toString() << ". The connection is not reachable any more.";
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
        }

        evaluateReachableState();
    });
}

bool SolaxModbusTcpConnection::reachable() const
{
    return m_reachable;
}

uint SolaxModbusTcpConnection::checkReachableRetries() const
{
    return m_checkReachableRetries;
}

void SolaxModbusTcpConnection::setCheckReachableRetries(uint checkReachableRetries)
{
    if (m_checkReachableRetries == checkReachableRetries)
        return;

    m_checkReachableRetries = checkReachableRetries;
    emit checkReachableRetriesChanged(m_checkReachableRetries);
}

ModbusDataUtils::ByteOrder SolaxModbusTcpConnection::endianness() const
{
    return m_endianness;
}

void SolaxModbusTcpConnection::setEndianness(ModbusDataUtils::ByteOrder endianness)
{
    if (m_endianness == endianness)
        return;

    m_endianness = endianness;
    emit endiannessChanged(m_endianness);
}

quint16 SolaxModbusTcpConnection::batteryCapacity() const
{
    return m_batteryCapacity;
}

quint16 SolaxModbusTcpConnection::bmsWarningLsb() const
{
    return m_bmsWarningLsb;
}

quint16 SolaxModbusTcpConnection::bmsWarningMsb() const
{
    return m_bmsWarningMsb;
}

quint32 SolaxModbusTcpConnection::inverterFaultBits() const
{
    return m_inverterFaultBits;
}

quint16 SolaxModbusTcpConnection::meter1CommunicationState() const
{
    return m_meter1CommunicationState;
}

quint16 SolaxModbusTcpConnection::activePowerLimit() const
{
    return m_activePowerLimit;
}

quint16 SolaxModbusTcpConnection::firmwareVersion() const
{
    return m_firmwareVersion;
}

quint16 SolaxModbusTcpConnection::inverterType() const
{
    return m_inverterType;
}

QString SolaxModbusTcpConnection::serialNumber() const
{
    return m_serialNumber;
}

QString SolaxModbusTcpConnection::factoryName() const
{
    return m_factoryName;
}

QString SolaxModbusTcpConnection::moduleName() const
{
    return m_moduleName;
}

float SolaxModbusTcpConnection::inverterVoltage() const
{
    return m_inverterVoltage;
}

float SolaxModbusTcpConnection::inverterCurrent() const
{
    return m_inverterCurrent;
}

qint16 SolaxModbusTcpConnection::inverterPower() const
{
    return m_inverterPower;
}

float SolaxModbusTcpConnection::pvVoltage1() const
{
    return m_pvVoltage1;
}

float SolaxModbusTcpConnection::pvVoltage2() const
{
    return m_pvVoltage2;
}

float SolaxModbusTcpConnection::pvCurrent1() const
{
    return m_pvCurrent1;
}

float SolaxModbusTcpConnection::pvCurrent2() const
{
    return m_pvCurrent2;
}

float SolaxModbusTcpConnection::inverterFrequency() const
{
    return m_inverterFrequency;
}

qint16 SolaxModbusTcpConnection::temperature() const
{
    return m_temperature;
}

SolaxModbusTcpConnection::RunMode SolaxModbusTcpConnection::runMode() const
{
    return m_runMode;
}

quint16 SolaxModbusTcpConnection::powerDc1() const
{
    return m_powerDc1;
}

quint16 SolaxModbusTcpConnection::powerDc2() const
{
    return m_powerDc2;
}

float SolaxModbusTcpConnection::batVoltageCharge1() const
{
    return m_batVoltageCharge1;
}

float SolaxModbusTcpConnection::batCurrentCharge1() const
{
    return m_batCurrentCharge1;
}

qint16 SolaxModbusTcpConnection::batPowerCharge1() const
{
    return m_batPowerCharge1;
}

quint16 SolaxModbusTcpConnection::bmsConnectState() const
{
    return m_bmsConnectState;
}

qint16 SolaxModbusTcpConnection::temperatureBat() const
{
    return m_temperatureBat;
}

qint32 SolaxModbusTcpConnection::feedinPower() const
{
    return m_feedinPower;
}

float SolaxModbusTcpConnection::feedinEnergyTotal() const
{
    return m_feedinEnergyTotal;
}

float SolaxModbusTcpConnection::consumEnergyTotal() const
{
    return m_consumEnergyTotal;
}

float SolaxModbusTcpConnection::gridVoltageR() const
{
    return m_gridVoltageR;
}

float SolaxModbusTcpConnection::gridCurrentR() const
{
    return m_gridCurrentR;
}

qint16 SolaxModbusTcpConnection::gridPowerR() const
{
    return m_gridPowerR;
}

float SolaxModbusTcpConnection::gridFrequencyR() const
{
    return m_gridFrequencyR;
}

float SolaxModbusTcpConnection::gridVoltageS() const
{
    return m_gridVoltageS;
}

float SolaxModbusTcpConnection::gridCurrentS() const
{
    return m_gridCurrentS;
}

qint16 SolaxModbusTcpConnection::gridPowerS() const
{
    return m_gridPowerS;
}

float SolaxModbusTcpConnection::gridFrequencyS() const
{
    return m_gridFrequencyS;
}

float SolaxModbusTcpConnection::gridVoltageT() const
{
    return m_gridVoltageT;
}

float SolaxModbusTcpConnection::gridCurrentT() const
{
    return m_gridCurrentT;
}

qint16 SolaxModbusTcpConnection::gridPowerT() const
{
    return m_gridPowerT;
}

float SolaxModbusTcpConnection::gridFrequencyT() const
{
    return m_gridFrequencyT;
}

float SolaxModbusTcpConnection::solarEnergyTotal() const
{
    return m_solarEnergyTotal;
}

float SolaxModbusTcpConnection::solarEnergyToday() const
{
    return m_solarEnergyToday;
}

quint16 SolaxModbusTcpConnection::pvVoltage3() const
{
    return m_pvVoltage3;
}

quint16 SolaxModbusTcpConnection::pvCurrent3() const
{
    return m_pvCurrent3;
}

quint16 SolaxModbusTcpConnection::powerDc3() const
{
    return m_powerDc3;
}

quint16 SolaxModbusTcpConnection::pv3VoltFaultValue() const
{
    return m_pv3VoltFaultValue;
}

quint16 SolaxModbusTcpConnection::pv3VoltFaultValue2() const
{
    return m_pv3VoltFaultValue2;
}

quint16 SolaxModbusTcpConnection::batVoltageCharge2() const
{
    return m_batVoltageCharge2;
}

quint16 SolaxModbusTcpConnection::batCurrentCharge2() const
{
    return m_batCurrentCharge2;
}

qint16 SolaxModbusTcpConnection::batPowerCharge2() const
{
    return m_batPowerCharge2;
}

quint16 SolaxModbusTcpConnection::bms2FaultLsb() const
{
    return m_bms2FaultLsb;
}

quint16 SolaxModbusTcpConnection::bms2FaulMLsb() const
{
    return m_bms2FaulMLsb;
}

quint16 SolaxModbusTcpConnection::batDataReference2() const
{
    return m_batDataReference2;
}

quint16 SolaxModbusTcpConnection::batteryCapacity2() const
{
    return m_batteryCapacity2;
}

quint16 SolaxModbusTcpConnection::totalBatteryCapacity2() const
{
    return m_totalBatteryCapacity2;
}

qint32 SolaxModbusTcpConnection::EoutPowerTotal() const
{
    return m_EoutPowerTotal;
}

qint16 SolaxModbusTcpConnection::temperatureBat2() const
{
    return m_temperatureBat2;
}

bool SolaxModbusTcpConnection::initialize()
{
    if (!m_reachable) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Tried to initialize but the device is not to be reachable.";
        return false;
    }
    if (m_initObject) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Tried to initialize but the init process is already running.";
        return false;
    }

    // Parent object for the init process
    m_initObject = new QObject(this);

    QModbusReply *reply = nullptr;

    // Read Firmware version (0x7D)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read init \"Firmware version (0x7D)\" register:" << 125 << "size:" << 1;
    reply = readFirmwareVersion();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Firmware version (0x7D)\" registers from" << hostAddress().toString() << errorString();
        finishInitialization(false);
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, m_initObject, [this, reply](){
        handleModbusError(reply->error());
        m_pendingInitReplies.removeAll(reply);
        if (reply->error() != QModbusDevice::NoError) {
            finishInitialization(false);
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from init \"Firmware version (0x7D)\" register" << 125 << "size:" << 1 << unit.values();
        processFirmwareVersionRegisterValues(unit.values());
        initialize2();
    });

    connect(reply, &QModbusReply::errorOccurred, m_initObject, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while reading \"Firmware version (0x7D)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    return true;
}

// Split up initialize, so that modbus calls are sent one after the other.
void SolaxModbusTcpConnection::initialize2()
{
    QModbusReply *reply = nullptr;

    // Read Inverter rated power (0xBA)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read init \"Inverter rated power (0xBA)\" register:" << 186 << "size:" << 1;
    reply = readInverterType();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Inverter rated power (0xBA)\" registers from" << hostAddress().toString() << errorString();
        finishInitialization(false);
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, m_initObject, [this, reply](){
        handleModbusError(reply->error());
        m_pendingInitReplies.removeAll(reply);
        if (reply->error() != QModbusDevice::NoError) {
            finishInitialization(false);
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from init \"Inverter rated power (0xBA)\" register" << 186 << "size:" << 1 << unit.values();
        processInverterTypeRegisterValues(unit.values());
        initialize3();
    });

    connect(reply, &QModbusReply::errorOccurred, m_initObject, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while reading \"Inverter rated power (0xBA)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::initialize3()
{
    QModbusReply *reply = nullptr;

    // Read identification
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read init block \"identification\" registers from:" << 0 << "size:" << 21;
    reply = readBlockIdentification();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading block \"identification\" registers";
        finishInitialization(false);
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, m_initObject, [this, reply](){
        m_pendingInitReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            finishInitialization(false);
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from reading init block \"identification\" register" << 0 << "size:" << 21 << blockValues;
        processSerialNumberRegisterValues(blockValues.mid(0, 7));
        processFactoryNameRegisterValues(blockValues.mid(7, 7));
        processModuleNameRegisterValues(blockValues.mid(14, 7));
        verifyInitFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, m_initObject, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"identification\" registers" << error << reply->errorString();
    });
}

bool SolaxModbusTcpConnection::update()
{
    if (!connected())
        return false;

    if (!m_pendingUpdateReplies.isEmpty()) {
        qCDebug(dcSolaxModbusTcpConnection()) << "Tried to update but there are still some update replies pending. Waiting for them to be finished...";
        return true;
    }

    QModbusReply *reply = nullptr;

    // Read Battery state of charge (0x1C)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Battery state of charge (0x1C)\" register:" << 28 << "size:" << 1;
    reply = readBatteryCapacity();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Battery state of charge (0x1C)\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Battery state of charge (0x1C)\" register" << 28 << "size:" << 1 << unit.values();
        processBatteryCapacityRegisterValues(unit.values());
        update2();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while reading \"Battery state of charge (0x1C)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    return true;
}

// Split up update, so that modbus calls are sent one after the other.
void SolaxModbusTcpConnection::update2()
{
    QModbusReply *reply = nullptr;

    // Read BMS warning bits lsb (0x1F)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"BMS warning bits lsb (0x1F)\" register:" << 31 << "size:" << 1;
    reply = readBmsWarningLsb();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"BMS warning bits lsb (0x1F)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"BMS warning bits lsb (0x1F)\" register" << 31 << "size:" << 1 << unit.values();
        processBmsWarningLsbRegisterValues(unit.values());
        update3();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while reading \"BMS warning bits lsb (0x1F)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::update3()
{
    QModbusReply *reply = nullptr;

    // Read BMS warning bits msb (0x26)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"BMS warning bits msb (0x26)\" register:" << 38 << "size:" << 1;
    reply = readBmsWarningMsb();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"BMS warning bits msb (0x26)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"BMS warning bits msb (0x26)\" register" << 38 << "size:" << 1 << unit.values();
        processBmsWarningMsbRegisterValues(unit.values());
        update4();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while reading \"BMS warning bits msb (0x26)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::update4()
{
    QModbusReply *reply = nullptr;

    // Read Inverter fault bits (0x40)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Inverter fault bits (0x40)\" register:" << 64 << "size:" << 2;
    reply = readInverterFaultBits();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Inverter fault bits (0x40)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Inverter fault bits (0x40)\" register" << 64 << "size:" << 2 << unit.values();
        processInverterFaultBitsRegisterValues(unit.values());
        update5();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while reading \"Inverter fault bits (0x40)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::update5()
{
    QModbusReply *reply = nullptr;

    // Read Meter 1 communication status (0xB8)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Meter 1 communication status (0xB8)\" register:" << 184 << "size:" << 1;
    reply = readMeter1CommunicationState();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Meter 1 communication status (0xB8)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Meter 1 communication status (0xB8)\" register" << 184 << "size:" << 1 << unit.values();
        processMeter1CommunicationStateRegisterValues(unit.values());
        update6();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while reading \"Meter 1 communication status (0xB8)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::update6()
{
    QModbusReply *reply = nullptr;

    // Read Active power limit (0x25)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Active power limit (0x25)\" register:" << 37 << "size:" << 1;
    reply = readActivePowerLimit();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Active power limit (0x25)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Active power limit (0x25)\" register" << 37 << "size:" << 1 << unit.values();
        processActivePowerLimitRegisterValues(unit.values());
        update7();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while reading \"Active power limit (0x25)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::update7()
{
    QModbusReply *reply = nullptr;

    // Read pvVoltageAndCurrent
    reply = readBlockPvVoltageAndCurrent();
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read block \"pvVoltageAndCurrent\" registers from:" << 0 << "size:" << 12;
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading block \"pvVoltageAndCurrent\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from reading block \"pvVoltageAndCurrent\" register" << 0 << "size:" << 12 << blockValues;
        processInverterVoltageRegisterValues(blockValues.mid(0, 1));
        processInverterCurrentRegisterValues(blockValues.mid(1, 1));
        processInverterPowerRegisterValues(blockValues.mid(2, 1));
        processPvVoltage1RegisterValues(blockValues.mid(3, 1));
        processPvVoltage2RegisterValues(blockValues.mid(4, 1));
        processPvCurrent1RegisterValues(blockValues.mid(5, 1));
        processPvCurrent2RegisterValues(blockValues.mid(6, 1));
        processInverterFrequencyRegisterValues(blockValues.mid(7, 1));
        processTemperatureRegisterValues(blockValues.mid(8, 1));
        processRunModeRegisterValues(blockValues.mid(9, 1));
        processPowerDc1RegisterValues(blockValues.mid(10, 1));
        processPowerDc2RegisterValues(blockValues.mid(11, 1));
        update8();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"pvVoltageAndCurrent\" registers" << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::update8()
{
    QModbusReply *reply = nullptr;

    // Read batPowerAndState
    reply = readBlockBatPowerAndState();
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read block \"batPowerAndState\" registers from:" << 20 << "size:" << 5;
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading block \"batPowerAndState\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from reading block \"batPowerAndState\" register" << 20 << "size:" << 5 << blockValues;
        processBatVoltageCharge1RegisterValues(blockValues.mid(0, 1));
        processBatCurrentCharge1RegisterValues(blockValues.mid(1, 1));
        processBatPowerCharge1RegisterValues(blockValues.mid(2, 1));
        processBmsConnectStateRegisterValues(blockValues.mid(3, 1));
        processTemperatureBatRegisterValues(blockValues.mid(4, 1));
        update9();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"batPowerAndState\" registers" << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::update9()
{
    QModbusReply *reply = nullptr;

    // Read meterData
    reply = readBlockMeterData();
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read block \"meterData\" registers from:" << 70 << "size:" << 6;
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading block \"meterData\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from reading block \"meterData\" register" << 70 << "size:" << 6 << blockValues;
        processFeedinPowerRegisterValues(blockValues.mid(0, 2));
        processFeedinEnergyTotalRegisterValues(blockValues.mid(2, 2));
        processConsumEnergyTotalRegisterValues(blockValues.mid(4, 2));
        update10();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"meterData\" registers" << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::update10()
{
    QModbusReply *reply = nullptr;

    // Read phasesData
    reply = readBlockPhasesData();
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read block \"phasesData\" registers from:" << 106 << "size:" << 12;
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading block \"phasesData\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from reading block \"phasesData\" register" << 106 << "size:" << 12 << blockValues;
        processGridVoltageRRegisterValues(blockValues.mid(0, 1));
        processGridCurrentRRegisterValues(blockValues.mid(1, 1));
        processGridPowerRRegisterValues(blockValues.mid(2, 1));
        processGridFrequencyRRegisterValues(blockValues.mid(3, 1));
        processGridVoltageSRegisterValues(blockValues.mid(4, 1));
        processGridCurrentSRegisterValues(blockValues.mid(5, 1));
        processGridPowerSRegisterValues(blockValues.mid(6, 1));
        processGridFrequencySRegisterValues(blockValues.mid(7, 1));
        processGridVoltageTRegisterValues(blockValues.mid(8, 1));
        processGridCurrentTRegisterValues(blockValues.mid(9, 1));
        processGridPowerTRegisterValues(blockValues.mid(10, 1));
        processGridFrequencyTRegisterValues(blockValues.mid(11, 1));
        update11();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"phasesData\" registers" << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::update11()
{
    QModbusReply *reply = nullptr;

    // Read solarEnergy
    reply = readBlockSolarEnergy();
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read block \"solarEnergy\" registers from:" << 148 << "size:" << 3;
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading block \"solarEnergy\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from reading block \"solarEnergy\" register" << 148 << "size:" << 3 << blockValues;
        processSolarEnergyTotalRegisterValues(blockValues.mid(0, 2));
        processSolarEnergyTodayRegisterValues(blockValues.mid(2, 1));
        update12();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"solarEnergy\" registers" << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::update12()
{
    QModbusReply *reply = nullptr;
    // Read pv3andbms3
    reply = readBlockPv3andbms3();
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read block \"pv3andbms3\" registers from:" << 290 << "size:" << 16;
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading block \"pv3andbms3\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from reading block \"pv3andbms3\" register" << 290 << "size:" << 16 << blockValues;
        processPvVoltage3RegisterValues(blockValues.mid(0, 1));
        processPvCurrent3RegisterValues(blockValues.mid(1, 1));
        processPowerDc3RegisterValues(blockValues.mid(2, 1));
        processPv3VoltFaultValueRegisterValues(blockValues.mid(3, 1));
        processPv3VoltFaultValue2RegisterValues(blockValues.mid(4, 1));
        processBatVoltageCharge2RegisterValues(blockValues.mid(5, 1));
        processBatCurrentCharge2RegisterValues(blockValues.mid(6, 1));
        processBatPowerCharge2RegisterValues(blockValues.mid(7, 1));
        processBms2FaultLsbRegisterValues(blockValues.mid(8, 1));
        processBms2FaulMLsbRegisterValues(blockValues.mid(9, 1));
        processBatDataReference2RegisterValues(blockValues.mid(10, 1));
        processBatteryCapacity2RegisterValues(blockValues.mid(11, 1));
        processTotalBatteryCapacity2RegisterValues(blockValues.mid(12, 1));
        processEoutPowerTotalRegisterValues(blockValues.mid(13, 2));
        processTemperatureBat2RegisterValues(blockValues.mid(15, 1));
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"pv3andbms3\" registers" << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateBatteryCapacity()
{
    // Update registers from Battery state of charge (0x1C)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Battery state of charge (0x1C)\" register:" << 28 << "size:" << 1;
    QModbusReply *reply = readBatteryCapacity();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Battery state of charge (0x1C)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Battery state of charge (0x1C)\" register" << 28 << "size:" << 1 << unit.values();
            processBatteryCapacityRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"Battery state of charge (0x1C)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateBmsWarningLsb()
{
    // Update registers from BMS warning bits lsb (0x1F)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"BMS warning bits lsb (0x1F)\" register:" << 31 << "size:" << 1;
    QModbusReply *reply = readBmsWarningLsb();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"BMS warning bits lsb (0x1F)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"BMS warning bits lsb (0x1F)\" register" << 31 << "size:" << 1 << unit.values();
            processBmsWarningLsbRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"BMS warning bits lsb (0x1F)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateBmsWarningMsb()
{
    // Update registers from BMS warning bits msb (0x26)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"BMS warning bits msb (0x26)\" register:" << 38 << "size:" << 1;
    QModbusReply *reply = readBmsWarningMsb();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"BMS warning bits msb (0x26)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"BMS warning bits msb (0x26)\" register" << 38 << "size:" << 1 << unit.values();
            processBmsWarningMsbRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"BMS warning bits msb (0x26)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateInverterFaultBits()
{
    // Update registers from Inverter fault bits (0x40)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Inverter fault bits (0x40)\" register:" << 64 << "size:" << 2;
    QModbusReply *reply = readInverterFaultBits();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Inverter fault bits (0x40)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Inverter fault bits (0x40)\" register" << 64 << "size:" << 2 << unit.values();
            processInverterFaultBitsRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"Inverter fault bits (0x40)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateMeter1CommunicationState()
{
    // Update registers from Meter 1 communication status (0xB8)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Meter 1 communication status (0xB8)\" register:" << 184 << "size:" << 1;
    QModbusReply *reply = readMeter1CommunicationState();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Meter 1 communication status (0xB8)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Meter 1 communication status (0xB8)\" register" << 184 << "size:" << 1 << unit.values();
            processMeter1CommunicationStateRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"Meter 1 communication status (0xB8)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateActivePowerLimit()
{
    // Update registers from Active power limit (0x25)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Active power limit (0x25)\" register:" << 37 << "size:" << 1;
    QModbusReply *reply = readActivePowerLimit();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Active power limit (0x25)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Active power limit (0x25)\" register" << 37 << "size:" << 1 << unit.values();
            processActivePowerLimitRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"Active power limit (0x25)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateBatPowerCharge1()
{
    // Update registers from Battery power charge1 (0x16)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Battery power charge1 (0x16)\" register:" << 22 << "size:" << 1;
    QModbusReply *reply = readBatPowerCharge1();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Battery power charge1 (0x16)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Battery power charge1 (0x16)\" register" << 22 << "size:" << 1 << unit.values();
            processBatPowerCharge1RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"Battery power charge1 (0x16)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateBmsConnectState()
{
    // Update registers from BMS connected state (0x17)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"BMS connected state (0x17)\" register:" << 23 << "size:" << 1;
    QModbusReply *reply = readBmsConnectState();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"BMS connected state (0x17)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"BMS connected state (0x17)\" register" << 23 << "size:" << 1 << unit.values();
            processBmsConnectStateRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"BMS connected state (0x17)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateFeedinPower()
{
    // Update registers from Power to grid (0x46). Positive means exported power, negative means consumed power.
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Power to grid (0x46). Positive means exported power, negative means consumed power.\" register:" << 70 << "size:" << 2;
    QModbusReply *reply = readFeedinPower();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Power to grid (0x46). Positive means exported power, negative means consumed power.\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Power to grid (0x46). Positive means exported power, negative means consumed power.\" register" << 70 << "size:" << 2 << unit.values();
            processFeedinPowerRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"Power to grid (0x46). Positive means exported power, negative means consumed power.\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateFeedinEnergyTotal()
{
    // Update registers from Exported energy, total (0x48)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Exported energy, total (0x48)\" register:" << 72 << "size:" << 2;
    QModbusReply *reply = readFeedinEnergyTotal();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Exported energy, total (0x48)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Exported energy, total (0x48)\" register" << 72 << "size:" << 2 << unit.values();
            processFeedinEnergyTotalRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"Exported energy, total (0x48)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateConsumEnergyTotal()
{
    // Update registers from Consumed energy, total (0x4A)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Consumed energy, total (0x4A)\" register:" << 74 << "size:" << 2;
    QModbusReply *reply = readConsumEnergyTotal();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Consumed energy, total (0x4A)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Consumed energy, total (0x4A)\" register" << 74 << "size:" << 2 << unit.values();
            processConsumEnergyTotalRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"Consumed energy, total (0x4A)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateGridVoltageR()
{
    // Update registers from Phase R voltage (0x6A)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Phase R voltage (0x6A)\" register:" << 106 << "size:" << 1;
    QModbusReply *reply = readGridVoltageR();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Phase R voltage (0x6A)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Phase R voltage (0x6A)\" register" << 106 << "size:" << 1 << unit.values();
            processGridVoltageRRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"Phase R voltage (0x6A)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateGridCurrentR()
{
    // Update registers from Phase R current (0x6B)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Phase R current (0x6B)\" register:" << 107 << "size:" << 1;
    QModbusReply *reply = readGridCurrentR();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Phase R current (0x6B)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Phase R current (0x6B)\" register" << 107 << "size:" << 1 << unit.values();
            processGridCurrentRRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"Phase R current (0x6B)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateGridPowerR()
{
    // Update registers from Phase R power (0x6C)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Phase R power (0x6C)\" register:" << 108 << "size:" << 1;
    QModbusReply *reply = readGridPowerR();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Phase R power (0x6C)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Phase R power (0x6C)\" register" << 108 << "size:" << 1 << unit.values();
            processGridPowerRRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"Phase R power (0x6C)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateGridVoltageS()
{
    // Update registers from Phase S voltage (0x6E)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Phase S voltage (0x6E)\" register:" << 110 << "size:" << 1;
    QModbusReply *reply = readGridVoltageS();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Phase S voltage (0x6E)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Phase S voltage (0x6E)\" register" << 110 << "size:" << 1 << unit.values();
            processGridVoltageSRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"Phase S voltage (0x6E)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateGridCurrentS()
{
    // Update registers from Phase S current (0x6F)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Phase S current (0x6F)\" register:" << 111 << "size:" << 1;
    QModbusReply *reply = readGridCurrentS();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Phase S current (0x6F)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Phase S current (0x6F)\" register" << 111 << "size:" << 1 << unit.values();
            processGridCurrentSRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"Phase S current (0x6F)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateGridPowerS()
{
    // Update registers from Phase S power (0x70)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Phase S power (0x70)\" register:" << 112 << "size:" << 1;
    QModbusReply *reply = readGridPowerS();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Phase S power (0x70)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Phase S power (0x70)\" register" << 112 << "size:" << 1 << unit.values();
            processGridPowerSRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"Phase S power (0x70)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateGridVoltageT()
{
    // Update registers from Phase T voltage (0x72)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Phase T voltage (0x72)\" register:" << 114 << "size:" << 1;
    QModbusReply *reply = readGridVoltageT();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Phase T voltage (0x72)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Phase T voltage (0x72)\" register" << 114 << "size:" << 1 << unit.values();
            processGridVoltageTRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"Phase T voltage (0x72)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateGridCurrentT()
{
    // Update registers from Phase T current (0x73)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Phase T current (0x73)\" register:" << 115 << "size:" << 1;
    QModbusReply *reply = readGridCurrentT();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Phase T current (0x73)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Phase T current (0x73)\" register" << 115 << "size:" << 1 << unit.values();
            processGridCurrentTRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"Phase T current (0x73)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateGridPowerT()
{
    // Update registers from Phase T power (0x74)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Phase T power (0x74)\" register:" << 116 << "size:" << 1;
    QModbusReply *reply = readGridPowerT();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Phase T power (0x74)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Phase T power (0x74)\" register" << 116 << "size:" << 1 << unit.values();
            processGridPowerTRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"Phase T power (0x74)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateSolarEnergyTotal()
{
    // Update registers from Solar energy produced total (0x94)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Solar energy produced total (0x94)\" register:" << 148 << "size:" << 2;
    QModbusReply *reply = readSolarEnergyTotal();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Solar energy produced total (0x94)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Solar energy produced total (0x94)\" register" << 148 << "size:" << 2 << unit.values();
            processSolarEnergyTotalRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"Solar energy produced total (0x94)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateSolarEnergyToday()
{
    // Update registers from Solar energy produced today (0x96)
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read \"Solar energy produced today (0x96)\" register:" << 150 << "size:" << 1;
    QModbusReply *reply = readSolarEnergyToday();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading \"Solar energy produced today (0x96)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from \"Solar energy produced today (0x96)\" register" << 150 << "size:" << 1 << unit.values();
            processSolarEnergyTodayRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating \"Solar energy produced today (0x96)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateIdentificationBlock()
{
    // Update register block "identification"
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read block \"identification\" registers from:" << 0 << "size:" << 21;
    QModbusReply *reply = readBlockIdentification();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading block \"identification\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from reading block \"identification\" register" << 0 << "size:" << 21 << blockValues;
            processSerialNumberRegisterValues(blockValues.mid(0, 7));
            processFactoryNameRegisterValues(blockValues.mid(7, 7));
            processModuleNameRegisterValues(blockValues.mid(14, 7));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"identification\" registers" << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updatePvVoltageAndCurrentBlock()
{
    // Update register block "pvVoltageAndCurrent"
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read block \"pvVoltageAndCurrent\" registers from:" << 0 << "size:" << 12;
    QModbusReply *reply = readBlockPvVoltageAndCurrent();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading block \"pvVoltageAndCurrent\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from reading block \"pvVoltageAndCurrent\" register" << 0 << "size:" << 12 << blockValues;
            processInverterVoltageRegisterValues(blockValues.mid(0, 1));
            processInverterCurrentRegisterValues(blockValues.mid(1, 1));
            processInverterPowerRegisterValues(blockValues.mid(2, 1));
            processPvVoltage1RegisterValues(blockValues.mid(3, 1));
            processPvVoltage2RegisterValues(blockValues.mid(4, 1));
            processPvCurrent1RegisterValues(blockValues.mid(5, 1));
            processPvCurrent2RegisterValues(blockValues.mid(6, 1));
            processInverterFrequencyRegisterValues(blockValues.mid(7, 1));
            processTemperatureRegisterValues(blockValues.mid(8, 1));
            processRunModeRegisterValues(blockValues.mid(9, 1));
            processPowerDc1RegisterValues(blockValues.mid(10, 1));
            processPowerDc2RegisterValues(blockValues.mid(11, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"pvVoltageAndCurrent\" registers" << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateBatPowerAndStateBlock()
{
    // Update register block "batPowerAndState"
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read block \"batPowerAndState\" registers from:" << 20 << "size:" << 5;
    QModbusReply *reply = readBlockBatPowerAndState();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading block \"batPowerAndState\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from reading block \"batPowerAndState\" register" << 20 << "size:" << 5 << blockValues;
            processBatVoltageCharge1RegisterValues(blockValues.mid(0, 1));
            processBatCurrentCharge1RegisterValues(blockValues.mid(1, 1));
            processBatPowerCharge1RegisterValues(blockValues.mid(2, 1));
            processBmsConnectStateRegisterValues(blockValues.mid(3, 1));
            processTemperatureBatRegisterValues(blockValues.mid(4, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"batPowerAndState\" registers" << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateMeterDataBlock()
{
    // Update register block "meterData"
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read block \"meterData\" registers from:" << 70 << "size:" << 6;
    QModbusReply *reply = readBlockMeterData();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading block \"meterData\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from reading block \"meterData\" register" << 70 << "size:" << 6 << blockValues;
            processFeedinPowerRegisterValues(blockValues.mid(0, 2));
            processFeedinEnergyTotalRegisterValues(blockValues.mid(2, 2));
            processConsumEnergyTotalRegisterValues(blockValues.mid(4, 2));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"meterData\" registers" << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updatePhasesDataBlock()
{
    // Update register block "phasesData"
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read block \"phasesData\" registers from:" << 106 << "size:" << 12;
    QModbusReply *reply = readBlockPhasesData();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading block \"phasesData\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from reading block \"phasesData\" register" << 106 << "size:" << 12 << blockValues;
            processGridVoltageRRegisterValues(blockValues.mid(0, 1));
            processGridCurrentRRegisterValues(blockValues.mid(1, 1));
            processGridPowerRRegisterValues(blockValues.mid(2, 1));
            processGridFrequencyRRegisterValues(blockValues.mid(3, 1));
            processGridVoltageSRegisterValues(blockValues.mid(4, 1));
            processGridCurrentSRegisterValues(blockValues.mid(5, 1));
            processGridPowerSRegisterValues(blockValues.mid(6, 1));
            processGridFrequencySRegisterValues(blockValues.mid(7, 1));
            processGridVoltageTRegisterValues(blockValues.mid(8, 1));
            processGridCurrentTRegisterValues(blockValues.mid(9, 1));
            processGridPowerTRegisterValues(blockValues.mid(10, 1));
            processGridFrequencyTRegisterValues(blockValues.mid(11, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"phasesData\" registers" << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updateSolarEnergyBlock()
{
    // Update register block "solarEnergy"
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read block \"solarEnergy\" registers from:" << 148 << "size:" << 3;
    QModbusReply *reply = readBlockSolarEnergy();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading block \"solarEnergy\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from reading block \"solarEnergy\" register" << 148 << "size:" << 3 << blockValues;
            processSolarEnergyTotalRegisterValues(blockValues.mid(0, 2));
            processSolarEnergyTodayRegisterValues(blockValues.mid(2, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"solarEnergy\" registers" << error << reply->errorString();
    });
}

void SolaxModbusTcpConnection::updatePv3andbms3Block()
{
    // Update register block "pv3andbms3"
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Read block \"pv3andbms3\" registers from:" << 290 << "size:" << 16;
    QModbusReply *reply = readBlockPv3andbms3();
    if (!reply) {
        qCWarning(dcSolaxModbusTcpConnection()) << "Error occurred while reading block \"pv3andbms3\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcSolaxModbusTcpConnection()) << "<-- Response from reading block \"pv3andbms3\" register" << 290 << "size:" << 16 << blockValues;
            processPvVoltage3RegisterValues(blockValues.mid(0, 1));
            processPvCurrent3RegisterValues(blockValues.mid(1, 1));
            processPowerDc3RegisterValues(blockValues.mid(2, 1));
            processPv3VoltFaultValueRegisterValues(blockValues.mid(3, 1));
            processPv3VoltFaultValue2RegisterValues(blockValues.mid(4, 1));
            processBatVoltageCharge2RegisterValues(blockValues.mid(5, 1));
            processBatCurrentCharge2RegisterValues(blockValues.mid(6, 1));
            processBatPowerCharge2RegisterValues(blockValues.mid(7, 1));
            processBms2FaultLsbRegisterValues(blockValues.mid(8, 1));
            processBms2FaulMLsbRegisterValues(blockValues.mid(9, 1));
            processBatDataReference2RegisterValues(blockValues.mid(10, 1));
            processBatteryCapacity2RegisterValues(blockValues.mid(11, 1));
            processTotalBatteryCapacity2RegisterValues(blockValues.mid(12, 1));
            processEoutPowerTotalRegisterValues(blockValues.mid(13, 2));
            processTemperatureBat2RegisterValues(blockValues.mid(15, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"pv3andbms3\" registers" << error << reply->errorString();
    });
}

QModbusReply *SolaxModbusTcpConnection::readBatteryCapacity()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 28, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBmsWarningLsb()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 31, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBmsWarningMsb()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 38, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readInverterFaultBits()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 64, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readMeter1CommunicationState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 184, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readActivePowerLimit()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 37, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readFirmwareVersion()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 125, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readInverterType()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 186, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readSerialNumber()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 0, 7);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readFactoryName()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 7, 7);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readModuleName()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 14, 7);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readInverterVoltage()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 0, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readInverterCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 1, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readInverterPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 2, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readPvVoltage1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 3, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readPvVoltage2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 4, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readPvCurrent1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 5, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readPvCurrent2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 6, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readInverterFrequency()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 7, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 8, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readRunMode()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 9, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readPowerDc1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 10, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readPowerDc2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 11, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBatVoltageCharge1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 20, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBatCurrentCharge1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 21, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBatPowerCharge1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 22, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBmsConnectState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 23, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readTemperatureBat()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 24, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readFeedinPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 70, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readFeedinEnergyTotal()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 72, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readConsumEnergyTotal()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 74, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readGridVoltageR()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 106, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readGridCurrentR()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 107, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readGridPowerR()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 108, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readGridFrequencyR()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 109, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readGridVoltageS()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 110, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readGridCurrentS()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 111, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readGridPowerS()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 112, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readGridFrequencyS()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 113, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readGridVoltageT()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 114, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readGridCurrentT()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 115, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readGridPowerT()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 116, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readGridFrequencyT()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 117, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readSolarEnergyTotal()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 148, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readSolarEnergyToday()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 150, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readPvVoltage3()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 290, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readPvCurrent3()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 291, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readPowerDc3()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 292, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readPv3VoltFaultValue()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 293, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readPv3VoltFaultValue2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 294, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBatVoltageCharge2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 295, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBatCurrentCharge2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 296, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBatPowerCharge2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 297, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBms2FaultLsb()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 298, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBms2FaulMLsb()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 299, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBatDataReference2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 300, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBatteryCapacity2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 301, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readTotalBatteryCapacity2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 302, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readEoutPowerTotal()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 303, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readTemperatureBat2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 305, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBlockIdentification()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 0, 21);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBlockPvVoltageAndCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 0, 12);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBlockBatPowerAndState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 20, 5);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBlockMeterData()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 70, 6);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBlockPhasesData()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 106, 12);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBlockSolarEnergy()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 148, 3);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *SolaxModbusTcpConnection::readBlockPv3andbms3()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::InputRegisters, 290, 16);
    return sendReadRequest(request, m_slaveId);
}

void SolaxModbusTcpConnection::processBatteryCapacityRegisterValues(const QVector<quint16> values)
{
    quint16 receivedBatteryCapacity = ModbusDataUtils::convertToUInt16(values);
    emit batteryCapacityReadFinished(receivedBatteryCapacity);

    if (m_batteryCapacity != receivedBatteryCapacity) {
        m_batteryCapacity = receivedBatteryCapacity;
        emit batteryCapacityChanged(m_batteryCapacity);
    }
}

void SolaxModbusTcpConnection::processBmsWarningLsbRegisterValues(const QVector<quint16> values)
{
    quint16 receivedBmsWarningLsb = ModbusDataUtils::convertToUInt16(values);
    emit bmsWarningLsbReadFinished(receivedBmsWarningLsb);

    if (m_bmsWarningLsb != receivedBmsWarningLsb) {
        m_bmsWarningLsb = receivedBmsWarningLsb;
        emit bmsWarningLsbChanged(m_bmsWarningLsb);
    }
}

void SolaxModbusTcpConnection::processBmsWarningMsbRegisterValues(const QVector<quint16> values)
{
    quint16 receivedBmsWarningMsb = ModbusDataUtils::convertToUInt16(values);
    emit bmsWarningMsbReadFinished(receivedBmsWarningMsb);

    if (m_bmsWarningMsb != receivedBmsWarningMsb) {
        m_bmsWarningMsb = receivedBmsWarningMsb;
        emit bmsWarningMsbChanged(m_bmsWarningMsb);
    }
}

void SolaxModbusTcpConnection::processInverterFaultBitsRegisterValues(const QVector<quint16> values)
{
    quint32 receivedInverterFaultBits = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit inverterFaultBitsReadFinished(receivedInverterFaultBits);

    if (m_inverterFaultBits != receivedInverterFaultBits) {
        m_inverterFaultBits = receivedInverterFaultBits;
        emit inverterFaultBitsChanged(m_inverterFaultBits);
    }
}

void SolaxModbusTcpConnection::processMeter1CommunicationStateRegisterValues(const QVector<quint16> values)
{
    quint16 receivedMeter1CommunicationState = ModbusDataUtils::convertToUInt16(values);
    emit meter1CommunicationStateReadFinished(receivedMeter1CommunicationState);

    if (m_meter1CommunicationState != receivedMeter1CommunicationState) {
        m_meter1CommunicationState = receivedMeter1CommunicationState;
        emit meter1CommunicationStateChanged(m_meter1CommunicationState);
    }
}

void SolaxModbusTcpConnection::processActivePowerLimitRegisterValues(const QVector<quint16> values)
{
    quint16 receivedActivePowerLimit = ModbusDataUtils::convertToUInt16(values);
    emit activePowerLimitReadFinished(receivedActivePowerLimit);

    if (m_activePowerLimit != receivedActivePowerLimit) {
        m_activePowerLimit = receivedActivePowerLimit;
        emit activePowerLimitChanged(m_activePowerLimit);
    }
}

void SolaxModbusTcpConnection::processFirmwareVersionRegisterValues(const QVector<quint16> values)
{
    quint16 receivedFirmwareVersion = ModbusDataUtils::convertToUInt16(values);
    emit firmwareVersionReadFinished(receivedFirmwareVersion);

    if (m_firmwareVersion != receivedFirmwareVersion) {
        m_firmwareVersion = receivedFirmwareVersion;
        emit firmwareVersionChanged(m_firmwareVersion);
    }
}

void SolaxModbusTcpConnection::processInverterTypeRegisterValues(const QVector<quint16> values)
{
    quint16 receivedInverterType = ModbusDataUtils::convertToUInt16(values);
    emit inverterTypeReadFinished(receivedInverterType);

    if (m_inverterType != receivedInverterType) {
        m_inverterType = receivedInverterType;
        emit inverterTypeChanged(m_inverterType);
    }
}

void SolaxModbusTcpConnection::processSerialNumberRegisterValues(const QVector<quint16> values)
{
    QString receivedSerialNumber = ModbusDataUtils::convertToString(values);
    emit serialNumberReadFinished(receivedSerialNumber);

    if (m_serialNumber != receivedSerialNumber) {
        m_serialNumber = receivedSerialNumber;
        emit serialNumberChanged(m_serialNumber);
    }
}

void SolaxModbusTcpConnection::processFactoryNameRegisterValues(const QVector<quint16> values)
{
    QString receivedFactoryName = ModbusDataUtils::convertToString(values);
    emit factoryNameReadFinished(receivedFactoryName);

    if (m_factoryName != receivedFactoryName) {
        m_factoryName = receivedFactoryName;
        emit factoryNameChanged(m_factoryName);
    }
}

void SolaxModbusTcpConnection::processModuleNameRegisterValues(const QVector<quint16> values)
{
    QString receivedModuleName = ModbusDataUtils::convertToString(values);
    emit moduleNameReadFinished(receivedModuleName);

    if (m_moduleName != receivedModuleName) {
        m_moduleName = receivedModuleName;
        emit moduleNameChanged(m_moduleName);
    }
}

void SolaxModbusTcpConnection::processInverterVoltageRegisterValues(const QVector<quint16> values)
{
    float receivedInverterVoltage = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit inverterVoltageReadFinished(receivedInverterVoltage);

    if (m_inverterVoltage != receivedInverterVoltage) {
        m_inverterVoltage = receivedInverterVoltage;
        emit inverterVoltageChanged(m_inverterVoltage);
    }
}

void SolaxModbusTcpConnection::processInverterCurrentRegisterValues(const QVector<quint16> values)
{
    float receivedInverterCurrent = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit inverterCurrentReadFinished(receivedInverterCurrent);

    if (m_inverterCurrent != receivedInverterCurrent) {
        m_inverterCurrent = receivedInverterCurrent;
        emit inverterCurrentChanged(m_inverterCurrent);
    }
}

void SolaxModbusTcpConnection::processInverterPowerRegisterValues(const QVector<quint16> values)
{
    qint16 receivedInverterPower = ModbusDataUtils::convertToInt16(values);
    emit inverterPowerReadFinished(receivedInverterPower);

    if (m_inverterPower != receivedInverterPower) {
        m_inverterPower = receivedInverterPower;
        emit inverterPowerChanged(m_inverterPower);
    }
}

void SolaxModbusTcpConnection::processPvVoltage1RegisterValues(const QVector<quint16> values)
{
    float receivedPvVoltage1 = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit pvVoltage1ReadFinished(receivedPvVoltage1);

    if (m_pvVoltage1 != receivedPvVoltage1) {
        m_pvVoltage1 = receivedPvVoltage1;
        emit pvVoltage1Changed(m_pvVoltage1);
    }
}

void SolaxModbusTcpConnection::processPvVoltage2RegisterValues(const QVector<quint16> values)
{
    float receivedPvVoltage2 = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit pvVoltage2ReadFinished(receivedPvVoltage2);

    if (m_pvVoltage2 != receivedPvVoltage2) {
        m_pvVoltage2 = receivedPvVoltage2;
        emit pvVoltage2Changed(m_pvVoltage2);
    }
}

void SolaxModbusTcpConnection::processPvCurrent1RegisterValues(const QVector<quint16> values)
{
    float receivedPvCurrent1 = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit pvCurrent1ReadFinished(receivedPvCurrent1);

    if (m_pvCurrent1 != receivedPvCurrent1) {
        m_pvCurrent1 = receivedPvCurrent1;
        emit pvCurrent1Changed(m_pvCurrent1);
    }
}

void SolaxModbusTcpConnection::processPvCurrent2RegisterValues(const QVector<quint16> values)
{
    float receivedPvCurrent2 = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit pvCurrent2ReadFinished(receivedPvCurrent2);

    if (m_pvCurrent2 != receivedPvCurrent2) {
        m_pvCurrent2 = receivedPvCurrent2;
        emit pvCurrent2Changed(m_pvCurrent2);
    }
}

void SolaxModbusTcpConnection::processInverterFrequencyRegisterValues(const QVector<quint16> values)
{
    float receivedInverterFrequency = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit inverterFrequencyReadFinished(receivedInverterFrequency);

    if (m_inverterFrequency != receivedInverterFrequency) {
        m_inverterFrequency = receivedInverterFrequency;
        emit inverterFrequencyChanged(m_inverterFrequency);
    }
}

void SolaxModbusTcpConnection::processTemperatureRegisterValues(const QVector<quint16> values)
{
    qint16 receivedTemperature = ModbusDataUtils::convertToInt16(values);
    emit temperatureReadFinished(receivedTemperature);

    if (m_temperature != receivedTemperature) {
        m_temperature = receivedTemperature;
        emit temperatureChanged(m_temperature);
    }
}

void SolaxModbusTcpConnection::processRunModeRegisterValues(const QVector<quint16> values)
{
    RunMode receivedRunMode = static_cast<RunMode>(ModbusDataUtils::convertToUInt16(values));
    emit runModeReadFinished(receivedRunMode);

    if (m_runMode != receivedRunMode) {
        m_runMode = receivedRunMode;
        emit runModeChanged(m_runMode);
    }
}

void SolaxModbusTcpConnection::processPowerDc1RegisterValues(const QVector<quint16> values)
{
    quint16 receivedPowerDc1 = ModbusDataUtils::convertToUInt16(values);
    emit powerDc1ReadFinished(receivedPowerDc1);

    if (m_powerDc1 != receivedPowerDc1) {
        m_powerDc1 = receivedPowerDc1;
        emit powerDc1Changed(m_powerDc1);
    }
}

void SolaxModbusTcpConnection::processPowerDc2RegisterValues(const QVector<quint16> values)
{
    quint16 receivedPowerDc2 = ModbusDataUtils::convertToUInt16(values);
    emit powerDc2ReadFinished(receivedPowerDc2);

    if (m_powerDc2 != receivedPowerDc2) {
        m_powerDc2 = receivedPowerDc2;
        emit powerDc2Changed(m_powerDc2);
    }
}

void SolaxModbusTcpConnection::processBatVoltageCharge1RegisterValues(const QVector<quint16> values)
{
    float receivedBatVoltageCharge1 = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit batVoltageCharge1ReadFinished(receivedBatVoltageCharge1);

    if (m_batVoltageCharge1 != receivedBatVoltageCharge1) {
        m_batVoltageCharge1 = receivedBatVoltageCharge1;
        emit batVoltageCharge1Changed(m_batVoltageCharge1);
    }
}

void SolaxModbusTcpConnection::processBatCurrentCharge1RegisterValues(const QVector<quint16> values)
{
    float receivedBatCurrentCharge1 = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit batCurrentCharge1ReadFinished(receivedBatCurrentCharge1);

    if (m_batCurrentCharge1 != receivedBatCurrentCharge1) {
        m_batCurrentCharge1 = receivedBatCurrentCharge1;
        emit batCurrentCharge1Changed(m_batCurrentCharge1);
    }
}

void SolaxModbusTcpConnection::processBatPowerCharge1RegisterValues(const QVector<quint16> values)
{
    qint16 receivedBatPowerCharge1 = ModbusDataUtils::convertToInt16(values);
    emit batPowerCharge1ReadFinished(receivedBatPowerCharge1);

    if (m_batPowerCharge1 != receivedBatPowerCharge1) {
        m_batPowerCharge1 = receivedBatPowerCharge1;
        emit batPowerCharge1Changed(m_batPowerCharge1);
    }
}

void SolaxModbusTcpConnection::processBmsConnectStateRegisterValues(const QVector<quint16> values)
{
    quint16 receivedBmsConnectState = ModbusDataUtils::convertToUInt16(values);
    emit bmsConnectStateReadFinished(receivedBmsConnectState);

    if (m_bmsConnectState != receivedBmsConnectState) {
        m_bmsConnectState = receivedBmsConnectState;
        emit bmsConnectStateChanged(m_bmsConnectState);
    }
}

void SolaxModbusTcpConnection::processTemperatureBatRegisterValues(const QVector<quint16> values)
{
    qint16 receivedTemperatureBat = ModbusDataUtils::convertToInt16(values);
    emit temperatureBatReadFinished(receivedTemperatureBat);

    if (m_temperatureBat != receivedTemperatureBat) {
        m_temperatureBat = receivedTemperatureBat;
        emit temperatureBatChanged(m_temperatureBat);
    }
}

void SolaxModbusTcpConnection::processFeedinPowerRegisterValues(const QVector<quint16> values)
{
    qint32 receivedFeedinPower = ModbusDataUtils::convertToInt32(values, m_endianness);
    emit feedinPowerReadFinished(receivedFeedinPower);

    if (m_feedinPower != receivedFeedinPower) {
        m_feedinPower = receivedFeedinPower;
        emit feedinPowerChanged(m_feedinPower);
    }
}

void SolaxModbusTcpConnection::processFeedinEnergyTotalRegisterValues(const QVector<quint16> values)
{
    float receivedFeedinEnergyTotal = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -2);
    emit feedinEnergyTotalReadFinished(receivedFeedinEnergyTotal);

    if (m_feedinEnergyTotal != receivedFeedinEnergyTotal) {
        m_feedinEnergyTotal = receivedFeedinEnergyTotal;
        emit feedinEnergyTotalChanged(m_feedinEnergyTotal);
    }
}

void SolaxModbusTcpConnection::processConsumEnergyTotalRegisterValues(const QVector<quint16> values)
{
    float receivedConsumEnergyTotal = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -2);
    emit consumEnergyTotalReadFinished(receivedConsumEnergyTotal);

    if (m_consumEnergyTotal != receivedConsumEnergyTotal) {
        m_consumEnergyTotal = receivedConsumEnergyTotal;
        emit consumEnergyTotalChanged(m_consumEnergyTotal);
    }
}

void SolaxModbusTcpConnection::processGridVoltageRRegisterValues(const QVector<quint16> values)
{
    float receivedGridVoltageR = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit gridVoltageRReadFinished(receivedGridVoltageR);

    if (m_gridVoltageR != receivedGridVoltageR) {
        m_gridVoltageR = receivedGridVoltageR;
        emit gridVoltageRChanged(m_gridVoltageR);
    }
}

void SolaxModbusTcpConnection::processGridCurrentRRegisterValues(const QVector<quint16> values)
{
    float receivedGridCurrentR = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit gridCurrentRReadFinished(receivedGridCurrentR);

    if (m_gridCurrentR != receivedGridCurrentR) {
        m_gridCurrentR = receivedGridCurrentR;
        emit gridCurrentRChanged(m_gridCurrentR);
    }
}

void SolaxModbusTcpConnection::processGridPowerRRegisterValues(const QVector<quint16> values)
{
    qint16 receivedGridPowerR = ModbusDataUtils::convertToInt16(values);
    emit gridPowerRReadFinished(receivedGridPowerR);

    if (m_gridPowerR != receivedGridPowerR) {
        m_gridPowerR = receivedGridPowerR;
        emit gridPowerRChanged(m_gridPowerR);
    }
}

void SolaxModbusTcpConnection::processGridFrequencyRRegisterValues(const QVector<quint16> values)
{
    float receivedGridFrequencyR = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit gridFrequencyRReadFinished(receivedGridFrequencyR);

    if (m_gridFrequencyR != receivedGridFrequencyR) {
        m_gridFrequencyR = receivedGridFrequencyR;
        emit gridFrequencyRChanged(m_gridFrequencyR);
    }
}

void SolaxModbusTcpConnection::processGridVoltageSRegisterValues(const QVector<quint16> values)
{
    float receivedGridVoltageS = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit gridVoltageSReadFinished(receivedGridVoltageS);

    if (m_gridVoltageS != receivedGridVoltageS) {
        m_gridVoltageS = receivedGridVoltageS;
        emit gridVoltageSChanged(m_gridVoltageS);
    }
}

void SolaxModbusTcpConnection::processGridCurrentSRegisterValues(const QVector<quint16> values)
{
    float receivedGridCurrentS = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit gridCurrentSReadFinished(receivedGridCurrentS);

    if (m_gridCurrentS != receivedGridCurrentS) {
        m_gridCurrentS = receivedGridCurrentS;
        emit gridCurrentSChanged(m_gridCurrentS);
    }
}

void SolaxModbusTcpConnection::processGridPowerSRegisterValues(const QVector<quint16> values)
{
    qint16 receivedGridPowerS = ModbusDataUtils::convertToInt16(values);
    emit gridPowerSReadFinished(receivedGridPowerS);

    if (m_gridPowerS != receivedGridPowerS) {
        m_gridPowerS = receivedGridPowerS;
        emit gridPowerSChanged(m_gridPowerS);
    }
}

void SolaxModbusTcpConnection::processGridFrequencySRegisterValues(const QVector<quint16> values)
{
    float receivedGridFrequencyS = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit gridFrequencySReadFinished(receivedGridFrequencyS);

    if (m_gridFrequencyS != receivedGridFrequencyS) {
        m_gridFrequencyS = receivedGridFrequencyS;
        emit gridFrequencySChanged(m_gridFrequencyS);
    }
}

void SolaxModbusTcpConnection::processGridVoltageTRegisterValues(const QVector<quint16> values)
{
    float receivedGridVoltageT = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit gridVoltageTReadFinished(receivedGridVoltageT);

    if (m_gridVoltageT != receivedGridVoltageT) {
        m_gridVoltageT = receivedGridVoltageT;
        emit gridVoltageTChanged(m_gridVoltageT);
    }
}

void SolaxModbusTcpConnection::processGridCurrentTRegisterValues(const QVector<quint16> values)
{
    float receivedGridCurrentT = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -1);
    emit gridCurrentTReadFinished(receivedGridCurrentT);

    if (m_gridCurrentT != receivedGridCurrentT) {
        m_gridCurrentT = receivedGridCurrentT;
        emit gridCurrentTChanged(m_gridCurrentT);
    }
}

void SolaxModbusTcpConnection::processGridPowerTRegisterValues(const QVector<quint16> values)
{
    qint16 receivedGridPowerT = ModbusDataUtils::convertToInt16(values);
    emit gridPowerTReadFinished(receivedGridPowerT);

    if (m_gridPowerT != receivedGridPowerT) {
        m_gridPowerT = receivedGridPowerT;
        emit gridPowerTChanged(m_gridPowerT);
    }
}

void SolaxModbusTcpConnection::processGridFrequencyTRegisterValues(const QVector<quint16> values)
{
    float receivedGridFrequencyT = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -2);
    emit gridFrequencyTReadFinished(receivedGridFrequencyT);

    if (m_gridFrequencyT != receivedGridFrequencyT) {
        m_gridFrequencyT = receivedGridFrequencyT;
        emit gridFrequencyTChanged(m_gridFrequencyT);
    }
}

void SolaxModbusTcpConnection::processSolarEnergyTotalRegisterValues(const QVector<quint16> values)
{
    float receivedSolarEnergyTotal = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -1);
    emit solarEnergyTotalReadFinished(receivedSolarEnergyTotal);

    if (m_solarEnergyTotal != receivedSolarEnergyTotal) {
        m_solarEnergyTotal = receivedSolarEnergyTotal;
        emit solarEnergyTotalChanged(m_solarEnergyTotal);
    }
}

void SolaxModbusTcpConnection::processSolarEnergyTodayRegisterValues(const QVector<quint16> values)
{
    float receivedSolarEnergyToday = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit solarEnergyTodayReadFinished(receivedSolarEnergyToday);

    if (m_solarEnergyToday != receivedSolarEnergyToday) {
        m_solarEnergyToday = receivedSolarEnergyToday;
        emit solarEnergyTodayChanged(m_solarEnergyToday);
    }
}

void SolaxModbusTcpConnection::processPvVoltage3RegisterValues(const QVector<quint16> values)
{
    quint16 receivedPvVoltage3 = ModbusDataUtils::convertToUInt16(values);
    emit pvVoltage3ReadFinished(receivedPvVoltage3);

    if (m_pvVoltage3 != receivedPvVoltage3) {
        m_pvVoltage3 = receivedPvVoltage3;
        emit pvVoltage3Changed(m_pvVoltage3);
    }
}

void SolaxModbusTcpConnection::processPvCurrent3RegisterValues(const QVector<quint16> values)
{
    quint16 receivedPvCurrent3 = ModbusDataUtils::convertToUInt16(values);
    emit pvCurrent3ReadFinished(receivedPvCurrent3);

    if (m_pvCurrent3 != receivedPvCurrent3) {
        m_pvCurrent3 = receivedPvCurrent3;
        emit pvCurrent3Changed(m_pvCurrent3);
    }
}

void SolaxModbusTcpConnection::processPowerDc3RegisterValues(const QVector<quint16> values)
{
    quint16 receivedPowerDc3 = ModbusDataUtils::convertToUInt16(values);
    emit powerDc3ReadFinished(receivedPowerDc3);

    if (m_powerDc3 != receivedPowerDc3) {
        m_powerDc3 = receivedPowerDc3;
        emit powerDc3Changed(m_powerDc3);
    }
}

void SolaxModbusTcpConnection::processPv3VoltFaultValueRegisterValues(const QVector<quint16> values)
{
    quint16 receivedPv3VoltFaultValue = ModbusDataUtils::convertToUInt16(values);
    emit pv3VoltFaultValueReadFinished(receivedPv3VoltFaultValue);

    if (m_pv3VoltFaultValue != receivedPv3VoltFaultValue) {
        m_pv3VoltFaultValue = receivedPv3VoltFaultValue;
        emit pv3VoltFaultValueChanged(m_pv3VoltFaultValue);
    }
}

void SolaxModbusTcpConnection::processPv3VoltFaultValue2RegisterValues(const QVector<quint16> values)
{
    quint16 receivedPv3VoltFaultValue2 = ModbusDataUtils::convertToUInt16(values);
    emit pv3VoltFaultValue2ReadFinished(receivedPv3VoltFaultValue2);

    if (m_pv3VoltFaultValue2 != receivedPv3VoltFaultValue2) {
        m_pv3VoltFaultValue2 = receivedPv3VoltFaultValue2;
        emit pv3VoltFaultValue2Changed(m_pv3VoltFaultValue2);
    }
}

void SolaxModbusTcpConnection::processBatVoltageCharge2RegisterValues(const QVector<quint16> values)
{
    quint16 receivedBatVoltageCharge2 = ModbusDataUtils::convertToUInt16(values);
    emit batVoltageCharge2ReadFinished(receivedBatVoltageCharge2);

    if (m_batVoltageCharge2 != receivedBatVoltageCharge2) {
        m_batVoltageCharge2 = receivedBatVoltageCharge2;
        emit batVoltageCharge2Changed(m_batVoltageCharge2);
    }
}

void SolaxModbusTcpConnection::processBatCurrentCharge2RegisterValues(const QVector<quint16> values)
{
    quint16 receivedBatCurrentCharge2 = ModbusDataUtils::convertToUInt16(values);
    emit batCurrentCharge2ReadFinished(receivedBatCurrentCharge2);

    if (m_batCurrentCharge2 != receivedBatCurrentCharge2) {
        m_batCurrentCharge2 = receivedBatCurrentCharge2;
        emit batCurrentCharge2Changed(m_batCurrentCharge2);
    }
}

void SolaxModbusTcpConnection::processBatPowerCharge2RegisterValues(const QVector<quint16> values)
{
    qint16 receivedBatPowerCharge2 = ModbusDataUtils::convertToInt16(values);
    emit batPowerCharge2ReadFinished(receivedBatPowerCharge2);

    if (m_batPowerCharge2 != receivedBatPowerCharge2) {
        m_batPowerCharge2 = receivedBatPowerCharge2;
        emit batPowerCharge2Changed(m_batPowerCharge2);
    }
}

void SolaxModbusTcpConnection::processBms2FaultLsbRegisterValues(const QVector<quint16> values)
{
    quint16 receivedBms2FaultLsb = ModbusDataUtils::convertToUInt16(values);
    emit bms2FaultLsbReadFinished(receivedBms2FaultLsb);

    if (m_bms2FaultLsb != receivedBms2FaultLsb) {
        m_bms2FaultLsb = receivedBms2FaultLsb;
        emit bms2FaultLsbChanged(m_bms2FaultLsb);
    }
}

void SolaxModbusTcpConnection::processBms2FaulMLsbRegisterValues(const QVector<quint16> values)
{
    quint16 receivedBms2FaulMLsb = ModbusDataUtils::convertToUInt16(values);
    emit bms2FaulMLsbReadFinished(receivedBms2FaulMLsb);

    if (m_bms2FaulMLsb != receivedBms2FaulMLsb) {
        m_bms2FaulMLsb = receivedBms2FaulMLsb;
        emit bms2FaulMLsbChanged(m_bms2FaulMLsb);
    }
}

void SolaxModbusTcpConnection::processBatDataReference2RegisterValues(const QVector<quint16> values)
{
    quint16 receivedBatDataReference2 = ModbusDataUtils::convertToUInt16(values);
    emit batDataReference2ReadFinished(receivedBatDataReference2);

    if (m_batDataReference2 != receivedBatDataReference2) {
        m_batDataReference2 = receivedBatDataReference2;
        emit batDataReference2Changed(m_batDataReference2);
    }
}

void SolaxModbusTcpConnection::processBatteryCapacity2RegisterValues(const QVector<quint16> values)
{
    quint16 receivedBatteryCapacity2 = ModbusDataUtils::convertToUInt16(values);
    emit batteryCapacity2ReadFinished(receivedBatteryCapacity2);

    if (m_batteryCapacity2 != receivedBatteryCapacity2) {
        m_batteryCapacity2 = receivedBatteryCapacity2;
        emit batteryCapacity2Changed(m_batteryCapacity2);
    }
}

void SolaxModbusTcpConnection::processTotalBatteryCapacity2RegisterValues(const QVector<quint16> values)
{
    quint16 receivedTotalBatteryCapacity2 = ModbusDataUtils::convertToUInt16(values);
    emit totalBatteryCapacity2ReadFinished(receivedTotalBatteryCapacity2);

    if (m_totalBatteryCapacity2 != receivedTotalBatteryCapacity2) {
        m_totalBatteryCapacity2 = receivedTotalBatteryCapacity2;
        emit totalBatteryCapacity2Changed(m_totalBatteryCapacity2);
    }
}

void SolaxModbusTcpConnection::processEoutPowerTotalRegisterValues(const QVector<quint16> values)
{
    qint32 receivedEoutPowerTotal = ModbusDataUtils::convertToInt32(values, ModbusDataUtils::ByteOrderBigEndian);
    emit EoutPowerTotalReadFinished(receivedEoutPowerTotal);

    if (m_EoutPowerTotal != receivedEoutPowerTotal) {
        m_EoutPowerTotal = receivedEoutPowerTotal;
        emit EoutPowerTotalChanged(m_EoutPowerTotal);
    }
}

void SolaxModbusTcpConnection::processTemperatureBat2RegisterValues(const QVector<quint16> values)
{
    qint16 receivedTemperatureBat2 = ModbusDataUtils::convertToInt16(values);
    emit temperatureBat2ReadFinished(receivedTemperatureBat2);

    if (m_temperatureBat2 != receivedTemperatureBat2) {
        m_temperatureBat2 = receivedTemperatureBat2;
        emit temperatureBat2Changed(m_temperatureBat2);
    }
}

void SolaxModbusTcpConnection::handleModbusError(QModbusDevice::Error error)
{
    if (error == QModbusDevice::NoError) {
        // Reset the communication counter and we know we can reach the device
        m_communicationFailedCounter = 0;
        if (!m_communicationWorking)
            qCDebug(dcSolaxModbusTcpConnection()) << "Received a reply without any errors. The communication with the device seems to work now.";

        m_communicationWorking = true;
        evaluateReachableState();
    } else {
        m_communicationFailedCounter++;
        if (m_communicationWorking && m_communicationFailedCounter >= m_communicationFailedMax) {
            m_communicationWorking = false;
            qCWarning(dcSolaxModbusTcpConnection()) << "Received" << m_communicationFailedCounter << "errors while communicating with the RTU master. Mark as not reachable until the communication works again.";
            evaluateReachableState();
        }
    }
}

void SolaxModbusTcpConnection::testReachability()
{
    if (m_checkRechableReply)
        return;

    // Try to read the check reachability register inverterType in order to verify if the communication is working or not.
    qCDebug(dcSolaxModbusTcpConnection()) << "--> Test reachability by reading \"Inverter rated power (0xBA)\" register:" << 186 << "size:" << 1;
    m_checkRechableReply = readInverterType();
    if (!m_checkRechableReply) {
        qCDebug(dcSolaxModbusTcpConnection()) << "Error occurred verifying reachability by reading \"Inverter rated power (0xBA)\" register";
        onReachabilityCheckFailed();
        return;
    }

    if (m_checkRechableReply->isFinished()) {
        m_checkRechableReply->deleteLater(); // Broadcast reply returns immediatly
        m_checkRechableReply = nullptr;
        onReachabilityCheckFailed();
        return;
    }

    connect(m_checkRechableReply, &QModbusReply::finished, this, [this](){
        handleModbusError(m_checkRechableReply->error());
        if (m_checkRechableReply->error() != QModbusDevice::NoError)
            onReachabilityCheckFailed();

        m_checkRechableReply->deleteLater();
        m_checkRechableReply = nullptr;
    });

    connect(m_checkRechableReply, &QModbusReply::errorOccurred, this, [this] (QModbusDevice::Error error){
        qCDebug(dcSolaxModbusTcpConnection()) << "Modbus reply error occurred while verifying reachability by reading \"Inverter rated power (0xBA)\" register" << error << m_checkRechableReply->errorString();
    });
}

void SolaxModbusTcpConnection::verifyInitFinished()
{
    if (m_pendingInitReplies.isEmpty()) {
        finishInitialization(true);
    }
}

void SolaxModbusTcpConnection::finishInitialization(bool success)
{
    if (success) {
        qCDebug(dcSolaxModbusTcpConnection()) << "Initialization finished of SolaxModbusTcpConnection" << hostAddress().toString() << "finished successfully";
    } else {
        qCWarning(dcSolaxModbusTcpConnection()) << "Initialization finished of SolaxModbusTcpConnection" << hostAddress().toString() << "failed.";
    }

    // Cleanup init
    delete m_initObject;
    m_initObject = nullptr;
    m_pendingInitReplies.clear();

    emit initializationFinished(success);
}

void SolaxModbusTcpConnection::verifyUpdateFinished()
{
    if (m_pendingUpdateReplies.isEmpty()) {
        emit updateFinished();
    }
}

void SolaxModbusTcpConnection::onReachabilityCheckFailed()
{
    m_checkReachableRetriesCount++;

    if (m_checkReachableRetriesCount <= m_checkReachableRetries) {
        qCDebug(dcSolaxModbusTcpConnection()) << "Reachability test failed. Retry in on second" << m_checkReachableRetriesCount << "/" << m_checkReachableRetries;
        QTimer::singleShot(1000, this, &SolaxModbusTcpConnection::testReachability);
        return;
    }

    // The test reachability method failed, not retrying any more
    emit checkReachabilityFailed();
}

void SolaxModbusTcpConnection::evaluateReachableState()
{
    bool reachable = m_communicationWorking && connected();
    if (m_reachable == reachable)
        return;

    m_reachable = reachable;
    emit reachableChanged(m_reachable);
    m_checkReachableRetriesCount = 0;
}

QDebug operator<<(QDebug debug, SolaxModbusTcpConnection *solaxModbusTcpConnection)
{
    debug.nospace().noquote() << "SolaxModbusTcpConnection(" << solaxModbusTcpConnection->hostAddress().toString() << ":" << solaxModbusTcpConnection->port() << ")" << "\n";
    debug.nospace().noquote() << "    - Battery state of charge (0x1C): " << solaxModbusTcpConnection->batteryCapacity() << " [%]" << "\n";
    debug.nospace().noquote() << "    - BMS warning bits lsb (0x1F): " << solaxModbusTcpConnection->bmsWarningLsb() << "\n";
    debug.nospace().noquote() << "    - BMS warning bits msb (0x26): " << solaxModbusTcpConnection->bmsWarningMsb() << "\n";
    debug.nospace().noquote() << "    - Inverter fault bits (0x40): " << solaxModbusTcpConnection->inverterFaultBits() << "\n";
    debug.nospace().noquote() << "    - Meter 1 communication status (0xB8): " << solaxModbusTcpConnection->meter1CommunicationState() << "\n";
    debug.nospace().noquote() << "    - Active power limit (0x25): " << solaxModbusTcpConnection->activePowerLimit() << " [%]" << "\n";
    debug.nospace().noquote() << "    - Firmware version (0x7D): " << solaxModbusTcpConnection->firmwareVersion() << "\n";
    debug.nospace().noquote() << "    - Inverter rated power (0xBA): " << solaxModbusTcpConnection->inverterType() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Serial number (0x00): " << solaxModbusTcpConnection->serialNumber() << "\n";
    debug.nospace().noquote() << "    - Factory name (0x07): " << solaxModbusTcpConnection->factoryName() << "\n";
    debug.nospace().noquote() << "    - Module name (0x0E): " << solaxModbusTcpConnection->moduleName() << "\n";
    debug.nospace().noquote() << "    - Inverter voltage (0x00): " << solaxModbusTcpConnection->inverterVoltage() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Inverter current (0x01): " << solaxModbusTcpConnection->inverterCurrent() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Inverter power (0x02): " << solaxModbusTcpConnection->inverterPower() << " [W]" << "\n";
    debug.nospace().noquote() << "    - PV voltage 1 (0x03): " << solaxModbusTcpConnection->pvVoltage1() << " [V]" << "\n";
    debug.nospace().noquote() << "    - PV voltage 2 (0x04): " << solaxModbusTcpConnection->pvVoltage2() << " [V]" << "\n";
    debug.nospace().noquote() << "    - PV current 1 (0x05): " << solaxModbusTcpConnection->pvCurrent1() << " [A]" << "\n";
    debug.nospace().noquote() << "    - PV current 2 (0x06): " << solaxModbusTcpConnection->pvCurrent2() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Inverter frequenxy (0x07): " << solaxModbusTcpConnection->inverterFrequency() << " [Hz]" << "\n";
    debug.nospace().noquote() << "    - Radiator temperature (0x08): " << solaxModbusTcpConnection->temperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - Run mode (0x09): " << solaxModbusTcpConnection->runMode() << "\n";
    debug.nospace().noquote() << "    - Power DC 1 (0x0A): " << solaxModbusTcpConnection->powerDc1() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Power DC 2 (0x0B): " << solaxModbusTcpConnection->powerDc2() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Battery voltage charge 1 (0x14): " << solaxModbusTcpConnection->batVoltageCharge1() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Battery current charge 1 (0x15): " << solaxModbusTcpConnection->batCurrentCharge1() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Battery power charge1 (0x16): " << solaxModbusTcpConnection->batPowerCharge1() << " [W]" << "\n";
    debug.nospace().noquote() << "    - BMS connected state (0x17): " << solaxModbusTcpConnection->bmsConnectState() << "\n";
    debug.nospace().noquote() << "    - Battery temperature: " << solaxModbusTcpConnection->temperatureBat() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - Power to grid (0x46). Positive means exported power, negative means consumed power.: " << solaxModbusTcpConnection->feedinPower() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Exported energy, total (0x48): " << solaxModbusTcpConnection->feedinEnergyTotal() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Consumed energy, total (0x4A): " << solaxModbusTcpConnection->consumEnergyTotal() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Phase R voltage (0x6A): " << solaxModbusTcpConnection->gridVoltageR() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Phase R current (0x6B): " << solaxModbusTcpConnection->gridCurrentR() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Phase R power (0x6C): " << solaxModbusTcpConnection->gridPowerR() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Phase R frequency (0x6D): " << solaxModbusTcpConnection->gridFrequencyR() << " [Hz]" << "\n";
    debug.nospace().noquote() << "    - Phase S voltage (0x6E): " << solaxModbusTcpConnection->gridVoltageS() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Phase S current (0x6F): " << solaxModbusTcpConnection->gridCurrentS() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Phase S power (0x70): " << solaxModbusTcpConnection->gridPowerS() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Phase S frequency (0x71): " << solaxModbusTcpConnection->gridFrequencyS() << " [Hz]" << "\n";
    debug.nospace().noquote() << "    - Phase T voltage (0x72): " << solaxModbusTcpConnection->gridVoltageT() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Phase T current (0x73): " << solaxModbusTcpConnection->gridCurrentT() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Phase T power (0x74): " << solaxModbusTcpConnection->gridPowerT() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Phase T frequency (0x75): " << solaxModbusTcpConnection->gridFrequencyT() << " [Hz]" << "\n";
    debug.nospace().noquote() << "    - Solar energy produced total (0x94): " << solaxModbusTcpConnection->solarEnergyTotal() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Solar energy produced today (0x96): " << solaxModbusTcpConnection->solarEnergyToday() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - PV voltage 3 (0x0122): " << solaxModbusTcpConnection->pvVoltage3() << " [V]" << "\n";
    debug.nospace().noquote() << "    - PV current 3 (0x0123): " << solaxModbusTcpConnection->pvCurrent3() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Power DC 3 (0x0124): " << solaxModbusTcpConnection->powerDc3() << " [W]" << "\n";
    debug.nospace().noquote() << "    - wPv3VoltFaultValue (0x0125): " << solaxModbusTcpConnection->pv3VoltFaultValue() << "\n";
    debug.nospace().noquote() << "    - wPv3VoltFaultValue2 (0x0126): " << solaxModbusTcpConnection->pv3VoltFaultValue2() << "\n";
    debug.nospace().noquote() << "    - Battery voltage charge 3 (0x0127): " << solaxModbusTcpConnection->batVoltageCharge2() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Battery current charge 3 (0x0128): " << solaxModbusTcpConnection->batCurrentCharge2() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Battery power charge 1 (0x0129): " << solaxModbusTcpConnection->batPowerCharge2() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Battery Fault Message LSB (0x012A): " << solaxModbusTcpConnection->bms2FaultLsb() << "\n";
    debug.nospace().noquote() << "    - Battery Fault Message MSB (0x012B): " << solaxModbusTcpConnection->bms2FaulMLsb() << "\n";
    debug.nospace().noquote() << "    - Battery Data Reference (0x012C): " << solaxModbusTcpConnection->batDataReference2() << "\n";
    debug.nospace().noquote() << "    - Battery2 state of charge (0x012D): " << solaxModbusTcpConnection->batteryCapacity2() << " [%]" << "\n";
    debug.nospace().noquote() << "    - Battery2 state of charge (0x012E): " << solaxModbusTcpConnection->totalBatteryCapacity2() << " [%]" << "\n";
    debug.nospace().noquote() << "    - Inv Total AC Power (0x012F): " << solaxModbusTcpConnection->EoutPowerTotal() << "\n";
    debug.nospace().noquote() << "    - Battery temperature 2 (0x0131): " << solaxModbusTcpConnection->temperatureBat2() << " [°C]" << "\n";
    return debug.quote().space();
}

