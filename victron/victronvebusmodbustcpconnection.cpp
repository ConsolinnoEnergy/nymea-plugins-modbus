/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Copyright 2013 - 2025, nymea GmbH
* Contact: contact@nymea.io
*
* This fileDescriptor is part of nymea.
* This project including source code and documentation is protected by
* copyright law, and remains the property of nymea GmbH. All rights, including
* reproduction, publication, editing and translation, are reserved. The use of
* this project is subject to the terms of a license agreement to be concluded
* with nymea GmbH in accordance with the terms of use of nymea GmbH, available
* under https://nymea.io/license
*
* GNU Lesser General Public License Usage
* Alternatively, this project may be redistributed and/or modified under the
* terms of the GNU Lesser General Public License as published by the Free
* Software Foundation; version 3. This project is distributed in the hope that
* it will be useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this project. If not, see <https://www.gnu.org/licenses/>.
*
* For any further details and any questions please contact us under
* contact@nymea.io or see our FAQ/Licensing Information on
* https://nymea.io/license/faq
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WARNING
*
* This file has been autogenerated. Any changes in this file may be overwritten.
* If you want to change something, update the register json or the tool.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


#include "victronvebusmodbustcpconnection.h"
#include <loggingcategories.h>
#include <math.h>
#include <QTimer>

NYMEA_LOGGING_CATEGORY(dcVictronVebusModbusTcpConnection, "VictronVebusModbusTcpConnection")

VictronVebusModbusTcpConnection::VictronVebusModbusTcpConnection(const QHostAddress &hostAddress, uint port, quint16 slaveId, QObject *parent) :
    ModbusTCPMaster(hostAddress, port, parent),
    m_slaveId(slaveId)
{
    connect(this, &ModbusTCPMaster::connectionStateChanged, this, [this](bool status){
        if (status) {
           qCDebug(dcVictronVebusModbusTcpConnection()) << "Modbus TCP connection" << m_hostAddress.toString() << "connected. Start testing if the connection is reachable...";
            // Cleanup before starting to initialize
            m_pendingInitReplies.clear();
            m_pendingUpdateReplies.clear();
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
            testReachability();
        } else {
            qCWarning(dcVictronVebusModbusTcpConnection()) << "Modbus TCP connection diconnected from" << m_hostAddress.toString() << ". The connection is not reachable any more.";
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
        }

        evaluateReachableState();
    });
}

bool VictronVebusModbusTcpConnection::reachable() const
{
    return m_reachable;
}

uint VictronVebusModbusTcpConnection::checkReachableRetries() const
{
    return m_checkReachableRetries;
}

void VictronVebusModbusTcpConnection::setCheckReachableRetries(uint checkReachableRetries)
{
    if (m_checkReachableRetries == checkReachableRetries)
        return;

    m_checkReachableRetries = checkReachableRetries;
    emit checkReachableRetriesChanged(m_checkReachableRetries);
}

ModbusDataUtils::ByteOrder VictronVebusModbusTcpConnection::endianness() const
{
    return m_endianness;
}

void VictronVebusModbusTcpConnection::setEndianness(ModbusDataUtils::ByteOrder endianness)
{
    if (m_endianness == endianness)
        return;

    m_endianness = endianness;
    emit endiannessChanged(m_endianness);
}

float VictronVebusModbusTcpConnection::inverterPowerInputPhaseA() const
{
    return m_inverterPowerInputPhaseA;
}

float VictronVebusModbusTcpConnection::inverterPowerInputPhaseB() const
{
    return m_inverterPowerInputPhaseB;
}

float VictronVebusModbusTcpConnection::inverterPowerInputPhaseC() const
{
    return m_inverterPowerInputPhaseC;
}

QVector<quint16> VictronVebusModbusTcpConnection::dummy1() const
{
    return m_dummy1;
}

float VictronVebusModbusTcpConnection::inverterOutputFrequency() const
{
    return m_inverterOutputFrequency;
}

QVector<quint16> VictronVebusModbusTcpConnection::dummy2() const
{
    return m_dummy2;
}

float VictronVebusModbusTcpConnection::inverterPowerOutputPhaseA() const
{
    return m_inverterPowerOutputPhaseA;
}

float VictronVebusModbusTcpConnection::inverterPowerOutputPhaseB() const
{
    return m_inverterPowerOutputPhaseB;
}

float VictronVebusModbusTcpConnection::inverterPowerOutputPhaseC() const
{
    return m_inverterPowerOutputPhaseC;
}

qint16 VictronVebusModbusTcpConnection::powerSetpointPhaseA() const
{
    return m_powerSetpointPhaseA;
}

QModbusReply *VictronVebusModbusTcpConnection::setPowerSetpointPhaseA(qint16 powerSetpointPhaseA)
{
    QVector<quint16> values = ModbusDataUtils::convertFromInt16(powerSetpointPhaseA);
    qCDebug(dcVictronVebusModbusTcpConnection()) << "--> Write \"ESS power setpoint phase 1\" register:" << 37 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 37, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 VictronVebusModbusTcpConnection::disableCharge() const
{
    return m_disableCharge;
}

QModbusReply *VictronVebusModbusTcpConnection::setDisableCharge(quint16 disableCharge)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(disableCharge);
    qCDebug(dcVictronVebusModbusTcpConnection()) << "--> Write \"disable charge flag\" register:" << 38 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 38, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 VictronVebusModbusTcpConnection::disableFeedIn() const
{
    return m_disableFeedIn;
}

QModbusReply *VictronVebusModbusTcpConnection::setDisableFeedIn(quint16 disableFeedIn)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(disableFeedIn);
    qCDebug(dcVictronVebusModbusTcpConnection()) << "--> Write \"disable feed in flag\" register:" << 39 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 39, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

qint16 VictronVebusModbusTcpConnection::powerSetpointPhaseB() const
{
    return m_powerSetpointPhaseB;
}

QModbusReply *VictronVebusModbusTcpConnection::setPowerSetpointPhaseB(qint16 powerSetpointPhaseB)
{
    QVector<quint16> values = ModbusDataUtils::convertFromInt16(powerSetpointPhaseB);
    qCDebug(dcVictronVebusModbusTcpConnection()) << "--> Write \"ESS power setpoint phase 2\" register:" << 40 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 40, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

qint16 VictronVebusModbusTcpConnection::powerSetpointPhaseC() const
{
    return m_powerSetpointPhaseC;
}

QModbusReply *VictronVebusModbusTcpConnection::setPowerSetpointPhaseC(qint16 powerSetpointPhaseC)
{
    QVector<quint16> values = ModbusDataUtils::convertFromInt16(powerSetpointPhaseC);
    qCDebug(dcVictronVebusModbusTcpConnection()) << "--> Write \"ESS power setpoint phase 3\" register:" << 41 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 41, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

bool VictronVebusModbusTcpConnection::initialize()
{
    if (!m_reachable) {
        qCWarning(dcVictronVebusModbusTcpConnection()) << "Tried to initialize but the device is not to be reachable.";
        return false;
    }
    // No init registers defined. Nothing to be done and we are finished.
    emit initializationFinished(true);
    return true;
}

bool VictronVebusModbusTcpConnection::update()
{
    if (!connected())
        return false;

    if (!m_pendingUpdateReplies.isEmpty()) {
        qCDebug(dcVictronVebusModbusTcpConnection()) << "Tried to update but there are still some update replies pending. Waiting for them to be finished...";
        return true;
    }

    QModbusReply *reply = nullptr;

    // Read vebuspower
    reply = readBlockVebuspower();
    qCDebug(dcVictronVebusModbusTcpConnection()) << "--> Read block \"vebuspower\" registers from:" << 12 << "size:" << 14;
    if (!reply) {
        qCWarning(dcVictronVebusModbusTcpConnection()) << "Error occurred while reading block \"vebuspower\" registers";
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcVictronVebusModbusTcpConnection()) << "<-- Response from reading block \"vebuspower\" register" << 12 << "size:" << 14 << blockValues;
        processInverterPowerInputPhaseARegisterValues(blockValues.mid(0, 1));
        processInverterPowerInputPhaseBRegisterValues(blockValues.mid(1, 1));
        processInverterPowerInputPhaseCRegisterValues(blockValues.mid(2, 1));
        processDummy1RegisterValues(blockValues.mid(3, 6));
        processInverterOutputFrequencyRegisterValues(blockValues.mid(9, 1));
        processDummy2RegisterValues(blockValues.mid(10, 1));
        processInverterPowerOutputPhaseARegisterValues(blockValues.mid(11, 1));
        processInverterPowerOutputPhaseBRegisterValues(blockValues.mid(12, 1));
        processInverterPowerOutputPhaseCRegisterValues(blockValues.mid(13, 1));
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcVictronVebusModbusTcpConnection()) << "Modbus reply error occurred while updating block \"vebuspower\" registers" << error << reply->errorString();
    });


    // Read vebussetp
    reply = readBlockVebussetp();
    qCDebug(dcVictronVebusModbusTcpConnection()) << "--> Read block \"vebussetp\" registers from:" << 37 << "size:" << 5;
    if (!reply) {
        qCWarning(dcVictronVebusModbusTcpConnection()) << "Error occurred while reading block \"vebussetp\" registers";
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcVictronVebusModbusTcpConnection()) << "<-- Response from reading block \"vebussetp\" register" << 37 << "size:" << 5 << blockValues;
        processPowerSetpointPhaseARegisterValues(blockValues.mid(0, 1));
        processDisableChargeRegisterValues(blockValues.mid(1, 1));
        processDisableFeedInRegisterValues(blockValues.mid(2, 1));
        processPowerSetpointPhaseBRegisterValues(blockValues.mid(3, 1));
        processPowerSetpointPhaseCRegisterValues(blockValues.mid(4, 1));
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcVictronVebusModbusTcpConnection()) << "Modbus reply error occurred while updating block \"vebussetp\" registers" << error << reply->errorString();
    });

    return true;
}

void VictronVebusModbusTcpConnection::updateVebuspowerBlock()
{
    // Update register block "vebuspower"
    qCDebug(dcVictronVebusModbusTcpConnection()) << "--> Read block \"vebuspower\" registers from:" << 12 << "size:" << 14;
    QModbusReply *reply = readBlockVebuspower();
    if (!reply) {
        qCWarning(dcVictronVebusModbusTcpConnection()) << "Error occurred while reading block \"vebuspower\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcVictronVebusModbusTcpConnection()) << "<-- Response from reading block \"vebuspower\" register" << 12 << "size:" << 14 << blockValues;
            processInverterPowerInputPhaseARegisterValues(blockValues.mid(0, 1));
            processInverterPowerInputPhaseBRegisterValues(blockValues.mid(1, 1));
            processInverterPowerInputPhaseCRegisterValues(blockValues.mid(2, 1));
            processDummy1RegisterValues(blockValues.mid(3, 6));
            processInverterOutputFrequencyRegisterValues(blockValues.mid(9, 1));
            processDummy2RegisterValues(blockValues.mid(10, 1));
            processInverterPowerOutputPhaseARegisterValues(blockValues.mid(11, 1));
            processInverterPowerOutputPhaseBRegisterValues(blockValues.mid(12, 1));
            processInverterPowerOutputPhaseCRegisterValues(blockValues.mid(13, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcVictronVebusModbusTcpConnection()) << "Modbus reply error occurred while updating block \"vebuspower\" registers" << error << reply->errorString();
    });
}

void VictronVebusModbusTcpConnection::updateVebussetpBlock()
{
    // Update register block "vebussetp"
    qCDebug(dcVictronVebusModbusTcpConnection()) << "--> Read block \"vebussetp\" registers from:" << 37 << "size:" << 5;
    QModbusReply *reply = readBlockVebussetp();
    if (!reply) {
        qCWarning(dcVictronVebusModbusTcpConnection()) << "Error occurred while reading block \"vebussetp\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcVictronVebusModbusTcpConnection()) << "<-- Response from reading block \"vebussetp\" register" << 37 << "size:" << 5 << blockValues;
            processPowerSetpointPhaseARegisterValues(blockValues.mid(0, 1));
            processDisableChargeRegisterValues(blockValues.mid(1, 1));
            processDisableFeedInRegisterValues(blockValues.mid(2, 1));
            processPowerSetpointPhaseBRegisterValues(blockValues.mid(3, 1));
            processPowerSetpointPhaseCRegisterValues(blockValues.mid(4, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcVictronVebusModbusTcpConnection()) << "Modbus reply error occurred while updating block \"vebussetp\" registers" << error << reply->errorString();
    });
}

QModbusReply *VictronVebusModbusTcpConnection::readInverterPowerInputPhaseA()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 12, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *VictronVebusModbusTcpConnection::readInverterPowerInputPhaseB()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 13, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *VictronVebusModbusTcpConnection::readInverterPowerInputPhaseC()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 14, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *VictronVebusModbusTcpConnection::readDummy1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 15, 6);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *VictronVebusModbusTcpConnection::readInverterOutputFrequency()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 21, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *VictronVebusModbusTcpConnection::readDummy2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 22, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *VictronVebusModbusTcpConnection::readInverterPowerOutputPhaseA()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 23, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *VictronVebusModbusTcpConnection::readInverterPowerOutputPhaseB()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 24, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *VictronVebusModbusTcpConnection::readInverterPowerOutputPhaseC()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 25, 1);
    return sendReadRequest(request, m_slaveId);
}

// MultipleWrite FC16 for vebus register 37 until 41
void VictronVebusModbusTcpConnection::writeSetpoints(int16_t powerSetPhase)
{
    QModbusReply *reply = nullptr;    
    
    quint16 startAddress = 37, numberOfRegisters = 5;
    quint8 payloadInBytes = 10; 

    quint16 setPointRaw = static_cast<quint16>(powerSetPhase < 0 ? powerSetPhase + 65536 : powerSetPhase);
    quint16 disableCharge = 0;
    quint16 disableFeedback = 0;

    QModbusRequest request(QModbusRequest::WriteMultipleRegisters, startAddress, numberOfRegisters,
    payloadInBytes, setPointRaw, disableCharge, disableFeedback, setPointRaw, setPointRaw);

    qCDebug(dcVictronVebusModbusTcpConnection()) << "QModbusRequest" << request;

    //QModbusRequest request_test(QModbusRequest::WriteMultipleRegisters, QByteArray::fromHex("002500050A00000000000000000000")); // manual request for testing
    reply = m_modbusTcpClient->sendRawRequest(request, m_slaveId);

    if (!reply) {
        qCWarning(dcVictronVebusModbusTcpConnection()) 
            << "Write powerDemand failed because the reply could not be created.";
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        if (reply->error() != QModbusDevice::NoError) {
            qCWarning(dcVictronVebusModbusTcpConnection())
                    << "Write setpoints finished with error" << reply->errorString();
            return;
        }

        qCDebug(dcVictronVebusModbusTcpConnection()) << "Write setpoints finished successfully";
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
            if (reply->error() == QModbusDevice::ProtocolError) {
                QModbusResponse response = reply->rawResult();
                if (response.isException()) {
                    qCDebug(dcVictronVebusModbusTcpConnection()) << "Modbus reply error occurred while writing setpoints" << hostAddress().toString() << response.exceptionCode();
                }
            } else {
                qCWarning(dcVictronVebusModbusTcpConnection()) << "Modbus reply error occurred while writing setpoints" << hostAddress().toString() << error << reply->errorString();
            }
        });   
}

QModbusReply *VictronVebusModbusTcpConnection::readPowerSetpointPhaseA()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 37, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *VictronVebusModbusTcpConnection::readDisableCharge()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 38, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *VictronVebusModbusTcpConnection::readDisableFeedIn()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 39, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *VictronVebusModbusTcpConnection::readPowerSetpointPhaseB()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 40, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *VictronVebusModbusTcpConnection::readPowerSetpointPhaseC()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 41, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *VictronVebusModbusTcpConnection::readBlockVebuspower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 12, 14);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *VictronVebusModbusTcpConnection::readBlockVebussetp()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 37, 5);
    return sendReadRequest(request, m_slaveId);
}

void VictronVebusModbusTcpConnection::processInverterPowerInputPhaseARegisterValues(const QVector<quint16> values)
{
    float receivedInverterPowerInputPhaseA = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, 1);
    emit inverterPowerInputPhaseAReadFinished(receivedInverterPowerInputPhaseA);

    if (m_inverterPowerInputPhaseA != receivedInverterPowerInputPhaseA) {
        m_inverterPowerInputPhaseA = receivedInverterPowerInputPhaseA;
        emit inverterPowerInputPhaseAChanged(m_inverterPowerInputPhaseA);
    }
}

void VictronVebusModbusTcpConnection::processInverterPowerInputPhaseBRegisterValues(const QVector<quint16> values)
{
    float receivedInverterPowerInputPhaseB = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, 1);
    emit inverterPowerInputPhaseBReadFinished(receivedInverterPowerInputPhaseB);

    if (m_inverterPowerInputPhaseB != receivedInverterPowerInputPhaseB) {
        m_inverterPowerInputPhaseB = receivedInverterPowerInputPhaseB;
        emit inverterPowerInputPhaseBChanged(m_inverterPowerInputPhaseB);
    }
}

void VictronVebusModbusTcpConnection::processInverterPowerInputPhaseCRegisterValues(const QVector<quint16> values)
{
    float receivedInverterPowerInputPhaseC = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, 1);
    emit inverterPowerInputPhaseCReadFinished(receivedInverterPowerInputPhaseC);

    if (m_inverterPowerInputPhaseC != receivedInverterPowerInputPhaseC) {
        m_inverterPowerInputPhaseC = receivedInverterPowerInputPhaseC;
        emit inverterPowerInputPhaseCChanged(m_inverterPowerInputPhaseC);
    }
}

void VictronVebusModbusTcpConnection::processDummy1RegisterValues(const QVector<quint16> values)
{
    QVector<quint16> receivedDummy1 = values;
    emit dummy1ReadFinished(receivedDummy1);

    if (m_dummy1 != receivedDummy1) {
        m_dummy1 = receivedDummy1;
        emit dummy1Changed(m_dummy1);
    }
}

void VictronVebusModbusTcpConnection::processInverterOutputFrequencyRegisterValues(const QVector<quint16> values)
{
    float receivedInverterOutputFrequency = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, -2);
    emit inverterOutputFrequencyReadFinished(receivedInverterOutputFrequency);

    if (m_inverterOutputFrequency != receivedInverterOutputFrequency) {
        m_inverterOutputFrequency = receivedInverterOutputFrequency;
        emit inverterOutputFrequencyChanged(m_inverterOutputFrequency);
    }
}

void VictronVebusModbusTcpConnection::processDummy2RegisterValues(const QVector<quint16> values)
{
    QVector<quint16> receivedDummy2 = values;
    emit dummy2ReadFinished(receivedDummy2);

    if (m_dummy2 != receivedDummy2) {
        m_dummy2 = receivedDummy2;
        emit dummy2Changed(m_dummy2);
    }
}

void VictronVebusModbusTcpConnection::processInverterPowerOutputPhaseARegisterValues(const QVector<quint16> values)
{
    float receivedInverterPowerOutputPhaseA = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, 1);
    emit inverterPowerOutputPhaseAReadFinished(receivedInverterPowerOutputPhaseA);

    if (m_inverterPowerOutputPhaseA != receivedInverterPowerOutputPhaseA) {
        m_inverterPowerOutputPhaseA = receivedInverterPowerOutputPhaseA;
        emit inverterPowerOutputPhaseAChanged(m_inverterPowerOutputPhaseA);
    }
}

void VictronVebusModbusTcpConnection::processInverterPowerOutputPhaseBRegisterValues(const QVector<quint16> values)
{
    float receivedInverterPowerOutputPhaseB = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, 1);
    emit inverterPowerOutputPhaseBReadFinished(receivedInverterPowerOutputPhaseB);

    if (m_inverterPowerOutputPhaseB != receivedInverterPowerOutputPhaseB) {
        m_inverterPowerOutputPhaseB = receivedInverterPowerOutputPhaseB;
        emit inverterPowerOutputPhaseBChanged(m_inverterPowerOutputPhaseB);
    }
}

void VictronVebusModbusTcpConnection::processInverterPowerOutputPhaseCRegisterValues(const QVector<quint16> values)
{
    float receivedInverterPowerOutputPhaseC = ModbusDataUtils::convertToInt16(values) * 1.0 * pow(10, 1);
    emit inverterPowerOutputPhaseCReadFinished(receivedInverterPowerOutputPhaseC);

    if (m_inverterPowerOutputPhaseC != receivedInverterPowerOutputPhaseC) {
        m_inverterPowerOutputPhaseC = receivedInverterPowerOutputPhaseC;
        emit inverterPowerOutputPhaseCChanged(m_inverterPowerOutputPhaseC);
    }
}

void VictronVebusModbusTcpConnection::processPowerSetpointPhaseARegisterValues(const QVector<quint16> values)
{
    qint16 receivedPowerSetpointPhaseA = ModbusDataUtils::convertToInt16(values);
    emit powerSetpointPhaseAReadFinished(receivedPowerSetpointPhaseA);

    if (m_powerSetpointPhaseA != receivedPowerSetpointPhaseA) {
        m_powerSetpointPhaseA = receivedPowerSetpointPhaseA;
        emit powerSetpointPhaseAChanged(m_powerSetpointPhaseA);
    }
}

void VictronVebusModbusTcpConnection::processDisableChargeRegisterValues(const QVector<quint16> values)
{
    quint16 receivedDisableCharge = ModbusDataUtils::convertToUInt16(values);
    emit disableChargeReadFinished(receivedDisableCharge);

    if (m_disableCharge != receivedDisableCharge) {
        m_disableCharge = receivedDisableCharge;
        emit disableChargeChanged(m_disableCharge);
    }
}

void VictronVebusModbusTcpConnection::processDisableFeedInRegisterValues(const QVector<quint16> values)
{
    quint16 receivedDisableFeedIn = ModbusDataUtils::convertToUInt16(values);
    emit disableFeedInReadFinished(receivedDisableFeedIn);

    if (m_disableFeedIn != receivedDisableFeedIn) {
        m_disableFeedIn = receivedDisableFeedIn;
        emit disableFeedInChanged(m_disableFeedIn);
    }
}

void VictronVebusModbusTcpConnection::processPowerSetpointPhaseBRegisterValues(const QVector<quint16> values)
{
    qint16 receivedPowerSetpointPhaseB = ModbusDataUtils::convertToInt16(values);
    emit powerSetpointPhaseBReadFinished(receivedPowerSetpointPhaseB);

    if (m_powerSetpointPhaseB != receivedPowerSetpointPhaseB) {
        m_powerSetpointPhaseB = receivedPowerSetpointPhaseB;
        emit powerSetpointPhaseBChanged(m_powerSetpointPhaseB);
    }
}

void VictronVebusModbusTcpConnection::processPowerSetpointPhaseCRegisterValues(const QVector<quint16> values)
{
    qint16 receivedPowerSetpointPhaseC = ModbusDataUtils::convertToInt16(values);
    emit powerSetpointPhaseCReadFinished(receivedPowerSetpointPhaseC);

    if (m_powerSetpointPhaseC != receivedPowerSetpointPhaseC) {
        m_powerSetpointPhaseC = receivedPowerSetpointPhaseC;
        emit powerSetpointPhaseCChanged(m_powerSetpointPhaseC);
    }
}

void VictronVebusModbusTcpConnection::handleModbusError(QModbusDevice::Error error)
{
    if (error == QModbusDevice::NoError) {
        // Reset the communication counter and we know we can reach the device
        m_communicationFailedCounter = 0;
        if (!m_communicationWorking)
            qCDebug(dcVictronVebusModbusTcpConnection()) << "Received a reply without any errors. The communication with the device seems to work now.";

        m_communicationWorking = true;
        evaluateReachableState();
    } else {
        m_communicationFailedCounter++;
        if (m_communicationWorking && m_communicationFailedCounter >= m_communicationFailedMax) {
            m_communicationWorking = false;
            qCWarning(dcVictronVebusModbusTcpConnection()) << "Received" << m_communicationFailedCounter << "errors while communicating with the RTU master. Mark as not reachable until the communication works again.";
            evaluateReachableState();
        }
    }
}

void VictronVebusModbusTcpConnection::testReachability()
{
    if (m_checkRechableReply)
        return;

    // Try to read the check reachability register powerSetpointPhaseA in order to verify if the communication is working or not.
    qCDebug(dcVictronVebusModbusTcpConnection()) << "--> Test reachability by reading \"ESS power setpoint phase 1\" register:" << 37 << "size:" << 1;
    m_checkRechableReply = readPowerSetpointPhaseA();
    if (!m_checkRechableReply) {
        qCDebug(dcVictronVebusModbusTcpConnection()) << "Error occurred verifying reachability by reading \"ESS power setpoint phase 1\" register";
        onReachabilityCheckFailed();
        return;
    }

    if (m_checkRechableReply->isFinished()) {
        m_checkRechableReply->deleteLater(); // Broadcast reply returns immediatly
        m_checkRechableReply = nullptr;
        onReachabilityCheckFailed();
        return;
    }

    connect(m_checkRechableReply, &QModbusReply::finished, this, [this](){
        handleModbusError(m_checkRechableReply->error());
        if (m_checkRechableReply->error() != QModbusDevice::NoError)
            onReachabilityCheckFailed();

        m_checkRechableReply->deleteLater();
        m_checkRechableReply = nullptr;
    });

    connect(m_checkRechableReply, &QModbusReply::errorOccurred, this, [this] (QModbusDevice::Error error){
        qCDebug(dcVictronVebusModbusTcpConnection()) << "Modbus reply error occurred while verifying reachability by reading \"ESS power setpoint phase 1\" register" << error << m_checkRechableReply->errorString();
    });
}

void VictronVebusModbusTcpConnection::verifyInitFinished()
{
    if (m_pendingInitReplies.isEmpty()) {
        finishInitialization(true);
    }
}

void VictronVebusModbusTcpConnection::finishInitialization(bool success)
{
    if (success) {
        qCDebug(dcVictronVebusModbusTcpConnection()) << "Initialization finished of VictronVebusModbusTcpConnection" << hostAddress().toString() << "finished successfully";
    } else {
        qCWarning(dcVictronVebusModbusTcpConnection()) << "Initialization finished of VictronVebusModbusTcpConnection" << hostAddress().toString() << "failed.";
    }

    // Cleanup init
    delete m_initObject;
    m_initObject = nullptr;
    m_pendingInitReplies.clear();

    emit initializationFinished(success);
}

void VictronVebusModbusTcpConnection::verifyUpdateFinished()
{
    if (m_pendingUpdateReplies.isEmpty()) {
        emit updateFinished();
    }
}

void VictronVebusModbusTcpConnection::onReachabilityCheckFailed()
{
    m_checkReachableRetriesCount++;

    if (m_checkReachableRetriesCount <= m_checkReachableRetries) {
        qCDebug(dcVictronVebusModbusTcpConnection()) << "Reachability test failed. Retry in on second" << m_checkReachableRetriesCount << "/" << m_checkReachableRetries;
        QTimer::singleShot(1000, this, &VictronVebusModbusTcpConnection::testReachability);
        return;
    }

    // The test reachability method failed, not retrying any more
    emit checkReachabilityFailed();
}

void VictronVebusModbusTcpConnection::evaluateReachableState()
{
    bool reachable = m_communicationWorking && connected();
    if (m_reachable == reachable)
        return;

    m_reachable = reachable;
    emit reachableChanged(m_reachable);
    m_checkReachableRetriesCount = 0;
}

QDebug operator<<(QDebug debug, VictronVebusModbusTcpConnection *victronVebusModbusTcpConnection)
{
    debug.nospace().noquote() << "VictronVebusModbusTcpConnection(" << victronVebusModbusTcpConnection->hostAddress().toString() << ":" << victronVebusModbusTcpConnection->port() << ")" << "\n";
    debug.nospace().noquote() << "    - Inverter AC input power phase A: " << victronVebusModbusTcpConnection->inverterPowerInputPhaseA() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Inverter AC input power phase B: " << victronVebusModbusTcpConnection->inverterPowerInputPhaseB() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Inverter AC input power phase C: " << victronVebusModbusTcpConnection->inverterPowerInputPhaseC() << " [W]" << "\n";
    debug.nospace().noquote() << "    - none: " << victronVebusModbusTcpConnection->dummy1() << "\n";
    debug.nospace().noquote() << "    - Inverter output frequency: " << victronVebusModbusTcpConnection->inverterOutputFrequency() << " [Hz]" << "\n";
    debug.nospace().noquote() << "    - none: " << victronVebusModbusTcpConnection->dummy2() << "\n";
    debug.nospace().noquote() << "    - Inverter AC output power phase A: " << victronVebusModbusTcpConnection->inverterPowerOutputPhaseA() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Inverter AC output power phase B: " << victronVebusModbusTcpConnection->inverterPowerOutputPhaseB() << " [W]" << "\n";
    debug.nospace().noquote() << "    - Inverter AC input power phase C: " << victronVebusModbusTcpConnection->inverterPowerOutputPhaseC() << " [W]" << "\n";
    debug.nospace().noquote() << "    - ESS power setpoint phase 1: " << victronVebusModbusTcpConnection->powerSetpointPhaseA() << " [W]" << "\n";
    debug.nospace().noquote() << "    - disable charge flag: " << victronVebusModbusTcpConnection->disableCharge() << " [-]" << "\n";
    debug.nospace().noquote() << "    - disable feed in flag: " << victronVebusModbusTcpConnection->disableFeedIn() << " [-]" << "\n";
    debug.nospace().noquote() << "    - ESS power setpoint phase 2: " << victronVebusModbusTcpConnection->powerSetpointPhaseB() << " [W]" << "\n";
    debug.nospace().noquote() << "    - ESS power setpoint phase 3: " << victronVebusModbusTcpConnection->powerSetpointPhaseC() << " [W]" << "\n";
    return debug.quote().space();
}

