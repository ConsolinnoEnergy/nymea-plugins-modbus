/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Copyright 2013 - 2024, nymea GmbH
* Contact: contact@nymea.io
*
* This fileDescriptor is part of nymea.
* This project including source code and documentation is protected by
* copyright law, and remains the property of nymea GmbH. All rights, including
* reproduction, publication, editing and translation, are reserved. The use of
* this project is subject to the terms of a license agreement to be concluded
* with nymea GmbH in accordance with the terms of use of nymea GmbH, available
* under https://nymea.io/license
*
* GNU Lesser General Public License Usage
* Alternatively, this project may be redistributed and/or modified under the
* terms of the GNU Lesser General Public License as published by the Free
* Software Foundation; version 3. This project is distributed in the hope that
* it will be useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this project. If not, see <https://www.gnu.org/licenses/>.
*
* For any further details and any questions please contact us under
* contact@nymea.io or see our FAQ/Licensing Information on
* https://nymea.io/license/faq
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WARNING
*
* This file has been autogenerated. Any changes in this file may be overwritten.
* If you want to change something, update the register json or the tool.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


#include "alfenwallboxmodbustcpconnection.h"
#include <loggingcategories.h>
#include <math.h>
#include <QTimer>

NYMEA_LOGGING_CATEGORY(dcAlfenWallboxModbusTcpConnection, "AlfenWallboxModbusTcpConnection")

AlfenWallboxModbusTcpConnection::AlfenWallboxModbusTcpConnection(const QHostAddress &hostAddress, uint port, quint16 slaveId, QObject *parent) :
    ModbusTcpMaster(hostAddress, port, parent),
    m_slaveId(slaveId)
{
    connect(this, &ModbusTcpMaster::connectionStateChanged, this, [this](bool status){
        if (status) {
           qCDebug(dcAlfenWallboxModbusTcpConnection()) << "Modbus TCP connection" << m_hostAddress.toString() << "connected. Start testing if the connection is reachable...";
            // Cleanup before starting to initialize
            m_pendingInitReplies.clear();
            m_pendingUpdateReplies.clear();
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
            testReachability();
        } else {
            qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus TCP connection diconnected from" << m_hostAddress.toString() << ". The connection is not reachable any more.";
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
        }

        evaluateReachableState();
    });
}

bool AlfenWallboxModbusTcpConnection::reachable() const
{
    return m_reachable;
}

uint AlfenWallboxModbusTcpConnection::checkReachableRetries() const
{
    return m_checkReachableRetries;
}

void AlfenWallboxModbusTcpConnection::setCheckReachableRetries(uint checkReachableRetries)
{
    if (m_checkReachableRetries == checkReachableRetries)
        return;

    m_checkReachableRetries = checkReachableRetries;
    emit checkReachableRetriesChanged(m_checkReachableRetries);
}

ModbusDataUtils::ByteOrder AlfenWallboxModbusTcpConnection::endianness() const
{
    return m_endianness;
}

void AlfenWallboxModbusTcpConnection::setEndianness(ModbusDataUtils::ByteOrder endianness)
{
    if (m_endianness == endianness)
        return;

    m_endianness = endianness;
    emit endiannessChanged(m_endianness);
}

float AlfenWallboxModbusTcpConnection::setpointMaxCurrent() const
{
    return m_setpointMaxCurrent;
}

QModbusReply *AlfenWallboxModbusTcpConnection::setSetpointMaxCurrent(float setpointMaxCurrent)
{
    QVector<quint16> values = ModbusDataUtils::convertFromFloat32(setpointMaxCurrent, m_endianness);
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Write \"modbusSlaveMaxCurrent\" register:" << 1210 << "size:" << 2 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1210, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

float AlfenWallboxModbusTcpConnection::activeLoadBalancindSafeCurrent() const
{
    return m_activeLoadBalancindSafeCurrent;
}

quint16 AlfenWallboxModbusTcpConnection::setpointMaxCurrentActive() const
{
    return m_setpointMaxCurrentActive;
}

quint16 AlfenWallboxModbusTcpConnection::phaseUsed() const
{
    return m_phaseUsed;
}

QModbusReply *AlfenWallboxModbusTcpConnection::setPhaseUsed(quint16 phaseUsed)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(phaseUsed);
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Write \"chargingUsing1or3Phases\" register:" << 1215 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1215, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

float AlfenWallboxModbusTcpConnection::voltagePhaseL1() const
{
    return m_voltagePhaseL1;
}

float AlfenWallboxModbusTcpConnection::voltagePhaseL2() const
{
    return m_voltagePhaseL2;
}

float AlfenWallboxModbusTcpConnection::voltagePhaseL3() const
{
    return m_voltagePhaseL3;
}

float AlfenWallboxModbusTcpConnection::currentPhaseL1() const
{
    return m_currentPhaseL1;
}

float AlfenWallboxModbusTcpConnection::currentPhaseL2() const
{
    return m_currentPhaseL2;
}

float AlfenWallboxModbusTcpConnection::currentPhaseL3() const
{
    return m_currentPhaseL3;
}

float AlfenWallboxModbusTcpConnection::currentSum() const
{
    return m_currentSum;
}

float AlfenWallboxModbusTcpConnection::powerFactorPhase1() const
{
    return m_powerFactorPhase1;
}

float AlfenWallboxModbusTcpConnection::powerFactorPhase2() const
{
    return m_powerFactorPhase2;
}

float AlfenWallboxModbusTcpConnection::powerFactorPhase3() const
{
    return m_powerFactorPhase3;
}

float AlfenWallboxModbusTcpConnection::powerFactorSum() const
{
    return m_powerFactorSum;
}

float AlfenWallboxModbusTcpConnection::frequency() const
{
    return m_frequency;
}

float AlfenWallboxModbusTcpConnection::realPowerPhase1() const
{
    return m_realPowerPhase1;
}

float AlfenWallboxModbusTcpConnection::realPowerPhase2() const
{
    return m_realPowerPhase2;
}

float AlfenWallboxModbusTcpConnection::realPowerPhase3() const
{
    return m_realPowerPhase3;
}

float AlfenWallboxModbusTcpConnection::realPowerSum() const
{
    return m_realPowerSum;
}

float AlfenWallboxModbusTcpConnection::currerealEnergyDeliveredL1() const
{
    return m_currerealEnergyDeliveredL1;
}

float AlfenWallboxModbusTcpConnection::realEnergyDeliveredPhaseL2() const
{
    return m_realEnergyDeliveredPhaseL2;
}

float AlfenWallboxModbusTcpConnection::realEnergyDeliveredPhaseL3() const
{
    return m_realEnergyDeliveredPhaseL3;
}

float AlfenWallboxModbusTcpConnection::realEnergyDeliveredSum() const
{
    return m_realEnergyDeliveredSum;
}

float AlfenWallboxModbusTcpConnection::currerealEnergyConsumedL1() const
{
    return m_currerealEnergyConsumedL1;
}

float AlfenWallboxModbusTcpConnection::realEnergyConsumedPhaseL2() const
{
    return m_realEnergyConsumedPhaseL2;
}

float AlfenWallboxModbusTcpConnection::realEnergyConsumedPhaseL3() const
{
    return m_realEnergyConsumedPhaseL3;
}

float AlfenWallboxModbusTcpConnection::realEnergyConsumedSum() const
{
    return m_realEnergyConsumedSum;
}

AlfenWallboxModbusTcpConnection::Availability AlfenWallboxModbusTcpConnection::availability() const
{
    return m_availability;
}

QString AlfenWallboxModbusTcpConnection::mode3State() const
{
    return m_mode3State;
}

float AlfenWallboxModbusTcpConnection::actualAppliedMaxCurrent() const
{
    return m_actualAppliedMaxCurrent;
}

quint32 AlfenWallboxModbusTcpConnection::modbusSlaveMaxCurrentValidTime() const
{
    return m_modbusSlaveMaxCurrentValidTime;
}

bool AlfenWallboxModbusTcpConnection::initialize()
{
    if (!m_reachable) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Tried to initialize but the device is not to be reachable.";
        return false;
    }
    // No init registers defined. Nothing to be done and we are finished.
    emit initializationFinished(true);
    return true;
}

bool AlfenWallboxModbusTcpConnection::update()
{
    if (!connected())
        return false;

    if (!m_pendingUpdateReplies.isEmpty()) {
        qCDebug(dcAlfenWallboxModbusTcpConnection()) << "Tried to update but there are still some update replies pending. Waiting for them to be finished...";
        return true;
    }

    QModbusReply *reply = nullptr;

    // Read modbusSlaveMaxCurrent
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"modbusSlaveMaxCurrent\" register:" << 1210 << "size:" << 2;
    reply = readSetpointMaxCurrent();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"modbusSlaveMaxCurrent\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"modbusSlaveMaxCurrent\" register" << 1210 << "size:" << 2 << unit.values();
        processSetpointMaxCurrentRegisterValues(unit.values());
        update1();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while reading \"modbusSlaveMaxCurrent\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
  
    return true;
}

void AlfenWallboxModbusTcpConnection::update1()
{
    QModbusReply *reply = nullptr;

    // Read activeLoadBalancindSafeCurrent
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"activeLoadBalancindSafeCurrent\" register:" << 1212 << "size:" << 2;
    reply = readActiveLoadBalancindSafeCurrent();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"activeLoadBalancindSafeCurrent\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"activeLoadBalancindSafeCurrent\" register" << 1212 << "size:" << 2 << unit.values();
        processActiveLoadBalancindSafeCurrentRegisterValues(unit.values());
        update2();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while reading \"activeLoadBalancindSafeCurrent\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::update2()
{
    QModbusReply *reply = nullptr;

    // Read modbusSlaveReceivedSetpointAccountedFor
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"modbusSlaveReceivedSetpointAccountedFor\" register:" << 1214 << "size:" << 1;
    reply = readSetpointMaxCurrentActive();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"modbusSlaveReceivedSetpointAccountedFor\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"modbusSlaveReceivedSetpointAccountedFor\" register" << 1214 << "size:" << 1 << unit.values();
        processSetpointMaxCurrentActiveRegisterValues(unit.values());
        update3();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while reading \"modbusSlaveReceivedSetpointAccountedFor\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::update3()
{
    QModbusReply *reply = nullptr;

    // Read chargingUsing1or3Phases
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"chargingUsing1or3Phases\" register:" << 1215 << "size:" << 1;
    reply = readPhaseUsed();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"chargingUsing1or3Phases\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"chargingUsing1or3Phases\" register" << 1215 << "size:" << 1 << unit.values();
        processPhaseUsedRegisterValues(unit.values());
        update4();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while reading \"chargingUsing1or3Phases\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::update4()
{
    QModbusReply *reply = nullptr;

    // Read voltage
    reply = readBlockVoltage();
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read block \"voltage\" registers from:" << 306 << "size:" << 6;
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading block \"voltage\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from reading block \"voltage\" register" << 306 << "size:" << 6 << blockValues;
        processVoltagePhaseL1RegisterValues(blockValues.mid(0, 2));
        processVoltagePhaseL2RegisterValues(blockValues.mid(2, 2));
        processVoltagePhaseL3RegisterValues(blockValues.mid(4, 2));
        update5();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"voltage\" registers" << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::update5()
{
    QModbusReply *reply = nullptr;

    // Read currentPowerFactorFreqPower
    reply = readBlockCurrentPowerFactorFreqPower();
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read block \"currentPowerFactorFreqPower\" registers from:" << 320 << "size:" << 26;
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading block \"currentPowerFactorFreqPower\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from reading block \"currentPowerFactorFreqPower\" register" << 320 << "size:" << 26 << blockValues;
        processCurrentPhaseL1RegisterValues(blockValues.mid(0, 2));
        processCurrentPhaseL2RegisterValues(blockValues.mid(2, 2));
        processCurrentPhaseL3RegisterValues(blockValues.mid(4, 2));
        processCurrentSumRegisterValues(blockValues.mid(6, 2));
        processPowerFactorPhase1RegisterValues(blockValues.mid(8, 2));
        processPowerFactorPhase2RegisterValues(blockValues.mid(10, 2));
        processPowerFactorPhase3RegisterValues(blockValues.mid(12, 2));
        processPowerFactorSumRegisterValues(blockValues.mid(14, 2));
        processFrequencyRegisterValues(blockValues.mid(16, 2));
        processRealPowerPhase1RegisterValues(blockValues.mid(18, 2));
        processRealPowerPhase2RegisterValues(blockValues.mid(20, 2));
        processRealPowerPhase3RegisterValues(blockValues.mid(22, 2));
        processRealPowerSumRegisterValues(blockValues.mid(24, 2));
        update6();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"currentPowerFactorFreqPower\" registers" << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::update6()
{
    QModbusReply *reply = nullptr;

    // Read energy
    reply = readBlockEnergy();
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read block \"energy\" registers from:" << 362 << "size:" << 32;
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading block \"energy\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from reading block \"energy\" register" << 362 << "size:" << 32 << blockValues;
        processCurrerealEnergyDeliveredL1RegisterValues(blockValues.mid(0, 4));
        processRealEnergyDeliveredPhaseL2RegisterValues(blockValues.mid(4, 4));
        processRealEnergyDeliveredPhaseL3RegisterValues(blockValues.mid(8, 4));
        processRealEnergyDeliveredSumRegisterValues(blockValues.mid(12, 4));
        processCurrerealEnergyConsumedL1RegisterValues(blockValues.mid(16, 4));
        processRealEnergyConsumedPhaseL2RegisterValues(blockValues.mid(20, 4));
        processRealEnergyConsumedPhaseL3RegisterValues(blockValues.mid(24, 4));
        processRealEnergyConsumedSumRegisterValues(blockValues.mid(28, 4));
        update7();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"energy\" registers" << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::update7()
{
    QModbusReply *reply = nullptr;

    // Read statusAndTransactions
    reply = readBlockStatusAndTransactions();
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read block \"statusAndTransactions\" registers from:" << 1200 << "size:" << 10;
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading block \"statusAndTransactions\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from reading block \"statusAndTransactions\" register" << 1200 << "size:" << 10 << blockValues;
        processAvailabilityRegisterValues(blockValues.mid(0, 1));
        processMode3StateRegisterValues(blockValues.mid(1, 5));
        processActualAppliedMaxCurrentRegisterValues(blockValues.mid(6, 2));
        processModbusSlaveMaxCurrentValidTimeRegisterValues(blockValues.mid(8, 2));
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"statusAndTransactions\" registers" << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateSetpointMaxCurrent()
{
    // Update registers from modbusSlaveMaxCurrent
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"modbusSlaveMaxCurrent\" register:" << 1210 << "size:" << 2;
    QModbusReply *reply = readSetpointMaxCurrent();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"modbusSlaveMaxCurrent\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"modbusSlaveMaxCurrent\" register" << 1210 << "size:" << 2 << unit.values();
            processSetpointMaxCurrentRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"modbusSlaveMaxCurrent\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateActiveLoadBalancindSafeCurrent()
{
    // Update registers from activeLoadBalancindSafeCurrent
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"activeLoadBalancindSafeCurrent\" register:" << 1212 << "size:" << 2;
    QModbusReply *reply = readActiveLoadBalancindSafeCurrent();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"activeLoadBalancindSafeCurrent\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"activeLoadBalancindSafeCurrent\" register" << 1212 << "size:" << 2 << unit.values();
            processActiveLoadBalancindSafeCurrentRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"activeLoadBalancindSafeCurrent\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateSetpointMaxCurrentActive()
{
    // Update registers from modbusSlaveReceivedSetpointAccountedFor
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"modbusSlaveReceivedSetpointAccountedFor\" register:" << 1214 << "size:" << 1;
    QModbusReply *reply = readSetpointMaxCurrentActive();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"modbusSlaveReceivedSetpointAccountedFor\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"modbusSlaveReceivedSetpointAccountedFor\" register" << 1214 << "size:" << 1 << unit.values();
            processSetpointMaxCurrentActiveRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"modbusSlaveReceivedSetpointAccountedFor\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updatePhaseUsed()
{
    // Update registers from chargingUsing1or3Phases
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"chargingUsing1or3Phases\" register:" << 1215 << "size:" << 1;
    QModbusReply *reply = readPhaseUsed();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"chargingUsing1or3Phases\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"chargingUsing1or3Phases\" register" << 1215 << "size:" << 1 << unit.values();
            processPhaseUsedRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"chargingUsing1or3Phases\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateVoltagePhaseL1()
{
    // Update registers from voltagePhaseL1
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"voltagePhaseL1\" register:" << 306 << "size:" << 2;
    QModbusReply *reply = readVoltagePhaseL1();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"voltagePhaseL1\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"voltagePhaseL1\" register" << 306 << "size:" << 2 << unit.values();
            processVoltagePhaseL1RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"voltagePhaseL1\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateVoltagePhaseL2()
{
    // Update registers from voltagePhaseL2
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"voltagePhaseL2\" register:" << 308 << "size:" << 2;
    QModbusReply *reply = readVoltagePhaseL2();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"voltagePhaseL2\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"voltagePhaseL2\" register" << 308 << "size:" << 2 << unit.values();
            processVoltagePhaseL2RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"voltagePhaseL2\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateVoltagePhaseL3()
{
    // Update registers from voltagePhaseL3
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"voltagePhaseL3\" register:" << 310 << "size:" << 2;
    QModbusReply *reply = readVoltagePhaseL3();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"voltagePhaseL3\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"voltagePhaseL3\" register" << 310 << "size:" << 2 << unit.values();
            processVoltagePhaseL3RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"voltagePhaseL3\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateCurrentPhaseL1()
{
    // Update registers from currentPhaseL1
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"currentPhaseL1\" register:" << 320 << "size:" << 2;
    QModbusReply *reply = readCurrentPhaseL1();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"currentPhaseL1\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"currentPhaseL1\" register" << 320 << "size:" << 2 << unit.values();
            processCurrentPhaseL1RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"currentPhaseL1\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateCurrentPhaseL2()
{
    // Update registers from currentPhaseL2
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"currentPhaseL2\" register:" << 322 << "size:" << 2;
    QModbusReply *reply = readCurrentPhaseL2();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"currentPhaseL2\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"currentPhaseL2\" register" << 322 << "size:" << 2 << unit.values();
            processCurrentPhaseL2RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"currentPhaseL2\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateCurrentPhaseL3()
{
    // Update registers from currentPhaseL3
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"currentPhaseL3\" register:" << 324 << "size:" << 2;
    QModbusReply *reply = readCurrentPhaseL3();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"currentPhaseL3\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"currentPhaseL3\" register" << 324 << "size:" << 2 << unit.values();
            processCurrentPhaseL3RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"currentPhaseL3\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateCurrentSum()
{
    // Update registers from currentSum
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"currentSum\" register:" << 326 << "size:" << 2;
    QModbusReply *reply = readCurrentSum();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"currentSum\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"currentSum\" register" << 326 << "size:" << 2 << unit.values();
            processCurrentSumRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"currentSum\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updatePowerFactorPhase1()
{
    // Update registers from powerFactorPhase1
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"powerFactorPhase1\" register:" << 328 << "size:" << 2;
    QModbusReply *reply = readPowerFactorPhase1();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"powerFactorPhase1\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"powerFactorPhase1\" register" << 328 << "size:" << 2 << unit.values();
            processPowerFactorPhase1RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"powerFactorPhase1\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updatePowerFactorPhase2()
{
    // Update registers from powerFactorPhase2
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"powerFactorPhase2\" register:" << 330 << "size:" << 2;
    QModbusReply *reply = readPowerFactorPhase2();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"powerFactorPhase2\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"powerFactorPhase2\" register" << 330 << "size:" << 2 << unit.values();
            processPowerFactorPhase2RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"powerFactorPhase2\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updatePowerFactorPhase3()
{
    // Update registers from powerFactorPhase3
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"powerFactorPhase3\" register:" << 332 << "size:" << 2;
    QModbusReply *reply = readPowerFactorPhase3();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"powerFactorPhase3\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"powerFactorPhase3\" register" << 332 << "size:" << 2 << unit.values();
            processPowerFactorPhase3RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"powerFactorPhase3\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updatePowerFactorSum()
{
    // Update registers from powerFactorSum
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"powerFactorSum\" register:" << 334 << "size:" << 2;
    QModbusReply *reply = readPowerFactorSum();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"powerFactorSum\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"powerFactorSum\" register" << 334 << "size:" << 2 << unit.values();
            processPowerFactorSumRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"powerFactorSum\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateFrequency()
{
    // Update registers from frequency
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"frequency\" register:" << 336 << "size:" << 2;
    QModbusReply *reply = readFrequency();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"frequency\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"frequency\" register" << 336 << "size:" << 2 << unit.values();
            processFrequencyRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"frequency\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateRealPowerPhase1()
{
    // Update registers from realPowerPhase1
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"realPowerPhase1\" register:" << 338 << "size:" << 2;
    QModbusReply *reply = readRealPowerPhase1();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"realPowerPhase1\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"realPowerPhase1\" register" << 338 << "size:" << 2 << unit.values();
            processRealPowerPhase1RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"realPowerPhase1\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateRealPowerPhase2()
{
    // Update registers from realPowerPhase2
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"realPowerPhase2\" register:" << 340 << "size:" << 2;
    QModbusReply *reply = readRealPowerPhase2();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"realPowerPhase2\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"realPowerPhase2\" register" << 340 << "size:" << 2 << unit.values();
            processRealPowerPhase2RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"realPowerPhase2\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateRealPowerPhase3()
{
    // Update registers from realPowerPhase3
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"realPowerPhase3\" register:" << 342 << "size:" << 2;
    QModbusReply *reply = readRealPowerPhase3();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"realPowerPhase3\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"realPowerPhase3\" register" << 342 << "size:" << 2 << unit.values();
            processRealPowerPhase3RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"realPowerPhase3\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateRealPowerSum()
{
    // Update registers from realPowerSum
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"realPowerSum\" register:" << 344 << "size:" << 2;
    QModbusReply *reply = readRealPowerSum();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"realPowerSum\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"realPowerSum\" register" << 344 << "size:" << 2 << unit.values();
            processRealPowerSumRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"realPowerSum\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateCurrerealEnergyDeliveredL1()
{
    // Update registers from realEnergyDeliveredPhaseL1
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"realEnergyDeliveredPhaseL1\" register:" << 362 << "size:" << 4;
    QModbusReply *reply = readCurrerealEnergyDeliveredL1();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"realEnergyDeliveredPhaseL1\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"realEnergyDeliveredPhaseL1\" register" << 362 << "size:" << 4 << unit.values();
            processCurrerealEnergyDeliveredL1RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"realEnergyDeliveredPhaseL1\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateRealEnergyDeliveredPhaseL2()
{
    // Update registers from realEnergyDeliveredPhaseL2
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"realEnergyDeliveredPhaseL2\" register:" << 366 << "size:" << 4;
    QModbusReply *reply = readRealEnergyDeliveredPhaseL2();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"realEnergyDeliveredPhaseL2\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"realEnergyDeliveredPhaseL2\" register" << 366 << "size:" << 4 << unit.values();
            processRealEnergyDeliveredPhaseL2RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"realEnergyDeliveredPhaseL2\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateRealEnergyDeliveredPhaseL3()
{
    // Update registers from realEnergyDeliveredPhaseL3
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"realEnergyDeliveredPhaseL3\" register:" << 370 << "size:" << 4;
    QModbusReply *reply = readRealEnergyDeliveredPhaseL3();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"realEnergyDeliveredPhaseL3\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"realEnergyDeliveredPhaseL3\" register" << 370 << "size:" << 4 << unit.values();
            processRealEnergyDeliveredPhaseL3RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"realEnergyDeliveredPhaseL3\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateRealEnergyDeliveredSum()
{
    // Update registers from realEnergyDeliveredSum
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"realEnergyDeliveredSum\" register:" << 374 << "size:" << 4;
    QModbusReply *reply = readRealEnergyDeliveredSum();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"realEnergyDeliveredSum\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"realEnergyDeliveredSum\" register" << 374 << "size:" << 4 << unit.values();
            processRealEnergyDeliveredSumRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"realEnergyDeliveredSum\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateCurrerealEnergyConsumedL1()
{
    // Update registers from realEnergyConsumedPhaseL1
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"realEnergyConsumedPhaseL1\" register:" << 378 << "size:" << 4;
    QModbusReply *reply = readCurrerealEnergyConsumedL1();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"realEnergyConsumedPhaseL1\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"realEnergyConsumedPhaseL1\" register" << 378 << "size:" << 4 << unit.values();
            processCurrerealEnergyConsumedL1RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"realEnergyConsumedPhaseL1\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateRealEnergyConsumedPhaseL2()
{
    // Update registers from realEnergyConsumedPhaseL2
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"realEnergyConsumedPhaseL2\" register:" << 382 << "size:" << 4;
    QModbusReply *reply = readRealEnergyConsumedPhaseL2();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"realEnergyConsumedPhaseL2\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"realEnergyConsumedPhaseL2\" register" << 382 << "size:" << 4 << unit.values();
            processRealEnergyConsumedPhaseL2RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"realEnergyConsumedPhaseL2\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateRealEnergyConsumedPhaseL3()
{
    // Update registers from realEnergyConsumedPhaseL3
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"realEnergyConsumedPhaseL3\" register:" << 386 << "size:" << 4;
    QModbusReply *reply = readRealEnergyConsumedPhaseL3();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"realEnergyConsumedPhaseL3\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"realEnergyConsumedPhaseL3\" register" << 386 << "size:" << 4 << unit.values();
            processRealEnergyConsumedPhaseL3RegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"realEnergyConsumedPhaseL3\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateRealEnergyConsumedSum()
{
    // Update registers from realEnergyConsumedSum
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"realEnergyConsumedSum\" register:" << 390 << "size:" << 4;
    QModbusReply *reply = readRealEnergyConsumedSum();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"realEnergyConsumedSum\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"realEnergyConsumedSum\" register" << 390 << "size:" << 4 << unit.values();
            processRealEnergyConsumedSumRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"realEnergyConsumedSum\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateAvailability()
{
    // Update registers from availability
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"availability\" register:" << 1200 << "size:" << 1;
    QModbusReply *reply = readAvailability();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"availability\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"availability\" register" << 1200 << "size:" << 1 << unit.values();
            processAvailabilityRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"availability\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateMode3State()
{
    // Update registers from mode3State61851
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"mode3State61851\" register:" << 1201 << "size:" << 5;
    QModbusReply *reply = readMode3State();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"mode3State61851\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"mode3State61851\" register" << 1201 << "size:" << 5 << unit.values();
            processMode3StateRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"mode3State61851\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateActualAppliedMaxCurrent()
{
    // Update registers from actualAppliedMaxCurrent
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"actualAppliedMaxCurrent\" register:" << 1206 << "size:" << 2;
    QModbusReply *reply = readActualAppliedMaxCurrent();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"actualAppliedMaxCurrent\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"actualAppliedMaxCurrent\" register" << 1206 << "size:" << 2 << unit.values();
            processActualAppliedMaxCurrentRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"actualAppliedMaxCurrent\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateModbusSlaveMaxCurrentValidTime()
{
    // Update registers from modbusSlaveMaxCurrentValidTime
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read \"modbusSlaveMaxCurrentValidTime\" register:" << 1208 << "size:" << 2;
    QModbusReply *reply = readModbusSlaveMaxCurrentValidTime();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading \"modbusSlaveMaxCurrentValidTime\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from \"modbusSlaveMaxCurrentValidTime\" register" << 1208 << "size:" << 2 << unit.values();
            processModbusSlaveMaxCurrentValidTimeRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating \"modbusSlaveMaxCurrentValidTime\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateVoltageBlock()
{
    // Update register block "voltage"
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read block \"voltage\" registers from:" << 306 << "size:" << 6;
    QModbusReply *reply = readBlockVoltage();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading block \"voltage\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from reading block \"voltage\" register" << 306 << "size:" << 6 << blockValues;
            processVoltagePhaseL1RegisterValues(blockValues.mid(0, 2));
            processVoltagePhaseL2RegisterValues(blockValues.mid(2, 2));
            processVoltagePhaseL3RegisterValues(blockValues.mid(4, 2));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"voltage\" registers" << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateCurrentPowerFactorFreqPowerBlock()
{
    // Update register block "currentPowerFactorFreqPower"
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read block \"currentPowerFactorFreqPower\" registers from:" << 320 << "size:" << 26;
    QModbusReply *reply = readBlockCurrentPowerFactorFreqPower();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading block \"currentPowerFactorFreqPower\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from reading block \"currentPowerFactorFreqPower\" register" << 320 << "size:" << 26 << blockValues;
            processCurrentPhaseL1RegisterValues(blockValues.mid(0, 2));
            processCurrentPhaseL2RegisterValues(blockValues.mid(2, 2));
            processCurrentPhaseL3RegisterValues(blockValues.mid(4, 2));
            processCurrentSumRegisterValues(blockValues.mid(6, 2));
            processPowerFactorPhase1RegisterValues(blockValues.mid(8, 2));
            processPowerFactorPhase2RegisterValues(blockValues.mid(10, 2));
            processPowerFactorPhase3RegisterValues(blockValues.mid(12, 2));
            processPowerFactorSumRegisterValues(blockValues.mid(14, 2));
            processFrequencyRegisterValues(blockValues.mid(16, 2));
            processRealPowerPhase1RegisterValues(blockValues.mid(18, 2));
            processRealPowerPhase2RegisterValues(blockValues.mid(20, 2));
            processRealPowerPhase3RegisterValues(blockValues.mid(22, 2));
            processRealPowerSumRegisterValues(blockValues.mid(24, 2));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"currentPowerFactorFreqPower\" registers" << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateEnergyBlock()
{
    // Update register block "energy"
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read block \"energy\" registers from:" << 362 << "size:" << 32;
    QModbusReply *reply = readBlockEnergy();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading block \"energy\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from reading block \"energy\" register" << 362 << "size:" << 32 << blockValues;
            processCurrerealEnergyDeliveredL1RegisterValues(blockValues.mid(0, 4));
            processRealEnergyDeliveredPhaseL2RegisterValues(blockValues.mid(4, 4));
            processRealEnergyDeliveredPhaseL3RegisterValues(blockValues.mid(8, 4));
            processRealEnergyDeliveredSumRegisterValues(blockValues.mid(12, 4));
            processCurrerealEnergyConsumedL1RegisterValues(blockValues.mid(16, 4));
            processRealEnergyConsumedPhaseL2RegisterValues(blockValues.mid(20, 4));
            processRealEnergyConsumedPhaseL3RegisterValues(blockValues.mid(24, 4));
            processRealEnergyConsumedSumRegisterValues(blockValues.mid(28, 4));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"energy\" registers" << error << reply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::updateStatusAndTransactionsBlock()
{
    // Update register block "statusAndTransactions"
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Read block \"statusAndTransactions\" registers from:" << 1200 << "size:" << 10;
    QModbusReply *reply = readBlockStatusAndTransactions();
    if (!reply) {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Error occurred while reading block \"statusAndTransactions\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "<-- Response from reading block \"statusAndTransactions\" register" << 1200 << "size:" << 10 << blockValues;
            processAvailabilityRegisterValues(blockValues.mid(0, 1));
            processMode3StateRegisterValues(blockValues.mid(1, 5));
            processActualAppliedMaxCurrentRegisterValues(blockValues.mid(6, 2));
            processModbusSlaveMaxCurrentValidTimeRegisterValues(blockValues.mid(8, 2));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while updating block \"statusAndTransactions\" registers" << error << reply->errorString();
    });
}

QModbusReply *AlfenWallboxModbusTcpConnection::readSetpointMaxCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1210, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readActiveLoadBalancindSafeCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1212, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readSetpointMaxCurrentActive()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1214, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readPhaseUsed()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1215, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readVoltagePhaseL1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 306, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readVoltagePhaseL2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 308, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readVoltagePhaseL3()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 310, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readCurrentPhaseL1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 320, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readCurrentPhaseL2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 322, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readCurrentPhaseL3()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 324, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readCurrentSum()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 326, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readPowerFactorPhase1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 328, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readPowerFactorPhase2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 330, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readPowerFactorPhase3()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 332, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readPowerFactorSum()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 334, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readFrequency()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 336, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readRealPowerPhase1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 338, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readRealPowerPhase2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 340, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readRealPowerPhase3()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 342, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readRealPowerSum()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 344, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readCurrerealEnergyDeliveredL1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 362, 4);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readRealEnergyDeliveredPhaseL2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 366, 4);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readRealEnergyDeliveredPhaseL3()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 370, 4);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readRealEnergyDeliveredSum()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 374, 4);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readCurrerealEnergyConsumedL1()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 378, 4);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readRealEnergyConsumedPhaseL2()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 382, 4);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readRealEnergyConsumedPhaseL3()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 386, 4);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readRealEnergyConsumedSum()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 390, 4);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readAvailability()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1200, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readMode3State()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1201, 5);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readActualAppliedMaxCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1206, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readModbusSlaveMaxCurrentValidTime()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1208, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readBlockVoltage()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 306, 6);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readBlockCurrentPowerFactorFreqPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 320, 26);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readBlockEnergy()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 362, 32);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *AlfenWallboxModbusTcpConnection::readBlockStatusAndTransactions()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 1200, 10);
    return sendReadRequest(request, m_slaveId);
}

void AlfenWallboxModbusTcpConnection::processSetpointMaxCurrentRegisterValues(const QVector<quint16> values)
{
    float receivedSetpointMaxCurrent = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit setpointMaxCurrentReadFinished(receivedSetpointMaxCurrent);

    if (m_setpointMaxCurrent != receivedSetpointMaxCurrent) {
        m_setpointMaxCurrent = receivedSetpointMaxCurrent;
        emit setpointMaxCurrentChanged(m_setpointMaxCurrent);
    }
}

void AlfenWallboxModbusTcpConnection::processActiveLoadBalancindSafeCurrentRegisterValues(const QVector<quint16> values)
{
    float receivedActiveLoadBalancindSafeCurrent = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit activeLoadBalancindSafeCurrentReadFinished(receivedActiveLoadBalancindSafeCurrent);

    if (m_activeLoadBalancindSafeCurrent != receivedActiveLoadBalancindSafeCurrent) {
        m_activeLoadBalancindSafeCurrent = receivedActiveLoadBalancindSafeCurrent;
        emit activeLoadBalancindSafeCurrentChanged(m_activeLoadBalancindSafeCurrent);
    }
}

void AlfenWallboxModbusTcpConnection::processSetpointMaxCurrentActiveRegisterValues(const QVector<quint16> values)
{
    quint16 receivedSetpointMaxCurrentActive = ModbusDataUtils::convertToUInt16(values);
    emit setpointMaxCurrentActiveReadFinished(receivedSetpointMaxCurrentActive);

    if (m_setpointMaxCurrentActive != receivedSetpointMaxCurrentActive) {
        m_setpointMaxCurrentActive = receivedSetpointMaxCurrentActive;
        emit setpointMaxCurrentActiveChanged(m_setpointMaxCurrentActive);
    }
}

void AlfenWallboxModbusTcpConnection::processPhaseUsedRegisterValues(const QVector<quint16> values)
{
    quint16 receivedPhaseUsed = ModbusDataUtils::convertToUInt16(values);
    emit phaseUsedReadFinished(receivedPhaseUsed);

    if (m_phaseUsed != receivedPhaseUsed) {
        m_phaseUsed = receivedPhaseUsed;
        emit phaseUsedChanged(m_phaseUsed);
    }
}

void AlfenWallboxModbusTcpConnection::processVoltagePhaseL1RegisterValues(const QVector<quint16> values)
{
    float receivedVoltagePhaseL1 = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit voltagePhaseL1ReadFinished(receivedVoltagePhaseL1);

    if (m_voltagePhaseL1 != receivedVoltagePhaseL1) {
        m_voltagePhaseL1 = receivedVoltagePhaseL1;
        emit voltagePhaseL1Changed(m_voltagePhaseL1);
    }
}

void AlfenWallboxModbusTcpConnection::processVoltagePhaseL2RegisterValues(const QVector<quint16> values)
{
    float receivedVoltagePhaseL2 = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit voltagePhaseL2ReadFinished(receivedVoltagePhaseL2);

    if (m_voltagePhaseL2 != receivedVoltagePhaseL2) {
        m_voltagePhaseL2 = receivedVoltagePhaseL2;
        emit voltagePhaseL2Changed(m_voltagePhaseL2);
    }
}

void AlfenWallboxModbusTcpConnection::processVoltagePhaseL3RegisterValues(const QVector<quint16> values)
{
    float receivedVoltagePhaseL3 = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit voltagePhaseL3ReadFinished(receivedVoltagePhaseL3);

    if (m_voltagePhaseL3 != receivedVoltagePhaseL3) {
        m_voltagePhaseL3 = receivedVoltagePhaseL3;
        emit voltagePhaseL3Changed(m_voltagePhaseL3);
    }
}

void AlfenWallboxModbusTcpConnection::processCurrentPhaseL1RegisterValues(const QVector<quint16> values)
{
    float receivedCurrentPhaseL1 = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit currentPhaseL1ReadFinished(receivedCurrentPhaseL1);

    if (m_currentPhaseL1 != receivedCurrentPhaseL1) {
        m_currentPhaseL1 = receivedCurrentPhaseL1;
        emit currentPhaseL1Changed(m_currentPhaseL1);
    }
}

void AlfenWallboxModbusTcpConnection::processCurrentPhaseL2RegisterValues(const QVector<quint16> values)
{
    float receivedCurrentPhaseL2 = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit currentPhaseL2ReadFinished(receivedCurrentPhaseL2);

    if (m_currentPhaseL2 != receivedCurrentPhaseL2) {
        m_currentPhaseL2 = receivedCurrentPhaseL2;
        emit currentPhaseL2Changed(m_currentPhaseL2);
    }
}

void AlfenWallboxModbusTcpConnection::processCurrentPhaseL3RegisterValues(const QVector<quint16> values)
{
    float receivedCurrentPhaseL3 = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit currentPhaseL3ReadFinished(receivedCurrentPhaseL3);

    if (m_currentPhaseL3 != receivedCurrentPhaseL3) {
        m_currentPhaseL3 = receivedCurrentPhaseL3;
        emit currentPhaseL3Changed(m_currentPhaseL3);
    }
}

void AlfenWallboxModbusTcpConnection::processCurrentSumRegisterValues(const QVector<quint16> values)
{
    float receivedCurrentSum = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit currentSumReadFinished(receivedCurrentSum);

    if (m_currentSum != receivedCurrentSum) {
        m_currentSum = receivedCurrentSum;
        emit currentSumChanged(m_currentSum);
    }
}

void AlfenWallboxModbusTcpConnection::processPowerFactorPhase1RegisterValues(const QVector<quint16> values)
{
    float receivedPowerFactorPhase1 = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit powerFactorPhase1ReadFinished(receivedPowerFactorPhase1);

    if (m_powerFactorPhase1 != receivedPowerFactorPhase1) {
        m_powerFactorPhase1 = receivedPowerFactorPhase1;
        emit powerFactorPhase1Changed(m_powerFactorPhase1);
    }
}

void AlfenWallboxModbusTcpConnection::processPowerFactorPhase2RegisterValues(const QVector<quint16> values)
{
    float receivedPowerFactorPhase2 = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit powerFactorPhase2ReadFinished(receivedPowerFactorPhase2);

    if (m_powerFactorPhase2 != receivedPowerFactorPhase2) {
        m_powerFactorPhase2 = receivedPowerFactorPhase2;
        emit powerFactorPhase2Changed(m_powerFactorPhase2);
    }
}

void AlfenWallboxModbusTcpConnection::processPowerFactorPhase3RegisterValues(const QVector<quint16> values)
{
    float receivedPowerFactorPhase3 = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit powerFactorPhase3ReadFinished(receivedPowerFactorPhase3);

    if (m_powerFactorPhase3 != receivedPowerFactorPhase3) {
        m_powerFactorPhase3 = receivedPowerFactorPhase3;
        emit powerFactorPhase3Changed(m_powerFactorPhase3);
    }
}

void AlfenWallboxModbusTcpConnection::processPowerFactorSumRegisterValues(const QVector<quint16> values)
{
    float receivedPowerFactorSum = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit powerFactorSumReadFinished(receivedPowerFactorSum);

    if (m_powerFactorSum != receivedPowerFactorSum) {
        m_powerFactorSum = receivedPowerFactorSum;
        emit powerFactorSumChanged(m_powerFactorSum);
    }
}

void AlfenWallboxModbusTcpConnection::processFrequencyRegisterValues(const QVector<quint16> values)
{
    float receivedFrequency = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit frequencyReadFinished(receivedFrequency);

    if (m_frequency != receivedFrequency) {
        m_frequency = receivedFrequency;
        emit frequencyChanged(m_frequency);
    }
}

void AlfenWallboxModbusTcpConnection::processRealPowerPhase1RegisterValues(const QVector<quint16> values)
{
    float receivedRealPowerPhase1 = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit realPowerPhase1ReadFinished(receivedRealPowerPhase1);

    if (m_realPowerPhase1 != receivedRealPowerPhase1) {
        m_realPowerPhase1 = receivedRealPowerPhase1;
        emit realPowerPhase1Changed(m_realPowerPhase1);
    }
}

void AlfenWallboxModbusTcpConnection::processRealPowerPhase2RegisterValues(const QVector<quint16> values)
{
    float receivedRealPowerPhase2 = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit realPowerPhase2ReadFinished(receivedRealPowerPhase2);

    if (m_realPowerPhase2 != receivedRealPowerPhase2) {
        m_realPowerPhase2 = receivedRealPowerPhase2;
        emit realPowerPhase2Changed(m_realPowerPhase2);
    }
}

void AlfenWallboxModbusTcpConnection::processRealPowerPhase3RegisterValues(const QVector<quint16> values)
{
    float receivedRealPowerPhase3 = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit realPowerPhase3ReadFinished(receivedRealPowerPhase3);

    if (m_realPowerPhase3 != receivedRealPowerPhase3) {
        m_realPowerPhase3 = receivedRealPowerPhase3;
        emit realPowerPhase3Changed(m_realPowerPhase3);
    }
}

void AlfenWallboxModbusTcpConnection::processRealPowerSumRegisterValues(const QVector<quint16> values)
{
    float receivedRealPowerSum = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit realPowerSumReadFinished(receivedRealPowerSum);

    if (m_realPowerSum != receivedRealPowerSum) {
        m_realPowerSum = receivedRealPowerSum;
        emit realPowerSumChanged(m_realPowerSum);
    }
}

void AlfenWallboxModbusTcpConnection::processCurrerealEnergyDeliveredL1RegisterValues(const QVector<quint16> values)
{
    float receivedCurrerealEnergyDeliveredL1 = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit currerealEnergyDeliveredL1ReadFinished(receivedCurrerealEnergyDeliveredL1);

    if (m_currerealEnergyDeliveredL1 != receivedCurrerealEnergyDeliveredL1) {
        m_currerealEnergyDeliveredL1 = receivedCurrerealEnergyDeliveredL1;
        emit currerealEnergyDeliveredL1Changed(m_currerealEnergyDeliveredL1);
    }
}

void AlfenWallboxModbusTcpConnection::processRealEnergyDeliveredPhaseL2RegisterValues(const QVector<quint16> values)
{
    float receivedRealEnergyDeliveredPhaseL2 = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit realEnergyDeliveredPhaseL2ReadFinished(receivedRealEnergyDeliveredPhaseL2);

    if (m_realEnergyDeliveredPhaseL2 != receivedRealEnergyDeliveredPhaseL2) {
        m_realEnergyDeliveredPhaseL2 = receivedRealEnergyDeliveredPhaseL2;
        emit realEnergyDeliveredPhaseL2Changed(m_realEnergyDeliveredPhaseL2);
    }
}

void AlfenWallboxModbusTcpConnection::processRealEnergyDeliveredPhaseL3RegisterValues(const QVector<quint16> values)
{
    float receivedRealEnergyDeliveredPhaseL3 = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit realEnergyDeliveredPhaseL3ReadFinished(receivedRealEnergyDeliveredPhaseL3);

    if (m_realEnergyDeliveredPhaseL3 != receivedRealEnergyDeliveredPhaseL3) {
        m_realEnergyDeliveredPhaseL3 = receivedRealEnergyDeliveredPhaseL3;
        emit realEnergyDeliveredPhaseL3Changed(m_realEnergyDeliveredPhaseL3);
    }
}

void AlfenWallboxModbusTcpConnection::processRealEnergyDeliveredSumRegisterValues(const QVector<quint16> values)
{
    double receivedRealEnergyDeliveredSum = ModbusDataUtils::convertToFloat64(values, m_endianness) / 1000;
    emit realEnergyDeliveredSumReadFinished(receivedRealEnergyDeliveredSum);

    if (m_realEnergyDeliveredSum != receivedRealEnergyDeliveredSum) {
        m_realEnergyDeliveredSum = receivedRealEnergyDeliveredSum;
        emit realEnergyDeliveredSumChanged(m_realEnergyDeliveredSum);
    }
}

void AlfenWallboxModbusTcpConnection::processCurrerealEnergyConsumedL1RegisterValues(const QVector<quint16> values)
{
    float receivedCurrerealEnergyConsumedL1 = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit currerealEnergyConsumedL1ReadFinished(receivedCurrerealEnergyConsumedL1);

    if (m_currerealEnergyConsumedL1 != receivedCurrerealEnergyConsumedL1) {
        m_currerealEnergyConsumedL1 = receivedCurrerealEnergyConsumedL1;
        emit currerealEnergyConsumedL1Changed(m_currerealEnergyConsumedL1);
    }
}

void AlfenWallboxModbusTcpConnection::processRealEnergyConsumedPhaseL2RegisterValues(const QVector<quint16> values)
{
    float receivedRealEnergyConsumedPhaseL2 = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit realEnergyConsumedPhaseL2ReadFinished(receivedRealEnergyConsumedPhaseL2);

    if (m_realEnergyConsumedPhaseL2 != receivedRealEnergyConsumedPhaseL2) {
        m_realEnergyConsumedPhaseL2 = receivedRealEnergyConsumedPhaseL2;
        emit realEnergyConsumedPhaseL2Changed(m_realEnergyConsumedPhaseL2);
    }
}

void AlfenWallboxModbusTcpConnection::processRealEnergyConsumedPhaseL3RegisterValues(const QVector<quint16> values)
{
    float receivedRealEnergyConsumedPhaseL3 = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit realEnergyConsumedPhaseL3ReadFinished(receivedRealEnergyConsumedPhaseL3);

    if (m_realEnergyConsumedPhaseL3 != receivedRealEnergyConsumedPhaseL3) {
        m_realEnergyConsumedPhaseL3 = receivedRealEnergyConsumedPhaseL3;
        emit realEnergyConsumedPhaseL3Changed(m_realEnergyConsumedPhaseL3);
    }
}

void AlfenWallboxModbusTcpConnection::processRealEnergyConsumedSumRegisterValues(const QVector<quint16> values)
{
    float receivedRealEnergyConsumedSum = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit realEnergyConsumedSumReadFinished(receivedRealEnergyConsumedSum);

    if (m_realEnergyConsumedSum != receivedRealEnergyConsumedSum) {
        m_realEnergyConsumedSum = receivedRealEnergyConsumedSum;
        emit realEnergyConsumedSumChanged(m_realEnergyConsumedSum);
    }
}

void AlfenWallboxModbusTcpConnection::processAvailabilityRegisterValues(const QVector<quint16> values)
{
    Availability receivedAvailability = static_cast<Availability>(ModbusDataUtils::convertToUInt16(values));
    emit availabilityReadFinished(receivedAvailability);

    if (m_availability != receivedAvailability) {
        m_availability = receivedAvailability;
        emit availabilityChanged(m_availability);
    }
}

void AlfenWallboxModbusTcpConnection::processMode3StateRegisterValues(const QVector<quint16> values)
{
    QString receivedMode3State = ModbusDataUtils::convertToString(values);
    emit mode3StateReadFinished(receivedMode3State);

    if (m_mode3State != receivedMode3State) {
        m_mode3State = receivedMode3State;
        emit mode3StateChanged(m_mode3State);
    }
}

void AlfenWallboxModbusTcpConnection::processActualAppliedMaxCurrentRegisterValues(const QVector<quint16> values)
{
    float receivedActualAppliedMaxCurrent = ModbusDataUtils::convertToFloat32(values, m_endianness);
    emit actualAppliedMaxCurrentReadFinished(receivedActualAppliedMaxCurrent);

    if (m_actualAppliedMaxCurrent != receivedActualAppliedMaxCurrent) {
        m_actualAppliedMaxCurrent = receivedActualAppliedMaxCurrent;
        emit actualAppliedMaxCurrentChanged(m_actualAppliedMaxCurrent);
    }
}

void AlfenWallboxModbusTcpConnection::processModbusSlaveMaxCurrentValidTimeRegisterValues(const QVector<quint16> values)
{
    quint32 receivedModbusSlaveMaxCurrentValidTime = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit modbusSlaveMaxCurrentValidTimeReadFinished(receivedModbusSlaveMaxCurrentValidTime);

    if (m_modbusSlaveMaxCurrentValidTime != receivedModbusSlaveMaxCurrentValidTime) {
        m_modbusSlaveMaxCurrentValidTime = receivedModbusSlaveMaxCurrentValidTime;
        emit modbusSlaveMaxCurrentValidTimeChanged(m_modbusSlaveMaxCurrentValidTime);
    }
}

void AlfenWallboxModbusTcpConnection::handleModbusError(QModbusDevice::Error error)
{
    if (error == QModbusDevice::NoError) {
        // Reset the communication counter and we know we can reach the device
        m_communicationFailedCounter = 0;
        if (!m_communicationWorking)
            qCDebug(dcAlfenWallboxModbusTcpConnection()) << "Received a reply without any errors. The communication with the device seems to work now.";

        m_communicationWorking = true;
        evaluateReachableState();
    } else {
        m_communicationFailedCounter++;
        if (m_communicationWorking && m_communicationFailedCounter >= m_communicationFailedMax) {
            m_communicationWorking = false;
            qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Received" << m_communicationFailedCounter << "errors while communicating with the RTU master. Mark as not reachable until the communication works again.";
            evaluateReachableState();
        }
    }
}

void AlfenWallboxModbusTcpConnection::testReachability()
{
    if (m_checkRechableReply)
        return;

    // Try to read the check reachability register availability in order to verify if the communication is working or not.
    qCDebug(dcAlfenWallboxModbusTcpConnection()) << "--> Test reachability by reading \"availability\" register:" << 1200 << "size:" << 1;
    m_checkRechableReply = readAvailability();
    if (!m_checkRechableReply) {
        qCDebug(dcAlfenWallboxModbusTcpConnection()) << "Error occurred verifying reachability by reading \"availability\" register";
        onReachabilityCheckFailed();
        return;
    }

    if (m_checkRechableReply->isFinished()) {
        m_checkRechableReply->deleteLater(); // Broadcast reply returns immediatly
        m_checkRechableReply = nullptr;
        onReachabilityCheckFailed();
        return;
    }

    connect(m_checkRechableReply, &QModbusReply::finished, this, [this](){
        handleModbusError(m_checkRechableReply->error());
        if (m_checkRechableReply->error() != QModbusDevice::NoError)
            onReachabilityCheckFailed();

        m_checkRechableReply->deleteLater();
        m_checkRechableReply = nullptr;
    });

    connect(m_checkRechableReply, &QModbusReply::errorOccurred, this, [this] (QModbusDevice::Error error){
        qCDebug(dcAlfenWallboxModbusTcpConnection()) << "Modbus reply error occurred while verifying reachability by reading \"availability\" register" << error << m_checkRechableReply->errorString();
    });
}

void AlfenWallboxModbusTcpConnection::verifyInitFinished()
{
    if (m_pendingInitReplies.isEmpty()) {
        finishInitialization(true);
    }
}

void AlfenWallboxModbusTcpConnection::finishInitialization(bool success)
{
    if (success) {
        qCDebug(dcAlfenWallboxModbusTcpConnection()) << "Initialization finished of AlfenWallboxModbusTcpConnection" << hostAddress().toString() << "finished successfully";
    } else {
        qCWarning(dcAlfenWallboxModbusTcpConnection()) << "Initialization finished of AlfenWallboxModbusTcpConnection" << hostAddress().toString() << "failed.";
    }

    // Cleanup init
    delete m_initObject;
    m_initObject = nullptr;
    m_pendingInitReplies.clear();

    emit initializationFinished(success);
}

void AlfenWallboxModbusTcpConnection::verifyUpdateFinished()
{
    if (m_pendingUpdateReplies.isEmpty()) {
        emit updateFinished();
    }
}

void AlfenWallboxModbusTcpConnection::onReachabilityCheckFailed()
{
    m_checkReachableRetriesCount++;

    if (m_checkReachableRetriesCount <= m_checkReachableRetries) {
        qCDebug(dcAlfenWallboxModbusTcpConnection()) << "Reachability test failed. Retry in on second" << m_checkReachableRetriesCount << "/" << m_checkReachableRetries;
        QTimer::singleShot(1000, this, &AlfenWallboxModbusTcpConnection::testReachability);
        return;
    }

    // The test reachability method failed, not retrying any more
    emit checkReachabilityFailed();
}

void AlfenWallboxModbusTcpConnection::evaluateReachableState()
{
    bool reachable = m_communicationWorking && connected();
    if (m_reachable == reachable)
        return;

    m_reachable = reachable;
    emit reachableChanged(m_reachable);
    m_checkReachableRetriesCount = 0;
}

QDebug operator<<(QDebug debug, AlfenWallboxModbusTcpConnection *alfenWallboxModbusTcpConnection)
{
    debug.nospace().noquote() << "AlfenWallboxModbusTcpConnection(" << alfenWallboxModbusTcpConnection->hostAddress().toString() << ":" << alfenWallboxModbusTcpConnection->port() << ")" << "\n";
    debug.nospace().noquote() << "    - modbusSlaveMaxCurrent: " << alfenWallboxModbusTcpConnection->setpointMaxCurrent() << " [Ampere]" << "\n";
    debug.nospace().noquote() << "    - activeLoadBalancindSafeCurrent: " << alfenWallboxModbusTcpConnection->activeLoadBalancindSafeCurrent() << " [Ampere]" << "\n";
    debug.nospace().noquote() << "    - modbusSlaveReceivedSetpointAccountedFor: " << alfenWallboxModbusTcpConnection->setpointMaxCurrentActive() << "\n";
    debug.nospace().noquote() << "    - chargingUsing1or3Phases: " << alfenWallboxModbusTcpConnection->phaseUsed() << "\n";
    debug.nospace().noquote() << "    - voltagePhaseL1: " << alfenWallboxModbusTcpConnection->voltagePhaseL1() << " [Volt]" << "\n";
    debug.nospace().noquote() << "    - voltagePhaseL2: " << alfenWallboxModbusTcpConnection->voltagePhaseL2() << " [Volt]" << "\n";
    debug.nospace().noquote() << "    - voltagePhaseL3: " << alfenWallboxModbusTcpConnection->voltagePhaseL3() << " [Volt]" << "\n";
    debug.nospace().noquote() << "    - currentPhaseL1: " << alfenWallboxModbusTcpConnection->currentPhaseL1() << " [Ampere]" << "\n";
    debug.nospace().noquote() << "    - currentPhaseL2: " << alfenWallboxModbusTcpConnection->currentPhaseL2() << " [Ampere]" << "\n";
    debug.nospace().noquote() << "    - currentPhaseL3: " << alfenWallboxModbusTcpConnection->currentPhaseL3() << " [Ampere]" << "\n";
    debug.nospace().noquote() << "    - currentSum: " << alfenWallboxModbusTcpConnection->currentSum() << " [Ampere]" << "\n";
    debug.nospace().noquote() << "    - powerFactorPhase1: " << alfenWallboxModbusTcpConnection->powerFactorPhase1() << " [-]" << "\n";
    debug.nospace().noquote() << "    - powerFactorPhase2: " << alfenWallboxModbusTcpConnection->powerFactorPhase2() << " [-]" << "\n";
    debug.nospace().noquote() << "    - powerFactorPhase3: " << alfenWallboxModbusTcpConnection->powerFactorPhase3() << " [-]" << "\n";
    debug.nospace().noquote() << "    - powerFactorSum: " << alfenWallboxModbusTcpConnection->powerFactorSum() << " [-]" << "\n";
    debug.nospace().noquote() << "    - frequency: " << alfenWallboxModbusTcpConnection->frequency() << " [Hz]" << "\n";
    debug.nospace().noquote() << "    - realPowerPhase1: " << alfenWallboxModbusTcpConnection->realPowerPhase1() << " [Watt]" << "\n";
    debug.nospace().noquote() << "    - realPowerPhase2: " << alfenWallboxModbusTcpConnection->realPowerPhase2() << " [Watt]" << "\n";
    debug.nospace().noquote() << "    - realPowerPhase3: " << alfenWallboxModbusTcpConnection->realPowerPhase3() << " [Watt]" << "\n";
    debug.nospace().noquote() << "    - realPowerSum: " << alfenWallboxModbusTcpConnection->realPowerSum() << " [Watt]" << "\n";
    debug.nospace().noquote() << "    - realEnergyDeliveredPhaseL1: " << alfenWallboxModbusTcpConnection->currerealEnergyDeliveredL1() << " [WattHour]" << "\n";
    debug.nospace().noquote() << "    - realEnergyDeliveredPhaseL2: " << alfenWallboxModbusTcpConnection->realEnergyDeliveredPhaseL2() << " [WattHour]" << "\n";
    debug.nospace().noquote() << "    - realEnergyDeliveredPhaseL3: " << alfenWallboxModbusTcpConnection->realEnergyDeliveredPhaseL3() << " [WattHour]" << "\n";
    debug.nospace().noquote() << "    - realEnergyDeliveredSum: " << alfenWallboxModbusTcpConnection->realEnergyDeliveredSum() << " [WattHour]" << "\n";
    debug.nospace().noquote() << "    - realEnergyConsumedPhaseL1: " << alfenWallboxModbusTcpConnection->currerealEnergyConsumedL1() << " [WattHour]" << "\n";
    debug.nospace().noquote() << "    - realEnergyConsumedPhaseL2: " << alfenWallboxModbusTcpConnection->realEnergyConsumedPhaseL2() << " [WattHour]" << "\n";
    debug.nospace().noquote() << "    - realEnergyConsumedPhaseL3: " << alfenWallboxModbusTcpConnection->realEnergyConsumedPhaseL3() << " [WattHour]" << "\n";
    debug.nospace().noquote() << "    - realEnergyConsumedSum: " << alfenWallboxModbusTcpConnection->realEnergyConsumedSum() << " [WattHour]" << "\n";
    debug.nospace().noquote() << "    - availability: " << alfenWallboxModbusTcpConnection->availability() << "\n";
    debug.nospace().noquote() << "    - mode3State61851: " << alfenWallboxModbusTcpConnection->mode3State() << "\n";
    debug.nospace().noquote() << "    - actualAppliedMaxCurrent: " << alfenWallboxModbusTcpConnection->actualAppliedMaxCurrent() << " [Ampere]" << "\n";
    debug.nospace().noquote() << "    - modbusSlaveMaxCurrentValidTime: " << alfenWallboxModbusTcpConnection->modbusSlaveMaxCurrentValidTime() << " [Seconds]" << "\n";
    return debug.quote().space();
}

