/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Copyright 2013 - 2025, nymea GmbH
* Contact: contact@nymea.io
*
* This fileDescriptor is part of nymea.
* This project including source code and documentation is protected by
* copyright law, and remains the property of nymea GmbH. All rights, including
* reproduction, publication, editing and translation, are reserved. The use of
* this project is subject to the terms of a license agreement to be concluded
* with nymea GmbH in accordance with the terms of use of nymea GmbH, available
* under https://nymea.io/license
*
* GNU Lesser General Public License Usage
* Alternatively, this project may be redistributed and/or modified under the
* terms of the GNU Lesser General Public License as published by the Free
* Software Foundation; version 3. This project is distributed in the hope that
* it will be useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this project. If not, see <https://www.gnu.org/licenses/>.
*
* For any further details and any questions please contact us under
* contact@nymea.io or see our FAQ/Licensing Information on
* https://nymea.io/license/faq
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WARNING
*
* This file has been autogenerated. Any changes in this file may be overwritten.
* If you want to change something, update the register json or the tool.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#ifndef WEBASTONEXTMODBUSTCPCONNECTION_H
#define WEBASTONEXTMODBUSTCPCONNECTION_H

#include <QObject>

#include <modbusdatautils.h>
#include <modbustcpmaster.h>

class WebastoNextModbusTcpConnection : public ModbusTCPMaster
{
    Q_OBJECT
public:
    enum Registers {
        RegisterChargerState = 1000,
        RegisterChargeState = 1001,
        RegisterEvseState = 1002,
        RegisterCableState = 1004,
        RegisterEvseErrorCode = 1006,
        RegisterCurrentL1 = 1008,
        RegisterCurrentL2 = 1010,
        RegisterCurrentL3 = 1012,
        RegisterTotalActivePower = 1020,
        RegisterActivePowerL1 = 1024,
        RegisterActivePowerL2 = 1028,
        RegisterActivePowerL3 = 1032,
        RegisterEnergyConsumed = 1036,
        RegisterMaxChargingCurrent = 1100,
        RegisterMinChargingCurrent = 1102,
        RegisterMaxChargingCurrentStation = 1104,
        RegisterMaxChargingCurrentCable = 1106,
        RegisterMaxChargingCurrentEv = 1108,
        RegisterSessionEnergy = 1502,
        RegisterSafeCurrent = 2000,
        RegisterComTimeout = 2002,
        RegisterChargePower = 5000,
        RegisterChargeCurrent = 5004,
        RegisterChargingAction = 5006,
        RegisterLifeBit = 6000
    };
    Q_ENUM(Registers)

    enum ChargerState {
        ChargerStateNoVehicle = 0,
        ChargerStateVehicleAttachedNoPermission = 1,
        ChargerStateCharging = 3,
        ChargerStateChargingPaused = 4,
        ChargerStateChargingError = 7,
        ChargerStateChargingStationReserved = 8
    };
    Q_ENUM(ChargerState)

    enum ChargeState {
        ChargeStateIdle = 0,
        ChargeStateCharging = 1
    };
    Q_ENUM(ChargeState)

    enum EvseState {
        EvseStateStarting = 0,
        EvseStateRunning = 1,
        EvseStateError = 2
    };
    Q_ENUM(EvseState)

    enum CableState {
        CableStateNoCableAttached = 0,
        CableStateCableAttachedNoCar = 1,
        CableStateCableAttachedCarAttached = 2,
        CableStateCableAttachedCarAttachedLocked = 3
    };
    Q_ENUM(CableState)

    enum ChargingAction {
        ChargingActionNoAction = 0,
        ChargingActionStartSession = 1,
        ChargingActionCancelSession = 2
    };
    Q_ENUM(ChargingAction)

    explicit WebastoNextModbusTcpConnection(const QHostAddress &hostAddress, uint port, quint16 slaveId, QObject *parent = nullptr);
    ~WebastoNextModbusTcpConnection() = default;

    bool reachable() const;

    ModbusDataUtils::ByteOrder endianness() const;
    void setEndianness(ModbusDataUtils::ByteOrder endianness);

    uint checkReachableRetries() const;
    void setCheckReachableRetries(uint checkReachableRetries);

    /* Cable state - Address: 1004, Size: 1 */
    CableState cableState() const;

    /* ESVE Error codes, 0 = No error - Address: 1006, Size: 1 */
    quint16 evseErrorCode() const;

    /* Charging current L1 [mA] - Address: 1008, Size: 1 */
    quint16 currentL1() const;

    /* Charging current L2 [mA] - Address: 1010, Size: 1 */
    quint16 currentL2() const;

    /* Charging current L3 [mA] - Address: 1012, Size: 1 */
    quint16 currentL3() const;

    /* Total active charging power [W] - Address: 1020, Size: 2 */
    quint32 totalActivePower() const;

    /* Active power L1 [W] - Address: 1024, Size: 2 */
    quint32 activePowerL1() const;

    /* Active power L2 [W] - Address: 1028, Size: 2 */
    quint32 activePowerL2() const;

    /* Active power L3 [W] - Address: 1032, Size: 2 */
    quint32 activePowerL3() const;

    /* Energy meter reading of the charging station [Wh] - Address: 1036, Size: 2 */
    quint32 energyConsumed() const;

    /* The maximal charging current of the hardware (EVSE, Cable, EV) [A] - Address: 1100, Size: 1 */
    quint16 maxChargingCurrent() const;

    /* The minimal charging current of the hardware (EVSE, Cable, EV) [A] - Address: 1102, Size: 1 */
    quint16 minChargingCurrent() const;

    /* The maximal charging current of the station [A] - Address: 1104, Size: 1 */
    quint16 maxChargingCurrentStation() const;

    /* The maximal charging current of the cable [A] - Address: 1106, Size: 1 */
    quint16 maxChargingCurrentCable() const;

    /* The maximal charging current of the EV [A] - Address: 1108, Size: 1 */
    quint16 maxChargingCurrentEv() const;

    /* Sum of charged energy for the last session [Wh] - Address: 1502, Size: 1 */
    quint16 sessionEnergy() const;

    /* Max. charge current under communication failure [A] - Address: 2000, Size: 1 */
    quint16 safeCurrent() const;
    QModbusReply *setSafeCurrent(quint16 safeCurrent);

    /* Communication timeout [s] - Address: 2002, Size: 1 */
    quint16 comTimeout() const;
    QModbusReply *setComTimeout(quint16 comTimeout);

    /* Set the charge power [W] - Address: 5000, Size: 2 */
    quint32 chargePower() const;
    QModbusReply *setChargePower(quint32 chargePower);

    /* Set the charge current [A] - Address: 5004, Size: 1 */
    quint16 chargeCurrent() const;
    QModbusReply *setChargeCurrent(quint16 chargeCurrent);

    /* Start / Cancel charging session - Address: 5006, Size: 1 */
    ChargingAction chargingAction() const;
    QModbusReply *setChargingAction(ChargingAction chargingAction);

    /* Life bit - Address: 6000, Size: 1 */
    quint16 lifeBit() const;
    QModbusReply *setLifeBit(quint16 lifeBit);

    /* State of the charging device - Address: 1000, Size: 1 */
    ChargerState chargerState() const;

    /* Charge state - Address: 1001, Size: 1 */
    ChargeState chargeState() const;

    /* EVSE state (state of charging station) - Address: 1002, Size: 1 */
    EvseState evseState() const;

    /* Read block from start addess 1000 with size of 3 registers containing following 3 properties:
      - State of the charging device - Address: 1000, Size: 1
      - Charge state - Address: 1001, Size: 1
      - EVSE state (state of charging station) - Address: 1002, Size: 1
    */
    void updateStatesBlock();

    void updateCableState();
    void updateEvseErrorCode();
    void updateCurrentL1();
    void updateCurrentL2();
    void updateCurrentL3();
    void updateTotalActivePower();
    void updateActivePowerL1();
    void updateActivePowerL2();
    void updateActivePowerL3();
    void updateEnergyConsumed();
    void updateMaxChargingCurrent();
    void updateMinChargingCurrent();
    void updateMaxChargingCurrentStation();
    void updateMaxChargingCurrentCable();
    void updateMaxChargingCurrentEv();
    void updateSessionEnergy();
    void updateSafeCurrent();
    void updateComTimeout();
    void updateChargePower();
    void updateChargeCurrent();
    void updateChargingAction();
    void updateLifeBit();

    void updateChargerState();
    void updateChargeState();
    void updateEvseState();

    QModbusReply *readCableState();
    QModbusReply *readEvseErrorCode();
    QModbusReply *readCurrentL1();
    QModbusReply *readCurrentL2();
    QModbusReply *readCurrentL3();
    QModbusReply *readTotalActivePower();
    QModbusReply *readActivePowerL1();
    QModbusReply *readActivePowerL2();
    QModbusReply *readActivePowerL3();
    QModbusReply *readEnergyConsumed();
    QModbusReply *readMaxChargingCurrent();
    QModbusReply *readMinChargingCurrent();
    QModbusReply *readMaxChargingCurrentStation();
    QModbusReply *readMaxChargingCurrentCable();
    QModbusReply *readMaxChargingCurrentEv();
    QModbusReply *readSessionEnergy();
    QModbusReply *readSafeCurrent();
    QModbusReply *readComTimeout();
    QModbusReply *readChargePower();
    QModbusReply *readChargeCurrent();
    QModbusReply *readChargingAction();
    QModbusReply *readLifeBit();
    QModbusReply *readChargerState();
    QModbusReply *readChargeState();
    QModbusReply *readEvseState();

    /* Read block from start addess 1000 with size of 3 registers containing following 3 properties:
     - State of the charging device - Address: 1000, Size: 1
     - Charge state - Address: 1001, Size: 1
     - EVSE state (state of charging station) - Address: 1002, Size: 1
    */
    QModbusReply *readBlockStates();


    virtual bool initialize();
    virtual bool update();

signals:
    void reachableChanged(bool reachable);
    void checkReachabilityFailed();
    void checkReachableRetriesChanged(uint checkReachableRetries);

    void initializationFinished(bool success);
    void updateFinished();

    void endiannessChanged(ModbusDataUtils::ByteOrder endianness);

    void cableStateChanged(CableState cableState);
    void cableStateReadFinished(CableState cableState);
    void evseErrorCodeChanged(quint16 evseErrorCode);
    void evseErrorCodeReadFinished(quint16 evseErrorCode);
    void currentL1Changed(quint16 currentL1);
    void currentL1ReadFinished(quint16 currentL1);
    void currentL2Changed(quint16 currentL2);
    void currentL2ReadFinished(quint16 currentL2);
    void currentL3Changed(quint16 currentL3);
    void currentL3ReadFinished(quint16 currentL3);
    void totalActivePowerChanged(quint32 totalActivePower);
    void totalActivePowerReadFinished(quint32 totalActivePower);
    void activePowerL1Changed(quint32 activePowerL1);
    void activePowerL1ReadFinished(quint32 activePowerL1);
    void activePowerL2Changed(quint32 activePowerL2);
    void activePowerL2ReadFinished(quint32 activePowerL2);
    void activePowerL3Changed(quint32 activePowerL3);
    void activePowerL3ReadFinished(quint32 activePowerL3);
    void energyConsumedChanged(quint32 energyConsumed);
    void energyConsumedReadFinished(quint32 energyConsumed);
    void maxChargingCurrentChanged(quint16 maxChargingCurrent);
    void maxChargingCurrentReadFinished(quint16 maxChargingCurrent);
    void minChargingCurrentChanged(quint16 minChargingCurrent);
    void minChargingCurrentReadFinished(quint16 minChargingCurrent);
    void maxChargingCurrentStationChanged(quint16 maxChargingCurrentStation);
    void maxChargingCurrentStationReadFinished(quint16 maxChargingCurrentStation);
    void maxChargingCurrentCableChanged(quint16 maxChargingCurrentCable);
    void maxChargingCurrentCableReadFinished(quint16 maxChargingCurrentCable);
    void maxChargingCurrentEvChanged(quint16 maxChargingCurrentEv);
    void maxChargingCurrentEvReadFinished(quint16 maxChargingCurrentEv);
    void sessionEnergyChanged(quint16 sessionEnergy);
    void sessionEnergyReadFinished(quint16 sessionEnergy);
    void safeCurrentChanged(quint16 safeCurrent);
    void safeCurrentReadFinished(quint16 safeCurrent);
    void comTimeoutChanged(quint16 comTimeout);
    void comTimeoutReadFinished(quint16 comTimeout);
    void chargePowerChanged(quint32 chargePower);
    void chargePowerReadFinished(quint32 chargePower);
    void chargeCurrentChanged(quint16 chargeCurrent);
    void chargeCurrentReadFinished(quint16 chargeCurrent);
    void chargingActionChanged(ChargingAction chargingAction);
    void chargingActionReadFinished(ChargingAction chargingAction);
    void lifeBitChanged(quint16 lifeBit);
    void lifeBitReadFinished(quint16 lifeBit);

    void chargerStateChanged(ChargerState chargerState);
    void chargerStateReadFinished(ChargerState chargerState);
    void chargeStateChanged(ChargeState chargeState);
    void chargeStateReadFinished(ChargeState chargeState);
    void evseStateChanged(EvseState evseState);
    void evseStateReadFinished(EvseState evseState);

protected:
    CableState m_cableState = CableStateNoCableAttached;
    quint16 m_evseErrorCode = CableStateNoCableAttached;
    quint16 m_currentL1 = 0;
    quint16 m_currentL2 = 0;
    quint16 m_currentL3 = 0;
    quint32 m_totalActivePower = 0;
    quint32 m_activePowerL1 = 0;
    quint32 m_activePowerL2 = 0;
    quint32 m_activePowerL3 = 0;
    quint32 m_energyConsumed = 0;
    quint16 m_maxChargingCurrent = 0;
    quint16 m_minChargingCurrent = 0;
    quint16 m_maxChargingCurrentStation = 0;
    quint16 m_maxChargingCurrentCable = 0;
    quint16 m_maxChargingCurrentEv = 0;
    quint16 m_sessionEnergy = 0;
    quint16 m_safeCurrent = 0;
    quint16 m_comTimeout = 0;
    quint32 m_chargePower = 0;
    quint16 m_chargeCurrent = 0;
    ChargingAction m_chargingAction = ChargingActionNoAction;
    quint16 m_lifeBit = 0;
    ChargerState m_chargerState = ChargerStateNoVehicle;
    ChargeState m_chargeState = ChargeStateIdle;
    EvseState m_evseState = EvseStateStarting;

    void processCableStateRegisterValues(const QVector<quint16> values);
    void processEvseErrorCodeRegisterValues(const QVector<quint16> values);
    void processCurrentL1RegisterValues(const QVector<quint16> values);
    void processCurrentL2RegisterValues(const QVector<quint16> values);
    void processCurrentL3RegisterValues(const QVector<quint16> values);
    void processTotalActivePowerRegisterValues(const QVector<quint16> values);
    void processActivePowerL1RegisterValues(const QVector<quint16> values);
    void processActivePowerL2RegisterValues(const QVector<quint16> values);
    void processActivePowerL3RegisterValues(const QVector<quint16> values);
    void processEnergyConsumedRegisterValues(const QVector<quint16> values);
    void processMaxChargingCurrentRegisterValues(const QVector<quint16> values);
    void processMinChargingCurrentRegisterValues(const QVector<quint16> values);
    void processMaxChargingCurrentStationRegisterValues(const QVector<quint16> values);
    void processMaxChargingCurrentCableRegisterValues(const QVector<quint16> values);
    void processMaxChargingCurrentEvRegisterValues(const QVector<quint16> values);
    void processSessionEnergyRegisterValues(const QVector<quint16> values);
    void processSafeCurrentRegisterValues(const QVector<quint16> values);
    void processComTimeoutRegisterValues(const QVector<quint16> values);
    void processChargePowerRegisterValues(const QVector<quint16> values);
    void processChargeCurrentRegisterValues(const QVector<quint16> values);
    void processChargingActionRegisterValues(const QVector<quint16> values);
    void processLifeBitRegisterValues(const QVector<quint16> values);

    void processChargerStateRegisterValues(const QVector<quint16> values);
    void processChargeStateRegisterValues(const QVector<quint16> values);
    void processEvseStateRegisterValues(const QVector<quint16> values);

    void handleModbusError(QModbusDevice::Error error);
    void testReachability();

private:
    ModbusDataUtils::ByteOrder m_endianness = ModbusDataUtils::ByteOrderBigEndian;
    quint16 m_slaveId = 1;

    bool m_reachable = false;
    QModbusReply *m_checkRechableReply = nullptr;
    uint m_checkReachableRetries = 0;
    uint m_checkReachableRetriesCount = 0;
    bool m_communicationWorking = false;
    quint8 m_communicationFailedMax = 10;
    quint8 m_communicationFailedCounter = 0;

    QVector<QModbusReply *> m_pendingInitReplies;
    QVector<QModbusReply *> m_pendingUpdateReplies;

    QObject *m_initObject = nullptr;
    void verifyInitFinished();
    void finishInitialization(bool success);

    void verifyUpdateFinished();

    void onReachabilityCheckFailed();
    void evaluateReachableState();

};

QDebug operator<<(QDebug debug, WebastoNextModbusTcpConnection *webastoNextModbusTcpConnection);

#endif // WEBASTONEXTMODBUSTCPCONNECTION_H
