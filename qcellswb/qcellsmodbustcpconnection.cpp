/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Copyright 2013 - 2024, nymea GmbH
* Contact: contact@nymea.io
*
* This fileDescriptor is part of nymea.
* This project including source code and documentation is protected by
* copyright law, and remains the property of nymea GmbH. All rights, including
* reproduction, publication, editing and translation, are reserved. The use of
* this project is subject to the terms of a license agreement to be concluded
* with nymea GmbH in accordance with the terms of use of nymea GmbH, available
* under https://nymea.io/license
*
* GNU Lesser General Public License Usage
* Alternatively, this project may be redistributed and/or modified under the
* terms of the GNU Lesser General Public License as published by the Free
* Software Foundation; version 3. This project is distributed in the hope that
* it will be useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this project. If not, see <https://www.gnu.org/licenses/>.
*
* For any further details and any questions please contact us under
* contact@nymea.io or see our FAQ/Licensing Information on
* https://nymea.io/license/faq
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WARNING
*
* This file has been autogenerated. Any changes in this file may be overwritten.
* If you want to change something, update the register json or the tool.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


#include "qcellsmodbustcpconnection.h"
#include <loggingcategories.h>
#include <math.h>
#include <QTimer>

NYMEA_LOGGING_CATEGORY(dcQCellsModbusTcpConnection, "QCellsModbusTcpConnection")

QCellsModbusTcpConnection::QCellsModbusTcpConnection(const QHostAddress &hostAddress, uint port, quint16 slaveId, QObject *parent) :
    ModbusTCPMaster(hostAddress, port, parent),
    m_slaveId(slaveId)
{
    connect(this, &ModbusTCPMaster::connectionStateChanged, this, [this](bool status){
        if (status) {
           qCDebug(dcQCellsModbusTcpConnection()) << "Modbus TCP connection" << m_hostAddress.toString() << "connected. Start testing if the connection is reachable...";
            // Cleanup before starting to initialize
            m_pendingInitReplies.clear();
            m_pendingUpdateReplies.clear();
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
            testReachability();
        } else {
            qCWarning(dcQCellsModbusTcpConnection()) << "Modbus TCP connection diconnected from" << m_hostAddress.toString() << ". The connection is not reachable any more.";
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
        }

        evaluateReachableState();
    });
}

bool QCellsModbusTcpConnection::reachable() const
{
    return m_reachable;
}

uint QCellsModbusTcpConnection::checkReachableRetries() const
{
    return m_checkReachableRetries;
}

void QCellsModbusTcpConnection::setCheckReachableRetries(uint checkReachableRetries)
{
    if (m_checkReachableRetries == checkReachableRetries)
        return;

    m_checkReachableRetries = checkReachableRetries;
    emit checkReachableRetriesChanged(m_checkReachableRetries);
}

ModbusDataUtils::ByteOrder QCellsModbusTcpConnection::endianness() const
{
    return m_endianness;
}

void QCellsModbusTcpConnection::setEndianness(ModbusDataUtils::ByteOrder endianness)
{
    if (m_endianness == endianness)
        return;

    m_endianness = endianness;
    emit endiannessChanged(m_endianness);
}

QModbusReply *QCellsModbusTcpConnection::setChargingControl(quint16 chargingControl)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(chargingControl);
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Write \"Control charing of the EVC (0x4001)\" register:" << 16385 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 16385, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint32 QCellsModbusTcpConnection::workMode() const
{
    return m_workMode;
}

QModbusReply *QCellsModbusTcpConnection::setWorkMode(quint32 workMode)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt32(workMode, m_endianness);
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Write \"Work Mode of the EVC (0x3000)\" register:" << 12288 << "size:" << 2 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 12288, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 QCellsModbusTcpConnection::firmwareVersion() const
{
    return m_firmwareVersion;
}

float QCellsModbusTcpConnection::maxSupportedPower() const
{
    return m_maxSupportedPower;
}

quint16 QCellsModbusTcpConnection::deviceAddress() const
{
    return m_deviceAddress;
}

quint16 QCellsModbusTcpConnection::firmwareVersionUnused() const
{
    return m_firmwareVersionUnused;
}

quint16 QCellsModbusTcpConnection::stopReason() const
{
    return m_stopReason;
}

QCellsModbusTcpConnection::EVCStatus QCellsModbusTcpConnection::deviceStatus() const
{
    return m_deviceStatus;
}

quint16 QCellsModbusTcpConnection::cpStatus() const
{
    return m_cpStatus;
}

quint16 QCellsModbusTcpConnection::plugStatus() const
{
    return m_plugStatus;
}

float QCellsModbusTcpConnection::cpTemperature() const
{
    return m_cpTemperature;
}

float QCellsModbusTcpConnection::envTemperature() const
{
    return m_envTemperature;
}

float QCellsModbusTcpConnection::voltagePhaseA() const
{
    return m_voltagePhaseA;
}

float QCellsModbusTcpConnection::voltagePhaseB() const
{
    return m_voltagePhaseB;
}

float QCellsModbusTcpConnection::voltagePhaseC() const
{
    return m_voltagePhaseC;
}

float QCellsModbusTcpConnection::currentPhaseA() const
{
    return m_currentPhaseA;
}

float QCellsModbusTcpConnection::currentPhaseB() const
{
    return m_currentPhaseB;
}

float QCellsModbusTcpConnection::currentPhaseC() const
{
    return m_currentPhaseC;
}

float QCellsModbusTcpConnection::currentPower() const
{
    return m_currentPower;
}

quint16 QCellsModbusTcpConnection::lockState() const
{
    return m_lockState;
}

quint16 QCellsModbusTcpConnection::chargePhase() const
{
    return m_chargePhase;
}

float QCellsModbusTcpConnection::maxSupportedPowerUnused() const
{
    return m_maxSupportedPowerUnused;
}

float QCellsModbusTcpConnection::minSupportedPower() const
{
    return m_minSupportedPower;
}

float QCellsModbusTcpConnection::maxSupportedCurrent() const
{
    return m_maxSupportedCurrent;
}

float QCellsModbusTcpConnection::minSupportedCurrent() const
{
    return m_minSupportedCurrent;
}

quint16 QCellsModbusTcpConnection::alarmInfo() const
{
    return m_alarmInfo;
}

float QCellsModbusTcpConnection::totalEnergy() const
{
    return m_totalEnergy;
}

float QCellsModbusTcpConnection::sessionEnergyConsumed() const
{
    return m_sessionEnergyConsumed;
}

quint32 QCellsModbusTcpConnection::faultInfo() const
{
    return m_faultInfo;
}

QString QCellsModbusTcpConnection::modelCode() const
{
    return m_modelCode;
}

QString QCellsModbusTcpConnection::serialNumber() const
{
    return m_serialNumber;
}

float QCellsModbusTcpConnection::maxChargeCurrent() const
{
    return m_maxChargeCurrent;
}

QModbusReply *QCellsModbusTcpConnection::setMaxChargeCurrent(float maxChargeCurrent)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(static_cast<quint16>(maxChargeCurrent  * 1.0 / pow(10, -1)));
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Write \"Maximum charging current of the EVC (0x3001)\" register:" << 12289 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 12289, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

float QCellsModbusTcpConnection::maxChargePower() const
{
    return m_maxChargePower;
}

QModbusReply *QCellsModbusTcpConnection::setMaxChargePower(float maxChargePower)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(static_cast<quint16>(maxChargePower  * 1.0 / pow(10, -1)));
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Write \"Maximum charging power of the EVC (0x3002)\" register:" << 12290 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 12290, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 QCellsModbusTcpConnection::maxChargeTime() const
{
    return m_maxChargeTime;
}

QModbusReply *QCellsModbusTcpConnection::setMaxChargeTime(quint16 maxChargeTime)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(maxChargeTime);
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Write \"Maximum charge time (minutes) of the EVC (0x3003)\" register:" << 12291 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 12291, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 QCellsModbusTcpConnection::maxChargeEnergy() const
{
    return m_maxChargeEnergy;
}

QModbusReply *QCellsModbusTcpConnection::setMaxChargeEnergy(quint16 maxChargeEnergy)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(maxChargeEnergy);
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Write \"Maximum charge energy of the EVC (0x3004)\" register:" << 12292 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 12292, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

quint16 QCellsModbusTcpConnection::timeValidity() const
{
    return m_timeValidity;
}

QModbusReply *QCellsModbusTcpConnection::setTimeValidity(quint16 timeValidity)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(timeValidity);
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Write \"Maximum charge time (minutes) of the EVC (0x3005)\" register:" << 12293 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 12293, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

float QCellsModbusTcpConnection::defaultCurrent() const
{
    return m_defaultCurrent;
}

QModbusReply *QCellsModbusTcpConnection::setDefaultCurrent(float defaultCurrent)
{
    QVector<quint16> values = ModbusDataUtils::convertFromUInt16(static_cast<quint16>(defaultCurrent  * 1.0 / pow(10, -1)));
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Write \"Default charging current of the EVC (0x3006)\" register:" << 12294 << "size:" << 1 << values;
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 12294, values.count());
    request.setValues(values);
    return sendWriteRequest(request, m_slaveId);
}

bool QCellsModbusTcpConnection::initialize()
{
    if (!m_reachable) {
        qCWarning(dcQCellsModbusTcpConnection()) << "Tried to initialize but the device is not to be reachable.";
        return false;
    }
    if (m_initObject) {
        qCWarning(dcQCellsModbusTcpConnection()) << "Tried to initialize but the init process is already running.";
        return false;
    }

    // Parent object for the init process
    m_initObject = new QObject(this);

    QModbusReply *reply = nullptr;

    // Read Software version of EVC (0x1001)
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Read init \"Software version of EVC (0x1001)\" register:" << 4097 << "size:" << 1;
    reply = readFirmwareVersion();
    if (!reply) {
        qCWarning(dcQCellsModbusTcpConnection()) << "Error occurred while reading \"Software version of EVC (0x1001)\" registers from" << hostAddress().toString() << errorString();
        finishInitialization(false);
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, m_initObject, [this, reply](){
        handleModbusError(reply->error());
        m_pendingInitReplies.removeAll(reply);
        if (reply->error() != QModbusDevice::NoError) {
            finishInitialization(false);
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcQCellsModbusTcpConnection()) << "<-- Response from init \"Software version of EVC (0x1001)\" register" << 4097 << "size:" << 1 << unit.values();
        processFirmwareVersionRegisterValues(unit.values());
        initialize1();
    });

    connect(reply, &QModbusReply::errorOccurred, m_initObject, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcQCellsModbusTcpConnection()) << "Modbus reply error occurred while reading \"Software version of EVC (0x1001)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    return true;
}

void QCellsModbusTcpConnection::initialize1()
{
    QModbusReply *reply = nullptr;

    // Read Maximum supported power of the EVC (0x1011)
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Read init \"Maximum supported power of the EVC (0x1011)\" register:" << 4113 << "size:" << 1;
    reply = readMaxSupportedPower();
    if (!reply) {
        qCWarning(dcQCellsModbusTcpConnection()) << "Error occurred while reading \"Maximum supported power of the EVC (0x1011)\" registers from" << hostAddress().toString() << errorString();
        finishInitialization(false);
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, m_initObject, [this, reply](){
        handleModbusError(reply->error());
        m_pendingInitReplies.removeAll(reply);
        if (reply->error() != QModbusDevice::NoError) {
            finishInitialization(false);
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcQCellsModbusTcpConnection()) << "<-- Response from init \"Maximum supported power of the EVC (0x1011)\" register" << 4113 << "size:" << 1 << unit.values();
        processMaxSupportedPowerRegisterValues(unit.values());
        initialize2();
    });

    connect(reply, &QModbusReply::errorOccurred, m_initObject, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcQCellsModbusTcpConnection()) << "Modbus reply error occurred while reading \"Maximum supported power of the EVC (0x1011)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void QCellsModbusTcpConnection::initialize2()
{
    QModbusReply *reply = nullptr;

    // Read systemInfo
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Read init block \"systemInfo\" registers from:" << 4126 << "size:" << 20;
    reply = readBlockSystemInfo();
    if (!reply) {
        qCWarning(dcQCellsModbusTcpConnection()) << "Error occurred while reading block \"systemInfo\" registers";
        finishInitialization(false);
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, m_initObject, [this, reply](){
        m_pendingInitReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            finishInitialization(false);
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcQCellsModbusTcpConnection()) << "<-- Response from reading init block \"systemInfo\" register" << 4126 << "size:" << 20 << blockValues;
        processModelCodeRegisterValues(blockValues.mid(0, 4));
        processSerialNumberRegisterValues(blockValues.mid(4, 16));
        verifyInitFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, m_initObject, [reply] (QModbusDevice::Error error){
        qCWarning(dcQCellsModbusTcpConnection()) << "Modbus reply error occurred while updating block \"systemInfo\" registers" << error << reply->errorString();
    });
}

bool QCellsModbusTcpConnection::update()
{
    if (!connected())
        return false;

    if (!m_pendingUpdateReplies.isEmpty()) {
        qCDebug(dcQCellsModbusTcpConnection()) << "Tried to update but there are still some update replies pending. Waiting for them to be finished...";
        return true;
    }

    QModbusReply *reply = nullptr;

    // Read Work Mode of the EVC (0x3000)
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Read \"Work Mode of the EVC (0x3000)\" register:" << 12288 << "size:" << 2;
    reply = readWorkMode();
    if (!reply) {
        qCWarning(dcQCellsModbusTcpConnection()) << "Error occurred while reading \"Work Mode of the EVC (0x3000)\" registers from" << hostAddress().toString() << errorString();
        return false;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        qCDebug(dcQCellsModbusTcpConnection()) << "<-- Response from \"Work Mode of the EVC (0x3000)\" register" << 12288 << "size:" << 2 << unit.values();
        processWorkModeRegisterValues(unit.values());
        update1();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcQCellsModbusTcpConnection()) << "Modbus reply error occurred while reading \"Work Mode of the EVC (0x3000)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });

    return true;
}

void QCellsModbusTcpConnection::update1()
{
    QModbusReply *reply = nullptr;

    // Read chargingInfo
    reply = readBlockChargingInfo();
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Read block \"chargingInfo\" registers from:" << 4096 << "size:" << 28;
    if (!reply) {
        qCWarning(dcQCellsModbusTcpConnection()) << "Error occurred while reading block \"chargingInfo\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcQCellsModbusTcpConnection()) << "<-- Response from reading block \"chargingInfo\" register" << 4096 << "size:" << 28 << blockValues;
        processDeviceAddressRegisterValues(blockValues.mid(0, 1));
        processFirmwareVersionUnusedRegisterValues(blockValues.mid(1, 1));
        processStopReasonRegisterValues(blockValues.mid(2, 1));
        processDeviceStatusRegisterValues(blockValues.mid(3, 1));
        processCpStatusRegisterValues(blockValues.mid(4, 1));
        processPlugStatusRegisterValues(blockValues.mid(5, 1));
        processCpTemperatureRegisterValues(blockValues.mid(6, 1));
        processEnvTemperatureRegisterValues(blockValues.mid(7, 1));
        processVoltagePhaseARegisterValues(blockValues.mid(8, 1));
        processVoltagePhaseBRegisterValues(blockValues.mid(9, 1));
        processVoltagePhaseCRegisterValues(blockValues.mid(10, 1));
        processCurrentPhaseARegisterValues(blockValues.mid(11, 1));
        processCurrentPhaseBRegisterValues(blockValues.mid(12, 1));
        processCurrentPhaseCRegisterValues(blockValues.mid(13, 1));
        processCurrentPowerRegisterValues(blockValues.mid(14, 1));
        processLockStateRegisterValues(blockValues.mid(15, 1));
        processChargePhaseRegisterValues(blockValues.mid(16, 1));
        processMaxSupportedPowerUnusedRegisterValues(blockValues.mid(17, 1));
        processMinSupportedPowerRegisterValues(blockValues.mid(18, 1));
        processMaxSupportedCurrentRegisterValues(blockValues.mid(19, 1));
        processMinSupportedCurrentRegisterValues(blockValues.mid(20, 1));
        processAlarmInfoRegisterValues(blockValues.mid(21, 1));
        processTotalEnergyRegisterValues(blockValues.mid(22, 2));
        processSessionEnergyConsumedRegisterValues(blockValues.mid(24, 2));
        processFaultInfoRegisterValues(blockValues.mid(26, 2));
        update2();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcQCellsModbusTcpConnection()) << "Modbus reply error occurred while updating block \"chargingInfo\" registers" << error << reply->errorString();
    });
}

void QCellsModbusTcpConnection::update2()
{
    QModbusReply *reply = nullptr;

    // Read chargeSettings
    reply = readBlockChargeSettings();
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Read block \"chargeSettings\" registers from:" << 12289 << "size:" << 6;
    if (!reply) {
        qCWarning(dcQCellsModbusTcpConnection()) << "Error occurred while reading block \"chargeSettings\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        m_pendingUpdateReplies.removeAll(reply);
        handleModbusError(reply->error());
        if (reply->error() != QModbusDevice::NoError) {
            verifyUpdateFinished();
            return;
        }

        const QModbusDataUnit unit = reply->result();
        const QVector<quint16> blockValues = unit.values();
        qCDebug(dcQCellsModbusTcpConnection()) << "<-- Response from reading block \"chargeSettings\" register" << 12289 << "size:" << 6 << blockValues;
        processMaxChargeCurrentRegisterValues(blockValues.mid(0, 1));
        processMaxChargePowerRegisterValues(blockValues.mid(1, 1));
        processMaxChargeTimeRegisterValues(blockValues.mid(2, 1));
        processMaxChargeEnergyRegisterValues(blockValues.mid(3, 1));
        processTimeValidityRegisterValues(blockValues.mid(4, 1));
        processDefaultCurrentRegisterValues(blockValues.mid(5, 1));
        verifyUpdateFinished();
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcQCellsModbusTcpConnection()) << "Modbus reply error occurred while updating block \"chargeSettings\" registers" << error << reply->errorString();
    });
}

void QCellsModbusTcpConnection::updateWorkMode()
{
    // Update registers from Work Mode of the EVC (0x3000)
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Read \"Work Mode of the EVC (0x3000)\" register:" << 12288 << "size:" << 2;
    QModbusReply *reply = readWorkMode();
    if (!reply) {
        qCWarning(dcQCellsModbusTcpConnection()) << "Error occurred while reading \"Work Mode of the EVC (0x3000)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcQCellsModbusTcpConnection()) << "<-- Response from \"Work Mode of the EVC (0x3000)\" register" << 12288 << "size:" << 2 << unit.values();
            processWorkModeRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcQCellsModbusTcpConnection()) << "Modbus reply error occurred while updating \"Work Mode of the EVC (0x3000)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void QCellsModbusTcpConnection::updateMaxChargeCurrent()
{
    // Update registers from Maximum charging current of the EVC (0x3001)
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Read \"Maximum charging current of the EVC (0x3001)\" register:" << 12289 << "size:" << 1;
    QModbusReply *reply = readMaxChargeCurrent();
    if (!reply) {
        qCWarning(dcQCellsModbusTcpConnection()) << "Error occurred while reading \"Maximum charging current of the EVC (0x3001)\" registers from" << hostAddress().toString() << errorString();
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            qCDebug(dcQCellsModbusTcpConnection()) << "<-- Response from \"Maximum charging current of the EVC (0x3001)\" register" << 12289 << "size:" << 1 << unit.values();
            processMaxChargeCurrentRegisterValues(unit.values());
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [this, reply] (QModbusDevice::Error error){
        qCWarning(dcQCellsModbusTcpConnection()) << "Modbus reply error occurred while updating \"Maximum charging current of the EVC (0x3001)\" registers from" << hostAddress().toString() << error << reply->errorString();
    });
}

void QCellsModbusTcpConnection::updateChargingInfoBlock()
{
    // Update register block "chargingInfo"
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Read block \"chargingInfo\" registers from:" << 4096 << "size:" << 28;
    QModbusReply *reply = readBlockChargingInfo();
    if (!reply) {
        qCWarning(dcQCellsModbusTcpConnection()) << "Error occurred while reading block \"chargingInfo\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcQCellsModbusTcpConnection()) << "<-- Response from reading block \"chargingInfo\" register" << 4096 << "size:" << 28 << blockValues;
            processDeviceAddressRegisterValues(blockValues.mid(0, 1));
            processFirmwareVersionUnusedRegisterValues(blockValues.mid(1, 1));
            processStopReasonRegisterValues(blockValues.mid(2, 1));
            processDeviceStatusRegisterValues(blockValues.mid(3, 1));
            processCpStatusRegisterValues(blockValues.mid(4, 1));
            processPlugStatusRegisterValues(blockValues.mid(5, 1));
            processCpTemperatureRegisterValues(blockValues.mid(6, 1));
            processEnvTemperatureRegisterValues(blockValues.mid(7, 1));
            processVoltagePhaseARegisterValues(blockValues.mid(8, 1));
            processVoltagePhaseBRegisterValues(blockValues.mid(9, 1));
            processVoltagePhaseCRegisterValues(blockValues.mid(10, 1));
            processCurrentPhaseARegisterValues(blockValues.mid(11, 1));
            processCurrentPhaseBRegisterValues(blockValues.mid(12, 1));
            processCurrentPhaseCRegisterValues(blockValues.mid(13, 1));
            processCurrentPowerRegisterValues(blockValues.mid(14, 1));
            processLockStateRegisterValues(blockValues.mid(15, 1));
            processChargePhaseRegisterValues(blockValues.mid(16, 1));
            processMaxSupportedPowerUnusedRegisterValues(blockValues.mid(17, 1));
            processMinSupportedPowerRegisterValues(blockValues.mid(18, 1));
            processMaxSupportedCurrentRegisterValues(blockValues.mid(19, 1));
            processMinSupportedCurrentRegisterValues(blockValues.mid(20, 1));
            processAlarmInfoRegisterValues(blockValues.mid(21, 1));
            processTotalEnergyRegisterValues(blockValues.mid(22, 2));
            processSessionEnergyConsumedRegisterValues(blockValues.mid(24, 2));
            processFaultInfoRegisterValues(blockValues.mid(26, 2));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcQCellsModbusTcpConnection()) << "Modbus reply error occurred while updating block \"chargingInfo\" registers" << error << reply->errorString();
    });
}

void QCellsModbusTcpConnection::updateSystemInfoBlock()
{
    // Update register block "systemInfo"
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Read block \"systemInfo\" registers from:" << 4126 << "size:" << 20;
    QModbusReply *reply = readBlockSystemInfo();
    if (!reply) {
        qCWarning(dcQCellsModbusTcpConnection()) << "Error occurred while reading block \"systemInfo\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcQCellsModbusTcpConnection()) << "<-- Response from reading block \"systemInfo\" register" << 4126 << "size:" << 20 << blockValues;
            processModelCodeRegisterValues(blockValues.mid(0, 4));
            processSerialNumberRegisterValues(blockValues.mid(4, 16));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcQCellsModbusTcpConnection()) << "Modbus reply error occurred while updating block \"systemInfo\" registers" << error << reply->errorString();
    });
}

void QCellsModbusTcpConnection::updateChargeSettingsBlock()
{
    // Update register block "chargeSettings"
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Read block \"chargeSettings\" registers from:" << 12289 << "size:" << 6;
    QModbusReply *reply = readBlockChargeSettings();
    if (!reply) {
        qCWarning(dcQCellsModbusTcpConnection()) << "Error occurred while reading block \"chargeSettings\" registers";
        return;
    }

    if (reply->isFinished()) {
        reply->deleteLater(); // Broadcast reply returns immediatly
        return;
    }

    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);
    connect(reply, &QModbusReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        if (reply->error() == QModbusDevice::NoError) {
            const QModbusDataUnit unit = reply->result();
            const QVector<quint16> blockValues = unit.values();
            qCDebug(dcQCellsModbusTcpConnection()) << "<-- Response from reading block \"chargeSettings\" register" << 12289 << "size:" << 6 << blockValues;
            processMaxChargeCurrentRegisterValues(blockValues.mid(0, 1));
            processMaxChargePowerRegisterValues(blockValues.mid(1, 1));
            processMaxChargeTimeRegisterValues(blockValues.mid(2, 1));
            processMaxChargeEnergyRegisterValues(blockValues.mid(3, 1));
            processTimeValidityRegisterValues(blockValues.mid(4, 1));
            processDefaultCurrentRegisterValues(blockValues.mid(5, 1));
        }
    });

    connect(reply, &QModbusReply::errorOccurred, this, [reply] (QModbusDevice::Error error){
        qCWarning(dcQCellsModbusTcpConnection()) << "Modbus reply error occurred while updating block \"chargeSettings\" registers" << error << reply->errorString();
    });
}

QModbusReply *QCellsModbusTcpConnection::readWorkMode()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 12288, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readFirmwareVersion()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4097, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readMaxSupportedPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4113, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readDeviceAddress()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4096, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readFirmwareVersionUnused()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4097, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readStopReason()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4098, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readDeviceStatus()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4099, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readCpStatus()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4100, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readPlugStatus()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4101, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readCpTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4102, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readEnvTemperature()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4103, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readVoltagePhaseA()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4104, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readVoltagePhaseB()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4105, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readVoltagePhaseC()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4106, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readCurrentPhaseA()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4107, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readCurrentPhaseB()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4108, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readCurrentPhaseC()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4109, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readCurrentPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4110, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readLockState()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4111, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readChargePhase()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4112, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readMaxSupportedPowerUnused()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4113, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readMinSupportedPower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4114, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readMaxSupportedCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4115, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readMinSupportedCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4116, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readAlarmInfo()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4117, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readTotalEnergy()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4118, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readSessionEnergyConsumed()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4120, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readFaultInfo()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4122, 2);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readModelCode()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4126, 4);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readSerialNumber()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4130, 16);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readMaxChargeCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 12289, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readMaxChargePower()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 12290, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readMaxChargeTime()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 12291, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readMaxChargeEnergy()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 12292, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readTimeValidity()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 12293, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readDefaultCurrent()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 12294, 1);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readBlockChargingInfo()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4096, 28);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readBlockSystemInfo()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 4126, 20);
    return sendReadRequest(request, m_slaveId);
}

QModbusReply *QCellsModbusTcpConnection::readBlockChargeSettings()
{
    QModbusDataUnit request = QModbusDataUnit(QModbusDataUnit::RegisterType::HoldingRegisters, 12289, 6);
    return sendReadRequest(request, m_slaveId);
}

void QCellsModbusTcpConnection::processWorkModeRegisterValues(const QVector<quint16> values)
{
    quint32 receivedWorkMode = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit workModeReadFinished(receivedWorkMode);

    if (m_workMode != receivedWorkMode) {
        m_workMode = receivedWorkMode;
        emit workModeChanged(m_workMode);
    }
}

void QCellsModbusTcpConnection::processFirmwareVersionRegisterValues(const QVector<quint16> values)
{
    quint16 receivedFirmwareVersion = ModbusDataUtils::convertToUInt16(values);
    emit firmwareVersionReadFinished(receivedFirmwareVersion);

    if (m_firmwareVersion != receivedFirmwareVersion) {
        m_firmwareVersion = receivedFirmwareVersion;
        emit firmwareVersionChanged(m_firmwareVersion);
    }
}

void QCellsModbusTcpConnection::processMaxSupportedPowerRegisterValues(const QVector<quint16> values)
{
    float receivedMaxSupportedPower = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit maxSupportedPowerReadFinished(receivedMaxSupportedPower);

    if (m_maxSupportedPower != receivedMaxSupportedPower) {
        m_maxSupportedPower = receivedMaxSupportedPower;
        emit maxSupportedPowerChanged(m_maxSupportedPower);
    }
}

void QCellsModbusTcpConnection::processDeviceAddressRegisterValues(const QVector<quint16> values)
{
    quint16 receivedDeviceAddress = ModbusDataUtils::convertToUInt16(values);
    emit deviceAddressReadFinished(receivedDeviceAddress);

    if (m_deviceAddress != receivedDeviceAddress) {
        m_deviceAddress = receivedDeviceAddress;
        emit deviceAddressChanged(m_deviceAddress);
    }
}

void QCellsModbusTcpConnection::processFirmwareVersionUnusedRegisterValues(const QVector<quint16> values)
{
    quint16 receivedFirmwareVersionUnused = ModbusDataUtils::convertToUInt16(values);
    emit firmwareVersionUnusedReadFinished(receivedFirmwareVersionUnused);

    if (m_firmwareVersionUnused != receivedFirmwareVersionUnused) {
        m_firmwareVersionUnused = receivedFirmwareVersionUnused;
        emit firmwareVersionUnusedChanged(m_firmwareVersionUnused);
    }
}

void QCellsModbusTcpConnection::processStopReasonRegisterValues(const QVector<quint16> values)
{
    quint16 receivedStopReason = ModbusDataUtils::convertToUInt16(values);
    emit stopReasonReadFinished(receivedStopReason);

    if (m_stopReason != receivedStopReason) {
        m_stopReason = receivedStopReason;
        emit stopReasonChanged(m_stopReason);
    }
}

void QCellsModbusTcpConnection::processDeviceStatusRegisterValues(const QVector<quint16> values)
{
    EVCStatus receivedDeviceStatus = static_cast<EVCStatus>(ModbusDataUtils::convertToUInt16(values));
    emit deviceStatusReadFinished(receivedDeviceStatus);

    if (m_deviceStatus != receivedDeviceStatus) {
        m_deviceStatus = receivedDeviceStatus;
        emit deviceStatusChanged(m_deviceStatus);
    }
}

void QCellsModbusTcpConnection::processCpStatusRegisterValues(const QVector<quint16> values)
{
    quint16 receivedCpStatus = ModbusDataUtils::convertToUInt16(values);
    emit cpStatusReadFinished(receivedCpStatus);

    if (m_cpStatus != receivedCpStatus) {
        m_cpStatus = receivedCpStatus;
        emit cpStatusChanged(m_cpStatus);
    }
}

void QCellsModbusTcpConnection::processPlugStatusRegisterValues(const QVector<quint16> values)
{
    quint16 receivedPlugStatus = ModbusDataUtils::convertToUInt16(values);
    emit plugStatusReadFinished(receivedPlugStatus);

    if (m_plugStatus != receivedPlugStatus) {
        m_plugStatus = receivedPlugStatus;
        emit plugStatusChanged(m_plugStatus);
    }
}

void QCellsModbusTcpConnection::processCpTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedCpTemperature = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit cpTemperatureReadFinished(receivedCpTemperature);

    if (m_cpTemperature != receivedCpTemperature) {
        m_cpTemperature = receivedCpTemperature;
        emit cpTemperatureChanged(m_cpTemperature);
    }
}

void QCellsModbusTcpConnection::processEnvTemperatureRegisterValues(const QVector<quint16> values)
{
    float receivedEnvTemperature = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit envTemperatureReadFinished(receivedEnvTemperature);

    if (m_envTemperature != receivedEnvTemperature) {
        m_envTemperature = receivedEnvTemperature;
        emit envTemperatureChanged(m_envTemperature);
    }
}

void QCellsModbusTcpConnection::processVoltagePhaseARegisterValues(const QVector<quint16> values)
{
    float receivedVoltagePhaseA = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit voltagePhaseAReadFinished(receivedVoltagePhaseA);

    if (m_voltagePhaseA != receivedVoltagePhaseA) {
        m_voltagePhaseA = receivedVoltagePhaseA;
        emit voltagePhaseAChanged(m_voltagePhaseA);
    }
}

void QCellsModbusTcpConnection::processVoltagePhaseBRegisterValues(const QVector<quint16> values)
{
    float receivedVoltagePhaseB = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit voltagePhaseBReadFinished(receivedVoltagePhaseB);

    if (m_voltagePhaseB != receivedVoltagePhaseB) {
        m_voltagePhaseB = receivedVoltagePhaseB;
        emit voltagePhaseBChanged(m_voltagePhaseB);
    }
}

void QCellsModbusTcpConnection::processVoltagePhaseCRegisterValues(const QVector<quint16> values)
{
    float receivedVoltagePhaseC = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit voltagePhaseCReadFinished(receivedVoltagePhaseC);

    if (m_voltagePhaseC != receivedVoltagePhaseC) {
        m_voltagePhaseC = receivedVoltagePhaseC;
        emit voltagePhaseCChanged(m_voltagePhaseC);
    }
}

void QCellsModbusTcpConnection::processCurrentPhaseARegisterValues(const QVector<quint16> values)
{
    float receivedCurrentPhaseA = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit currentPhaseAReadFinished(receivedCurrentPhaseA);

    if (m_currentPhaseA != receivedCurrentPhaseA) {
        m_currentPhaseA = receivedCurrentPhaseA;
        emit currentPhaseAChanged(m_currentPhaseA);
    }
}

void QCellsModbusTcpConnection::processCurrentPhaseBRegisterValues(const QVector<quint16> values)
{
    float receivedCurrentPhaseB = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit currentPhaseBReadFinished(receivedCurrentPhaseB);

    if (m_currentPhaseB != receivedCurrentPhaseB) {
        m_currentPhaseB = receivedCurrentPhaseB;
        emit currentPhaseBChanged(m_currentPhaseB);
    }
}

void QCellsModbusTcpConnection::processCurrentPhaseCRegisterValues(const QVector<quint16> values)
{
    float receivedCurrentPhaseC = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit currentPhaseCReadFinished(receivedCurrentPhaseC);

    if (m_currentPhaseC != receivedCurrentPhaseC) {
        m_currentPhaseC = receivedCurrentPhaseC;
        emit currentPhaseCChanged(m_currentPhaseC);
    }
}

void QCellsModbusTcpConnection::processCurrentPowerRegisterValues(const QVector<quint16> values)
{
    float receivedCurrentPower = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit currentPowerReadFinished(receivedCurrentPower);

    if (m_currentPower != receivedCurrentPower) {
        m_currentPower = receivedCurrentPower;
        emit currentPowerChanged(m_currentPower);
    }
}

void QCellsModbusTcpConnection::processLockStateRegisterValues(const QVector<quint16> values)
{
    quint16 receivedLockState = ModbusDataUtils::convertToUInt16(values);
    emit lockStateReadFinished(receivedLockState);

    if (m_lockState != receivedLockState) {
        m_lockState = receivedLockState;
        emit lockStateChanged(m_lockState);
    }
}

void QCellsModbusTcpConnection::processChargePhaseRegisterValues(const QVector<quint16> values)
{
    quint16 receivedChargePhase = ModbusDataUtils::convertToUInt16(values);
    emit chargePhaseReadFinished(receivedChargePhase);

    if (m_chargePhase != receivedChargePhase) {
        m_chargePhase = receivedChargePhase;
        emit chargePhaseChanged(m_chargePhase);
    }
}

void QCellsModbusTcpConnection::processMaxSupportedPowerUnusedRegisterValues(const QVector<quint16> values)
{
    float receivedMaxSupportedPowerUnused = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit maxSupportedPowerUnusedReadFinished(receivedMaxSupportedPowerUnused);

    if (m_maxSupportedPowerUnused != receivedMaxSupportedPowerUnused) {
        m_maxSupportedPowerUnused = receivedMaxSupportedPowerUnused;
        emit maxSupportedPowerUnusedChanged(m_maxSupportedPowerUnused);
    }
}

void QCellsModbusTcpConnection::processMinSupportedPowerRegisterValues(const QVector<quint16> values)
{
    float receivedMinSupportedPower = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit minSupportedPowerReadFinished(receivedMinSupportedPower);

    if (m_minSupportedPower != receivedMinSupportedPower) {
        m_minSupportedPower = receivedMinSupportedPower;
        emit minSupportedPowerChanged(m_minSupportedPower);
    }
}

void QCellsModbusTcpConnection::processMaxSupportedCurrentRegisterValues(const QVector<quint16> values)
{
    float receivedMaxSupportedCurrent = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit maxSupportedCurrentReadFinished(receivedMaxSupportedCurrent);

    if (m_maxSupportedCurrent != receivedMaxSupportedCurrent) {
        m_maxSupportedCurrent = receivedMaxSupportedCurrent;
        emit maxSupportedCurrentChanged(m_maxSupportedCurrent);
    }
}

void QCellsModbusTcpConnection::processMinSupportedCurrentRegisterValues(const QVector<quint16> values)
{
    float receivedMinSupportedCurrent = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit minSupportedCurrentReadFinished(receivedMinSupportedCurrent);

    if (m_minSupportedCurrent != receivedMinSupportedCurrent) {
        m_minSupportedCurrent = receivedMinSupportedCurrent;
        emit minSupportedCurrentChanged(m_minSupportedCurrent);
    }
}

void QCellsModbusTcpConnection::processAlarmInfoRegisterValues(const QVector<quint16> values)
{
    quint16 receivedAlarmInfo = ModbusDataUtils::convertToUInt16(values);
    emit alarmInfoReadFinished(receivedAlarmInfo);

    if (m_alarmInfo != receivedAlarmInfo) {
        m_alarmInfo = receivedAlarmInfo;
        emit alarmInfoChanged(m_alarmInfo);
    }
}

void QCellsModbusTcpConnection::processTotalEnergyRegisterValues(const QVector<quint16> values)
{
    float receivedTotalEnergy = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -1);
    emit totalEnergyReadFinished(receivedTotalEnergy);

    if (m_totalEnergy != receivedTotalEnergy) {
        m_totalEnergy = receivedTotalEnergy;
        emit totalEnergyChanged(m_totalEnergy);
    }
}

void QCellsModbusTcpConnection::processSessionEnergyConsumedRegisterValues(const QVector<quint16> values)
{
    float receivedSessionEnergyConsumed = ModbusDataUtils::convertToUInt32(values, m_endianness) * 1.0 * pow(10, -1);
    emit sessionEnergyConsumedReadFinished(receivedSessionEnergyConsumed);

    if (m_sessionEnergyConsumed != receivedSessionEnergyConsumed) {
        m_sessionEnergyConsumed = receivedSessionEnergyConsumed;
        emit sessionEnergyConsumedChanged(m_sessionEnergyConsumed);
    }
}

void QCellsModbusTcpConnection::processFaultInfoRegisterValues(const QVector<quint16> values)
{
    quint32 receivedFaultInfo = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit faultInfoReadFinished(receivedFaultInfo);

    if (m_faultInfo != receivedFaultInfo) {
        m_faultInfo = receivedFaultInfo;
        emit faultInfoChanged(m_faultInfo);
    }
}

void QCellsModbusTcpConnection::processModelCodeRegisterValues(const QVector<quint16> values)
{
    QString receivedModelCode = ModbusDataUtils::convertToString(values);
    emit modelCodeReadFinished(receivedModelCode);

    if (m_modelCode != receivedModelCode) {
        m_modelCode = receivedModelCode;
        emit modelCodeChanged(m_modelCode);
    }
}

void QCellsModbusTcpConnection::processSerialNumberRegisterValues(const QVector<quint16> values)
{
    QString receivedSerialNumber = ModbusDataUtils::convertToString(values);
    emit serialNumberReadFinished(receivedSerialNumber);

    if (m_serialNumber != receivedSerialNumber) {
        m_serialNumber = receivedSerialNumber;
        emit serialNumberChanged(m_serialNumber);
    }
}

void QCellsModbusTcpConnection::processMaxChargeCurrentRegisterValues(const QVector<quint16> values)
{
    float receivedMaxChargeCurrent = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit maxChargeCurrentReadFinished(receivedMaxChargeCurrent);

    if (m_maxChargeCurrent != receivedMaxChargeCurrent) {
        m_maxChargeCurrent = receivedMaxChargeCurrent;
        emit maxChargeCurrentChanged(m_maxChargeCurrent);
    }
}

void QCellsModbusTcpConnection::processMaxChargePowerRegisterValues(const QVector<quint16> values)
{
    float receivedMaxChargePower = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit maxChargePowerReadFinished(receivedMaxChargePower);

    if (m_maxChargePower != receivedMaxChargePower) {
        m_maxChargePower = receivedMaxChargePower;
        emit maxChargePowerChanged(m_maxChargePower);
    }
}

void QCellsModbusTcpConnection::processMaxChargeTimeRegisterValues(const QVector<quint16> values)
{
    quint16 receivedMaxChargeTime = ModbusDataUtils::convertToUInt16(values);
    emit maxChargeTimeReadFinished(receivedMaxChargeTime);

    if (m_maxChargeTime != receivedMaxChargeTime) {
        m_maxChargeTime = receivedMaxChargeTime;
        emit maxChargeTimeChanged(m_maxChargeTime);
    }
}

void QCellsModbusTcpConnection::processMaxChargeEnergyRegisterValues(const QVector<quint16> values)
{
    quint16 receivedMaxChargeEnergy = ModbusDataUtils::convertToUInt16(values);
    emit maxChargeEnergyReadFinished(receivedMaxChargeEnergy);

    if (m_maxChargeEnergy != receivedMaxChargeEnergy) {
        m_maxChargeEnergy = receivedMaxChargeEnergy;
        emit maxChargeEnergyChanged(m_maxChargeEnergy);
    }
}

void QCellsModbusTcpConnection::processTimeValidityRegisterValues(const QVector<quint16> values)
{
    quint16 receivedTimeValidity = ModbusDataUtils::convertToUInt16(values);
    emit timeValidityReadFinished(receivedTimeValidity);

    if (m_timeValidity != receivedTimeValidity) {
        m_timeValidity = receivedTimeValidity;
        emit timeValidityChanged(m_timeValidity);
    }
}

void QCellsModbusTcpConnection::processDefaultCurrentRegisterValues(const QVector<quint16> values)
{
    float receivedDefaultCurrent = ModbusDataUtils::convertToUInt16(values) * 1.0 * pow(10, -1);
    emit defaultCurrentReadFinished(receivedDefaultCurrent);

    if (m_defaultCurrent != receivedDefaultCurrent) {
        m_defaultCurrent = receivedDefaultCurrent;
        emit defaultCurrentChanged(m_defaultCurrent);
    }
}

void QCellsModbusTcpConnection::handleModbusError(QModbusDevice::Error error)
{
    if (error == QModbusDevice::NoError) {
        // Reset the communication counter and we know we can reach the device
        m_communicationFailedCounter = 0;
        if (!m_communicationWorking)
            qCDebug(dcQCellsModbusTcpConnection()) << "Received a reply without any errors. The communication with the device seems to work now.";

        m_communicationWorking = true;
        evaluateReachableState();
    } else {
        m_communicationFailedCounter++;
        if (m_communicationWorking && m_communicationFailedCounter >= m_communicationFailedMax) {
            m_communicationWorking = false;
            qCWarning(dcQCellsModbusTcpConnection()) << "Received" << m_communicationFailedCounter << "errors while communicating with the RTU master. Mark as not reachable until the communication works again.";
            evaluateReachableState();
        }
    }
}

void QCellsModbusTcpConnection::testReachability()
{
    if (m_checkRechableReply)
        return;

    // Try to read the check reachability register deviceAddress in order to verify if the communication is working or not.
    qCDebug(dcQCellsModbusTcpConnection()) << "--> Test reachability by reading \"Modbus Address of the EVC (0x1000)\" register:" << 4096 << "size:" << 1;
    m_checkRechableReply = readDeviceAddress();
    if (!m_checkRechableReply) {
        qCDebug(dcQCellsModbusTcpConnection()) << "Error occurred verifying reachability by reading \"Modbus Address of the EVC (0x1000)\" register";
        onReachabilityCheckFailed();
        return;
    }

    if (m_checkRechableReply->isFinished()) {
        m_checkRechableReply->deleteLater(); // Broadcast reply returns immediatly
        m_checkRechableReply = nullptr;
        onReachabilityCheckFailed();
        return;
    }

    connect(m_checkRechableReply, &QModbusReply::finished, this, [this](){
        handleModbusError(m_checkRechableReply->error());
        if (m_checkRechableReply->error() != QModbusDevice::NoError)
            onReachabilityCheckFailed();

        m_checkRechableReply->deleteLater();
        m_checkRechableReply = nullptr;
    });

    connect(m_checkRechableReply, &QModbusReply::errorOccurred, this, [this] (QModbusDevice::Error error){
        qCDebug(dcQCellsModbusTcpConnection()) << "Modbus reply error occurred while verifying reachability by reading \"Modbus Address of the EVC (0x1000)\" register" << error << m_checkRechableReply->errorString();
    });
}

void QCellsModbusTcpConnection::verifyInitFinished()
{
    if (m_pendingInitReplies.isEmpty()) {
        finishInitialization(true);
    }
}

void QCellsModbusTcpConnection::finishInitialization(bool success)
{
    if (success) {
        qCDebug(dcQCellsModbusTcpConnection()) << "Initialization finished of QCellsModbusTcpConnection" << hostAddress().toString() << "finished successfully";
    } else {
        qCWarning(dcQCellsModbusTcpConnection()) << "Initialization finished of QCellsModbusTcpConnection" << hostAddress().toString() << "failed.";
    }

    // Cleanup init
    delete m_initObject;
    m_initObject = nullptr;
    m_pendingInitReplies.clear();

    emit initializationFinished(success);
}

void QCellsModbusTcpConnection::verifyUpdateFinished()
{
    if (m_pendingUpdateReplies.isEmpty()) {
        emit updateFinished();
    }
}

void QCellsModbusTcpConnection::onReachabilityCheckFailed()
{
    m_checkReachableRetriesCount++;

    if (m_checkReachableRetriesCount <= m_checkReachableRetries) {
        qCDebug(dcQCellsModbusTcpConnection()) << "Reachability test failed. Retry in on second" << m_checkReachableRetriesCount << "/" << m_checkReachableRetries;
        QTimer::singleShot(1000, this, &QCellsModbusTcpConnection::testReachability);
        return;
    }

    // The test reachability method failed, not retrying any more
    emit checkReachabilityFailed();
}

void QCellsModbusTcpConnection::evaluateReachableState()
{
    bool reachable = m_communicationWorking && connected();
    if (m_reachable == reachable)
        return;

    m_reachable = reachable;
    emit reachableChanged(m_reachable);
    m_checkReachableRetriesCount = 0;
}

QDebug operator<<(QDebug debug, QCellsModbusTcpConnection *qCellsModbusTcpConnection)
{
    debug.nospace().noquote() << "QCellsModbusTcpConnection(" << qCellsModbusTcpConnection->hostAddress().toString() << ":" << qCellsModbusTcpConnection->port() << ")" << "\n";
    debug.nospace().noquote() << "    - Work Mode of the EVC (0x3000): " << qCellsModbusTcpConnection->workMode() << "\n";
    debug.nospace().noquote() << "    - Software version of EVC (0x1001): " << qCellsModbusTcpConnection->firmwareVersion() << "\n";
    debug.nospace().noquote() << "    - Maximum supported power of the EVC (0x1011): " << qCellsModbusTcpConnection->maxSupportedPower() << " [kW]" << "\n";
    debug.nospace().noquote() << "    - Modbus Address of the EVC (0x1000): " << qCellsModbusTcpConnection->deviceAddress() << "\n";
    debug.nospace().noquote() << "    - Unused Software version of EVC (0x1001): " << qCellsModbusTcpConnection->firmwareVersionUnused() << "\n";
    debug.nospace().noquote() << "    - Stop reason of the EVC (0x1002): " << qCellsModbusTcpConnection->stopReason() << "\n";
    debug.nospace().noquote() << "    - Status of the EVC (0x1003): " << qCellsModbusTcpConnection->deviceStatus() << "\n";
    debug.nospace().noquote() << "    - CP voltage level status of the EVC (0x1004): " << qCellsModbusTcpConnection->cpStatus() << "\n";
    debug.nospace().noquote() << "    - Plug status of the EVC (0x1005): " << qCellsModbusTcpConnection->plugStatus() << "\n";
    debug.nospace().noquote() << "    - Charging Port Temperature of the EVC (0x1006): " << qCellsModbusTcpConnection->cpTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - Environment Temperature of the EVC (0x1007): " << qCellsModbusTcpConnection->envTemperature() << " [°C]" << "\n";
    debug.nospace().noquote() << "    - Voltage of phase A (0x1008): " << qCellsModbusTcpConnection->voltagePhaseA() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Voltage of phase B (0x1009): " << qCellsModbusTcpConnection->voltagePhaseB() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Voltage of phase C (0x100A): " << qCellsModbusTcpConnection->voltagePhaseC() << " [V]" << "\n";
    debug.nospace().noquote() << "    - Current of phase A (0x100B): " << qCellsModbusTcpConnection->currentPhaseA() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Current of phase B (0x100C): " << qCellsModbusTcpConnection->currentPhaseB() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Current of phase C (0x100D): " << qCellsModbusTcpConnection->currentPhaseC() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Current power of the EVC (0x100E): " << qCellsModbusTcpConnection->currentPower() << " [kW]" << "\n";
    debug.nospace().noquote() << "    - State of the electronic lock (0x100F): " << qCellsModbusTcpConnection->lockState() << "\n";
    debug.nospace().noquote() << "    - Charging phase of EVC (0x1010): " << qCellsModbusTcpConnection->chargePhase() << "\n";
    debug.nospace().noquote() << "    - Unused Maximum supported power of the EVC (0x1011): " << qCellsModbusTcpConnection->maxSupportedPowerUnused() << " [kW]" << "\n";
    debug.nospace().noquote() << "    - Minimum supported power of the EVC (0x1012): " << qCellsModbusTcpConnection->minSupportedPower() << " [kW]" << "\n";
    debug.nospace().noquote() << "    - Maximum supported current of the EVC (0x1013): " << qCellsModbusTcpConnection->maxSupportedCurrent() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Minimum supported current of the EVC (0x1014): " << qCellsModbusTcpConnection->minSupportedCurrent() << " [A]" << "\n";
    debug.nospace().noquote() << "    - System alarm info of the EVC (0x1015): " << qCellsModbusTcpConnection->alarmInfo() << "\n";
    debug.nospace().noquote() << "    - Total energy conumed by the EVC (0x101A): " << qCellsModbusTcpConnection->totalEnergy() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Session energy consumed by the EVC (0x1016): " << qCellsModbusTcpConnection->sessionEnergyConsumed() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - System fault info of the EVC (0x101C): " << qCellsModbusTcpConnection->faultInfo() << "\n";
    debug.nospace().noquote() << "    - Model code of the EVC (0x101E): " << qCellsModbusTcpConnection->modelCode() << "\n";
    debug.nospace().noquote() << "    - Serial number of the EVC (0x1022): " << qCellsModbusTcpConnection->serialNumber() << "\n";
    debug.nospace().noquote() << "    - Maximum charging current of the EVC (0x3001): " << qCellsModbusTcpConnection->maxChargeCurrent() << " [A]" << "\n";
    debug.nospace().noquote() << "    - Maximum charging power of the EVC (0x3002): " << qCellsModbusTcpConnection->maxChargePower() << " [kW]" << "\n";
    debug.nospace().noquote() << "    - Maximum charge time (minutes) of the EVC (0x3003): " << qCellsModbusTcpConnection->maxChargeTime() << "\n";
    debug.nospace().noquote() << "    - Maximum charge energy of the EVC (0x3004): " << qCellsModbusTcpConnection->maxChargeEnergy() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Maximum charge time (minutes) of the EVC (0x3005): " << qCellsModbusTcpConnection->timeValidity() << " [kWh]" << "\n";
    debug.nospace().noquote() << "    - Default charging current of the EVC (0x3006): " << qCellsModbusTcpConnection->defaultCurrent() << " [A]" << "\n";
    return debug.quote().space();
}

