/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Copyright 2013 - 2024, nymea GmbH
* Contact: contact@nymea.io
*
* This fileDescriptor is part of nymea.
* This project including source code and documentation is protected by
* copyright law, and remains the property of nymea GmbH. All rights, including
* reproduction, publication, editing and translation, are reserved. The use of
* this project is subject to the terms of a license agreement to be concluded
* with nymea GmbH in accordance with the terms of use of nymea GmbH, available
* under https://nymea.io/license
*
* GNU Lesser General Public License Usage
* Alternatively, this project may be redistributed and/or modified under the
* terms of the GNU Lesser General Public License as published by the Free
* Software Foundation; version 3. This project is distributed in the hope that
* it will be useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this project. If not, see <https://www.gnu.org/licenses/>.
*
* For any further details and any questions please contact us under
* contact@nymea.io or see our FAQ/Licensing Information on
* https://nymea.io/license/faq
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WARNING
*
* This file has been autogenerated. Any changes in this file may be overwritten.
* If you want to change something, update the register json or the tool.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#include "dvmodbusirmodbusrtuconnection.h"
#include <loggingcategories.h>
#include <math.h>
#include <QTimer>

NYMEA_LOGGING_CATEGORY(dcDvModbusIRModbusRtuConnection, "DvModbusIRModbusRtuConnection")

DvModbusIRModbusRtuConnection::DvModbusIRModbusRtuConnection(ModbusRtuMaster *modbusRtuMaster, quint16 slaveId, QObject *parent) :
    QObject(parent),
    m_modbusRtuMaster(modbusRtuMaster),
    m_slaveId(slaveId)
{
    connect(m_modbusRtuMaster, &ModbusRtuMaster::connectedChanged, this, [=](bool connected){
        if (connected) {
            qCDebug(dcDvModbusIRModbusRtuConnection()) << "Modbus RTU resource" << m_modbusRtuMaster->serialPort() << "connected again. Start testing if the connection is reachable...";
            m_pendingInitReplies.clear();
            m_pendingUpdateReplies.clear();
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
            testReachability();
        } else {
            qCWarning(dcDvModbusIRModbusRtuConnection()) << "Modbus RTU resource" << m_modbusRtuMaster->serialPort() << "disconnected. The connection is not reachable any more.";
            m_communicationWorking = false;
            m_communicationFailedCounter = 0;
            m_checkReachableRetriesCount = 0;
        }

        evaluateReachableState();
    });

    if (m_modbusRtuMaster->connected()) {
        testReachability();
    } else {
        evaluateReachableState();
    }
}

ModbusRtuMaster *DvModbusIRModbusRtuConnection::modbusRtuMaster() const
{
    return m_modbusRtuMaster;
}
quint16 DvModbusIRModbusRtuConnection::slaveId() const
{
    return m_slaveId;
}

bool DvModbusIRModbusRtuConnection::reachable() const
{
    return m_reachable;
}

uint DvModbusIRModbusRtuConnection::checkReachableRetries() const
{
    return m_checkReachableRetries;
}

void DvModbusIRModbusRtuConnection::setCheckReachableRetries(uint checkReachableRetries)
{
    if (m_checkReachableRetries == checkReachableRetries)
        return;

    m_checkReachableRetries = checkReachableRetries;
    emit checkReachableRetriesChanged(m_checkReachableRetries);
}

ModbusDataUtils::ByteOrder DvModbusIRModbusRtuConnection::endianness() const
{
    return m_endianness;
}

void DvModbusIRModbusRtuConnection::setEndianness(ModbusDataUtils::ByteOrder endianness)
{
    if (m_endianness == endianness)
        return;

    m_endianness = endianness;
    emit endiannessChanged(m_endianness);
}

quint16 DvModbusIRModbusRtuConnection::serialNumber() const
{
    return m_serialNumber;
}

quint16 DvModbusIRModbusRtuConnection::deviceStatus() const
{
    return m_deviceStatus;
}

quint32 DvModbusIRModbusRtuConnection::meterId() const
{
    return m_meterId;
}

quint64 DvModbusIRModbusRtuConnection::totalConsumedEnergy() const
{
    return m_totalConsumedEnergy;
}

qint16 DvModbusIRModbusRtuConnection::consumedEnergyExponent() const
{
    return m_consumedEnergyExponent;
}

quint64 DvModbusIRModbusRtuConnection::totalProducedEnergy() const
{
    return m_totalProducedEnergy;
}

qint16 DvModbusIRModbusRtuConnection::producedEnergyExponent() const
{
    return m_producedEnergyExponent;
}

bool DvModbusIRModbusRtuConnection::initialize()
{
    if (!m_reachable) {
        qCWarning(dcDvModbusIRModbusRtuConnection()) << "Tried to initialize but the device is not to be reachable.";
        return false;
    }
    if (m_initObject) {
        qCWarning(dcDvModbusIRModbusRtuConnection()) << "Tried to initialize but the init process is already running.";
        return false;
    }

    // Parent object for the init process
    m_initObject = new QObject(this);

    ModbusRtuReply *reply = nullptr;

    // Read Serialnumber of read-out head.
    qCDebug(dcDvModbusIRModbusRtuConnection()) << "--> Read init \"Serialnumber of read-out head.\" register:" << 0 << "size:" << 1;
    reply = readSerialNumber();
    if (!reply) {
        qCWarning(dcDvModbusIRModbusRtuConnection()) << "Error occurred while reading \"Serialnumber of read-out head.\" registers";
        finishInitialization(false);
        return false;
    }

    if (reply->isFinished()) {
        finishInitialization(false); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, m_initObject, [this, reply](){
        handleModbusError(reply->error());
        m_pendingInitReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            finishInitialization(false);
            return;
        }

        QVector<quint16> values = reply->result();
        qCDebug(dcDvModbusIRModbusRtuConnection()) << "<-- Response from \"Serialnumber of read-out head.\" init register" << 0 << "size:" << 1 << values;
        processSerialNumberRegisterValues(values);
        verifyInitFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, m_initObject, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcDvModbusIRModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Serialnumber of read-out head.\" registers" << error << reply->errorString();
    });

    // Read Info about connected meters.
    qCDebug(dcDvModbusIRModbusRtuConnection()) << "--> Read init \"Info about connected meters.\" register:" << 4 << "size:" << 1;
    reply = readDeviceStatus();
    if (!reply) {
        qCWarning(dcDvModbusIRModbusRtuConnection()) << "Error occurred while reading \"Info about connected meters.\" registers";
        finishInitialization(false);
        return false;
    }

    if (reply->isFinished()) {
        finishInitialization(false); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, m_initObject, [this, reply](){
        handleModbusError(reply->error());
        m_pendingInitReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            finishInitialization(false);
            return;
        }

        QVector<quint16> values = reply->result();
        qCDebug(dcDvModbusIRModbusRtuConnection()) << "<-- Response from \"Info about connected meters.\" init register" << 4 << "size:" << 1 << values;
        processDeviceStatusRegisterValues(values);
        verifyInitFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, m_initObject, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcDvModbusIRModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Info about connected meters.\" registers" << error << reply->errorString();
    });

    // Read Devicenumber of connected meter.
    qCDebug(dcDvModbusIRModbusRtuConnection()) << "--> Read init \"Devicenumber of connected meter.\" register:" << 11 << "size:" << 2;
    reply = readMeterId();
    if (!reply) {
        qCWarning(dcDvModbusIRModbusRtuConnection()) << "Error occurred while reading \"Devicenumber of connected meter.\" registers";
        finishInitialization(false);
        return false;
    }

    if (reply->isFinished()) {
        finishInitialization(false); // Broadcast reply returns immediatly
        return false;
    }

    m_pendingInitReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, m_initObject, [this, reply](){
        handleModbusError(reply->error());
        m_pendingInitReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            finishInitialization(false);
            return;
        }

        QVector<quint16> values = reply->result();
        qCDebug(dcDvModbusIRModbusRtuConnection()) << "<-- Response from \"Devicenumber of connected meter.\" init register" << 11 << "size:" << 2 << values;
        processMeterIdRegisterValues(values);
        verifyInitFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, m_initObject, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcDvModbusIRModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Devicenumber of connected meter.\" registers" << error << reply->errorString();
    });
    return true;
}

bool DvModbusIRModbusRtuConnection::update()
{
    if (!m_modbusRtuMaster->connected()) {
        qCDebug(dcDvModbusIRModbusRtuConnection()) << "Tried to update the registers but the hardware resource seems not to be connected.";
        return false;
    }

    if (!m_pendingUpdateReplies.isEmpty()) {
        qCDebug(dcDvModbusIRModbusRtuConnection()) << "Tried to update the registers but there are still some update replies pending. Waiting for them to be finished...";
        return true;
    }

    // Hardware resource available but communication not working. 
    // Try to read the check reachability register to re-evaluatoe the communication... 
    if (m_modbusRtuMaster->connected() && !m_communicationWorking) {
        testReachability();
        return false;
    }

    ModbusRtuReply *reply = nullptr;

    // Read consumedEnergy
    qCDebug(dcDvModbusIRModbusRtuConnection()) << "--> Read block \"consumedEnergy\" registers from:" << 13 << "size:" << 5;
    reply = readBlockConsumedEnergy();
    if (!reply) {
        qCWarning(dcDvModbusIRModbusRtuConnection()) << "Error occurred while reading block \"consumedEnergy\" registers";
        return false;
    }

    if (reply->isFinished()) {
        return false; // Broadcast reply returns immediatly
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        m_pendingUpdateReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            verifyUpdateFinished();
            return;
        }

        QVector<quint16> blockValues = reply->result();
        qCDebug(dcDvModbusIRModbusRtuConnection()) << "<-- Response from reading block \"consumedEnergy\" register" << 13 << "size:" << 5 << blockValues;
        processTotalConsumedEnergyRegisterValues(blockValues.mid(0, 4));
        processConsumedEnergyExponentRegisterValues(blockValues.mid(4, 1));
        verifyUpdateFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcDvModbusIRModbusRtuConnection()) << "ModbusRtu reply error occurred while updating block \"consumedEnergy\" registers" << error << reply->errorString();
    });


    // Read producedEnergy
    qCDebug(dcDvModbusIRModbusRtuConnection()) << "--> Read block \"producedEnergy\" registers from:" << 28 << "size:" << 5;
    reply = readBlockProducedEnergy();
    if (!reply) {
        qCWarning(dcDvModbusIRModbusRtuConnection()) << "Error occurred while reading block \"producedEnergy\" registers";
        return false;
    }

    if (reply->isFinished()) {
        return false; // Broadcast reply returns immediatly
    }

    m_pendingUpdateReplies.append(reply);
    connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
        handleModbusError(reply->error());
        m_pendingUpdateReplies.removeAll(reply);

        if (reply->error() != ModbusRtuReply::NoError) {
            verifyUpdateFinished();
            return;
        }

        QVector<quint16> blockValues = reply->result();
        qCDebug(dcDvModbusIRModbusRtuConnection()) << "<-- Response from reading block \"producedEnergy\" register" << 28 << "size:" << 5 << blockValues;
        processTotalProducedEnergyRegisterValues(blockValues.mid(0, 4));
        processProducedEnergyExponentRegisterValues(blockValues.mid(4, 1));
        verifyUpdateFinished();
    });

    connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
        qCWarning(dcDvModbusIRModbusRtuConnection()) << "ModbusRtu reply error occurred while updating block \"producedEnergy\" registers" << error << reply->errorString();
    });

    return true;
}

void DvModbusIRModbusRtuConnection::updateTotalConsumedEnergy()
{
    // Update registers from Total consumed energy without comma.
    qCDebug(dcDvModbusIRModbusRtuConnection()) << "--> Read \"Total consumed energy without comma.\" register:" << 13 << "size:" << 4;
    ModbusRtuReply *reply = readTotalConsumedEnergy();
    if (!reply) {
        qCWarning(dcDvModbusIRModbusRtuConnection()) << "Error occurred while reading \"Total consumed energy without comma.\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcDvModbusIRModbusRtuConnection()) << "<-- Response from \"Total consumed energy without comma.\" register" << 13 << "size:" << 4 << values;
                processTotalConsumedEnergyRegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcDvModbusIRModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Total consumed energy without comma.\" registers" << error << reply->errorString();
        });
    }
}

void DvModbusIRModbusRtuConnection::updateConsumedEnergyExponent()
{
    // Update registers from 10-exponent for consumed energy.
    qCDebug(dcDvModbusIRModbusRtuConnection()) << "--> Read \"10-exponent for consumed energy.\" register:" << 17 << "size:" << 1;
    ModbusRtuReply *reply = readConsumedEnergyExponent();
    if (!reply) {
        qCWarning(dcDvModbusIRModbusRtuConnection()) << "Error occurred while reading \"10-exponent for consumed energy.\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcDvModbusIRModbusRtuConnection()) << "<-- Response from \"10-exponent for consumed energy.\" register" << 17 << "size:" << 1 << values;
                processConsumedEnergyExponentRegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcDvModbusIRModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"10-exponent for consumed energy.\" registers" << error << reply->errorString();
        });
    }
}

void DvModbusIRModbusRtuConnection::updateTotalProducedEnergy()
{
    // Update registers from Total produced energy without comma.
    qCDebug(dcDvModbusIRModbusRtuConnection()) << "--> Read \"Total produced energy without comma.\" register:" << 28 << "size:" << 4;
    ModbusRtuReply *reply = readTotalProducedEnergy();
    if (!reply) {
        qCWarning(dcDvModbusIRModbusRtuConnection()) << "Error occurred while reading \"Total produced energy without comma.\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcDvModbusIRModbusRtuConnection()) << "<-- Response from \"Total produced energy without comma.\" register" << 28 << "size:" << 4 << values;
                processTotalProducedEnergyRegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcDvModbusIRModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"Total produced energy without comma.\" registers" << error << reply->errorString();
        });
    }
}

void DvModbusIRModbusRtuConnection::updateProducedEnergyExponent()
{
    // Update registers from 10-exponent for produced energy.
    qCDebug(dcDvModbusIRModbusRtuConnection()) << "--> Read \"10-exponent for produced energy.\" register:" << 32 << "size:" << 1;
    ModbusRtuReply *reply = readProducedEnergyExponent();
    if (!reply) {
        qCWarning(dcDvModbusIRModbusRtuConnection()) << "Error occurred while reading \"10-exponent for produced energy.\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> values = reply->result();
                qCDebug(dcDvModbusIRModbusRtuConnection()) << "<-- Response from \"10-exponent for produced energy.\" register" << 32 << "size:" << 1 << values;
                processProducedEnergyExponentRegisterValues(values);
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcDvModbusIRModbusRtuConnection()) << "ModbusRtu reply error occurred while updating \"10-exponent for produced energy.\" registers" << error << reply->errorString();
        });
    }
}

void DvModbusIRModbusRtuConnection::updateConsumedEnergyBlock()
{
    // Update register block "consumedEnergy"
    qCDebug(dcDvModbusIRModbusRtuConnection()) << "--> Read block \"consumedEnergy\" registers from:" << 13 << "size:" << 5;
    ModbusRtuReply *reply = m_modbusRtuMaster->readHoldingRegister(m_slaveId, 13, 5);
    if (!reply) {
        qCWarning(dcDvModbusIRModbusRtuConnection()) << "Error occurred while reading block \"consumedEnergy\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> blockValues = reply->result();
                qCDebug(dcDvModbusIRModbusRtuConnection()) << "<-- Response from reading block \"consumedEnergy\" register" << 13 << "size:" << 5 << blockValues;
                processTotalConsumedEnergyRegisterValues(blockValues.mid(0, 4));
                processConsumedEnergyExponentRegisterValues(blockValues.mid(4, 1));
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcDvModbusIRModbusRtuConnection()) << "ModbusRtu reply error occurred while updating block \"consumedEnergy\" registers" << error << reply->errorString();
        });
    }
}

void DvModbusIRModbusRtuConnection::updateProducedEnergyBlock()
{
    // Update register block "producedEnergy"
    qCDebug(dcDvModbusIRModbusRtuConnection()) << "--> Read block \"producedEnergy\" registers from:" << 28 << "size:" << 5;
    ModbusRtuReply *reply = m_modbusRtuMaster->readHoldingRegister(m_slaveId, 28, 5);
    if (!reply) {
        qCWarning(dcDvModbusIRModbusRtuConnection()) << "Error occurred while reading block \"producedEnergy\" registers";
        return;
    }

    if (!reply->isFinished()) {
        connect(reply, &ModbusRtuReply::finished, this, [this, reply](){
            handleModbusError(reply->error());
            if (reply->error() == ModbusRtuReply::NoError) {
                QVector<quint16> blockValues = reply->result();
                qCDebug(dcDvModbusIRModbusRtuConnection()) << "<-- Response from reading block \"producedEnergy\" register" << 28 << "size:" << 5 << blockValues;
                processTotalProducedEnergyRegisterValues(blockValues.mid(0, 4));
                processProducedEnergyExponentRegisterValues(blockValues.mid(4, 1));
            }
        });

        connect(reply, &ModbusRtuReply::errorOccurred, this, [reply] (ModbusRtuReply::Error error){
            qCWarning(dcDvModbusIRModbusRtuConnection()) << "ModbusRtu reply error occurred while updating block \"producedEnergy\" registers" << error << reply->errorString();
        });
    }
}

ModbusRtuReply *DvModbusIRModbusRtuConnection::readSerialNumber()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 0, 1);
}

ModbusRtuReply *DvModbusIRModbusRtuConnection::readDeviceStatus()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 4, 1);
}

ModbusRtuReply *DvModbusIRModbusRtuConnection::readMeterId()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 11, 2);
}

ModbusRtuReply *DvModbusIRModbusRtuConnection::readTotalConsumedEnergy()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 13, 4);
}

ModbusRtuReply *DvModbusIRModbusRtuConnection::readConsumedEnergyExponent()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 17, 1);
}

ModbusRtuReply *DvModbusIRModbusRtuConnection::readTotalProducedEnergy()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 28, 4);
}

ModbusRtuReply *DvModbusIRModbusRtuConnection::readProducedEnergyExponent()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 32, 1);
}

ModbusRtuReply *DvModbusIRModbusRtuConnection::readBlockConsumedEnergy()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 13, 5);
}

ModbusRtuReply *DvModbusIRModbusRtuConnection::readBlockProducedEnergy()
{
    return m_modbusRtuMaster->readHoldingRegister(m_slaveId, 28, 5);
}

void DvModbusIRModbusRtuConnection::processSerialNumberRegisterValues(const QVector<quint16> values)
{
    quint16 receivedSerialNumber = ModbusDataUtils::convertToUInt16(values);
    emit serialNumberReadFinished(receivedSerialNumber);

    if (m_serialNumber != receivedSerialNumber) {
        m_serialNumber = receivedSerialNumber;
        emit serialNumberChanged(m_serialNumber);
    }
}

void DvModbusIRModbusRtuConnection::processDeviceStatusRegisterValues(const QVector<quint16> values)
{
    quint16 receivedDeviceStatus = ModbusDataUtils::convertToUInt16(values);
    emit deviceStatusReadFinished(receivedDeviceStatus);

    if (m_deviceStatus != receivedDeviceStatus) {
        m_deviceStatus = receivedDeviceStatus;
        emit deviceStatusChanged(m_deviceStatus);
    }
}

void DvModbusIRModbusRtuConnection::processMeterIdRegisterValues(const QVector<quint16> values)
{
    quint32 receivedMeterId = ModbusDataUtils::convertToUInt32(values, m_endianness);
    emit meterIdReadFinished(receivedMeterId);

    if (m_meterId != receivedMeterId) {
        m_meterId = receivedMeterId;
        emit meterIdChanged(m_meterId);
    }
}

void DvModbusIRModbusRtuConnection::processTotalConsumedEnergyRegisterValues(const QVector<quint16> values)
{
    quint64 receivedTotalConsumedEnergy = ModbusDataUtils::convertToUInt64(values, m_endianness);
    emit totalConsumedEnergyReadFinished(receivedTotalConsumedEnergy);

    if (m_totalConsumedEnergy != receivedTotalConsumedEnergy) {
        m_totalConsumedEnergy = receivedTotalConsumedEnergy;
        emit totalConsumedEnergyChanged(m_totalConsumedEnergy);
    }
}

void DvModbusIRModbusRtuConnection::processConsumedEnergyExponentRegisterValues(const QVector<quint16> values)
{
    qint16 receivedConsumedEnergyExponent = ModbusDataUtils::convertToInt16(values);
    emit consumedEnergyExponentReadFinished(receivedConsumedEnergyExponent);

    if (m_consumedEnergyExponent != receivedConsumedEnergyExponent) {
        m_consumedEnergyExponent = receivedConsumedEnergyExponent;
        emit consumedEnergyExponentChanged(m_consumedEnergyExponent);
    }
}

void DvModbusIRModbusRtuConnection::processTotalProducedEnergyRegisterValues(const QVector<quint16> values)
{
    quint64 receivedTotalProducedEnergy = ModbusDataUtils::convertToUInt64(values, m_endianness);
    emit totalProducedEnergyReadFinished(receivedTotalProducedEnergy);

    if (m_totalProducedEnergy != receivedTotalProducedEnergy) {
        m_totalProducedEnergy = receivedTotalProducedEnergy;
        emit totalProducedEnergyChanged(m_totalProducedEnergy);
    }
}

void DvModbusIRModbusRtuConnection::processProducedEnergyExponentRegisterValues(const QVector<quint16> values)
{
    qint16 receivedProducedEnergyExponent = ModbusDataUtils::convertToInt16(values);
    emit producedEnergyExponentReadFinished(receivedProducedEnergyExponent);

    if (m_producedEnergyExponent != receivedProducedEnergyExponent) {
        m_producedEnergyExponent = receivedProducedEnergyExponent;
        emit producedEnergyExponentChanged(m_producedEnergyExponent);
    }
}

void DvModbusIRModbusRtuConnection::handleModbusError(ModbusRtuReply::Error error)
{
    if (error == ModbusRtuReply::NoError) {
        // Reset the communication counter and we know we can reach the device
        m_communicationFailedCounter = 0;
        if (!m_communicationWorking)
            qCDebug(dcDvModbusIRModbusRtuConnection()) << "Received a reply without any errors. The communication with the device seems to work now.";

        m_communicationWorking = true;
        evaluateReachableState();
    } else {
        m_communicationFailedCounter++;
        if (m_communicationWorking && m_communicationFailedCounter >= m_communicationFailedMax) {
            m_communicationWorking = false;
            qCWarning(dcDvModbusIRModbusRtuConnection()) << "Received" << m_communicationFailedCounter << "errors while communicating with the RTU master. Mark as not reachable until the communication works again.";
            evaluateReachableState();
        }
    }
}

void DvModbusIRModbusRtuConnection::testReachability()
{
    if (m_checkRechableReply)
        return;

    // Try to read the check reachability register serialNumber in order to verify if the communication is working or not.
    qCDebug(dcDvModbusIRModbusRtuConnection()) << "--> Test reachability by reading \"Serialnumber of read-out head.\" register:" << 0 << "size:" << 1;
    m_checkRechableReply = readSerialNumber();
    if (!m_checkRechableReply) {
        qCDebug(dcDvModbusIRModbusRtuConnection()) << "Error occurred verifying reachability by reading \"Serialnumber of read-out head.\" register";
        onReachabilityCheckFailed();
        return;
    }

    if (m_checkRechableReply->isFinished()) {
        m_checkRechableReply = nullptr;
        onReachabilityCheckFailed();
        return;
    }

    connect(m_checkRechableReply, &ModbusRtuReply::finished, this, [this](){
        // Note: we don't care about the result here, only the error
        handleModbusError(m_checkRechableReply->error());
        if (m_checkRechableReply->error() != ModbusRtuReply::NoError)
            onReachabilityCheckFailed();

        m_checkRechableReply = nullptr;
    });

    connect(m_checkRechableReply, &ModbusRtuReply::errorOccurred, this, [this] (ModbusRtuReply::Error error){
        qCDebug(dcDvModbusIRModbusRtuConnection()) << "ModbusRtu reply error occurred while verifying reachability by reading \"Serialnumber of read-out head.\" register" << error << m_checkRechableReply->errorString();
    });
}

void DvModbusIRModbusRtuConnection::verifyInitFinished()
{
    if (m_pendingInitReplies.isEmpty()) {
        finishInitialization(true);
    }
}

void DvModbusIRModbusRtuConnection::finishInitialization(bool success)
{
    if (success) {
        qCDebug(dcDvModbusIRModbusRtuConnection()) << "Initialization finished of DvModbusIRModbusRtuConnection finished successfully";
    } else {
        qCWarning(dcDvModbusIRModbusRtuConnection()) << "Initialization finished of DvModbusIRModbusRtuConnection failed.";
    }

    // Cleanup init
    delete m_initObject;
    m_initObject = nullptr;
    m_pendingInitReplies.clear();

    emit initializationFinished(success);
}

void DvModbusIRModbusRtuConnection::verifyUpdateFinished()
{
    if (m_pendingUpdateReplies.isEmpty()) {
        emit updateFinished();
    }
}

void DvModbusIRModbusRtuConnection::onReachabilityCheckFailed()
{
    m_checkReachableRetriesCount++;

    if (m_checkReachableRetriesCount <= m_checkReachableRetries) {
        qCDebug(dcDvModbusIRModbusRtuConnection()) << "Reachability test failed. Retry in on second" << m_checkReachableRetriesCount << "/" << m_checkReachableRetries;
        QTimer::singleShot(1000, this, &DvModbusIRModbusRtuConnection::testReachability);
        return;
    }

    // The test reachability method failed, not retrying any more
    emit checkReachabilityFailed();
}

void DvModbusIRModbusRtuConnection::evaluateReachableState()
{
    bool reachable = m_communicationWorking && m_modbusRtuMaster->connected();
    if (m_reachable == reachable)
        return;

    m_reachable = reachable;
    emit reachableChanged(m_reachable);
    m_checkReachableRetriesCount = 0;
}

QDebug operator<<(QDebug debug, DvModbusIRModbusRtuConnection *dvModbusIRModbusRtuConnection)
{
    debug.nospace().noquote() << "DvModbusIRModbusRtuConnection(" << dvModbusIRModbusRtuConnection->modbusRtuMaster()->modbusUuid().toString() << ", " << dvModbusIRModbusRtuConnection->modbusRtuMaster()->serialPort() << ", slave ID:" << dvModbusIRModbusRtuConnection->slaveId() << ")" << "\n";
    debug.nospace().noquote() << "    - Serialnumber of read-out head.: " << dvModbusIRModbusRtuConnection->serialNumber() << "\n";
    debug.nospace().noquote() << "    - Info about connected meters.: " << dvModbusIRModbusRtuConnection->deviceStatus() << "\n";
    debug.nospace().noquote() << "    - Devicenumber of connected meter.: " << dvModbusIRModbusRtuConnection->meterId() << "\n";
    debug.nospace().noquote() << "    - Total consumed energy without comma.: " << dvModbusIRModbusRtuConnection->totalConsumedEnergy() << "\n";
    debug.nospace().noquote() << "    - 10-exponent for consumed energy.: " << dvModbusIRModbusRtuConnection->consumedEnergyExponent() << "\n";
    debug.nospace().noquote() << "    - Total produced energy without comma.: " << dvModbusIRModbusRtuConnection->totalProducedEnergy() << "\n";
    debug.nospace().noquote() << "    - 10-exponent for produced energy.: " << dvModbusIRModbusRtuConnection->producedEnergyExponent() << "\n";
    return debug.quote().space();
}

